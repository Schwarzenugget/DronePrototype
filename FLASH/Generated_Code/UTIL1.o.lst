   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UTIL1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.UTIL1_strcpy,"ax",%progbits
  18              		.align	2
  19              		.global	UTIL1_strcpy
  20              		.code	16
  21              		.thumb_func
  23              	UTIL1_strcpy:
  24              	.LFB0:
  25              		.file 1 "../Generated_Code/UTIL1.c"
   1:../Generated_Code/UTIL1.c **** /* ###################################################################
   2:../Generated_Code/UTIL1.c **** **     This component module is generated by Processor Expert. Do not modify it.
   3:../Generated_Code/UTIL1.c **** **     Filename    : UTIL1.c
   4:../Generated_Code/UTIL1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/UTIL1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/UTIL1.c **** **     Component   : Utility
   7:../Generated_Code/UTIL1.c **** **     Version     : Component 01.158, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/UTIL1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/UTIL1.c **** **     Date/Time   : 2018-06-06, 15:30, # CodeGen: 52
  10:../Generated_Code/UTIL1.c **** **     Abstract    :
  11:../Generated_Code/UTIL1.c **** **          Contains various utility functions.
  12:../Generated_Code/UTIL1.c **** **     Settings    :
  13:../Generated_Code/UTIL1.c **** **          Component name                                 : UTIL1
  14:../Generated_Code/UTIL1.c **** **     Contents    :
  15:../Generated_Code/UTIL1.c **** **         strcpy                  - void UTIL1_strcpy(uint8_t *dst, size_t dstSize, const unsigned
  16:../Generated_Code/UTIL1.c **** **         strcat                  - void UTIL1_strcat(uint8_t *dst, size_t dstSize, const unsigned
  17:../Generated_Code/UTIL1.c **** **         strcatPad               - void UTIL1_strcatPad(uint8_t *dst, size_t dstSize, const unsig
  18:../Generated_Code/UTIL1.c **** **         chcat                   - void UTIL1_chcat(uint8_t *dst, size_t dstSize, uint8_t ch);
  19:../Generated_Code/UTIL1.c **** **         Num8sToStr              - void UTIL1_Num8sToStr(uint8_t *dst, size_t dstSize, signed cha
  20:../Generated_Code/UTIL1.c **** **         Num8uToStr              - void UTIL1_Num8uToStr(uint8_t *dst, size_t dstSize, uint8_t va
  21:../Generated_Code/UTIL1.c **** **         Num16sToStr             - void UTIL1_Num16sToStr(uint8_t *dst, size_t dstSize, int16_t v
  22:../Generated_Code/UTIL1.c **** **         Num16uToStr             - void UTIL1_Num16uToStr(uint8_t *dst, size_t dstSize, uint16_t 
  23:../Generated_Code/UTIL1.c **** **         Num32uToStr             - void UTIL1_Num32uToStr(uint8_t *dst, size_t dstSize, uint32_t 
  24:../Generated_Code/UTIL1.c **** **         Num32sToStr             - void UTIL1_Num32sToStr(uint8_t *dst, size_t dstSize, int32_t v
  25:../Generated_Code/UTIL1.c **** **         NumFloatToStr           - void UTIL1_NumFloatToStr(uint8_t *dst, size_t dstSize, float v
  26:../Generated_Code/UTIL1.c **** **         Num16sToStrFormatted    - void UTIL1_Num16sToStrFormatted(uint8_t *dst, size_t dstSize, 
  27:../Generated_Code/UTIL1.c **** **         Num16uToStrFormatted    - void UTIL1_Num16uToStrFormatted(uint8_t *dst, size_t dstSize, 
  28:../Generated_Code/UTIL1.c **** **         Num32uToStrFormatted    - void UTIL1_Num32uToStrFormatted(uint8_t *dst, size_t dstSize, 
  29:../Generated_Code/UTIL1.c **** **         Num32sToStrFormatted    - void UTIL1_Num32sToStrFormatted(uint8_t *dst, size_t dstSize, 
  30:../Generated_Code/UTIL1.c **** **         strcatNum8u             - void UTIL1_strcatNum8u(uint8_t *dst, size_t dstSize, uint8_t v
  31:../Generated_Code/UTIL1.c **** **         strcatNum8s             - void UTIL1_strcatNum8s(uint8_t *dst, size_t dstSize, signed ch
  32:../Generated_Code/UTIL1.c **** **         strcatNum16u            - void UTIL1_strcatNum16u(uint8_t *dst, size_t dstSize, uint16_t
  33:../Generated_Code/UTIL1.c **** **         strcatNum16s            - void UTIL1_strcatNum16s(uint8_t *dst, size_t dstSize, int16_t 
  34:../Generated_Code/UTIL1.c **** **         strcatNum32u            - void UTIL1_strcatNum32u(uint8_t *dst, size_t dstSize, uint32_t
  35:../Generated_Code/UTIL1.c **** **         strcatNum32s            - void UTIL1_strcatNum32s(uint8_t *dst, size_t dstSize, int32_t 
  36:../Generated_Code/UTIL1.c **** **         strcatNum16uFormatted   - void UTIL1_strcatNum16uFormatted(uint8_t *dst, size_t dstSize,
  37:../Generated_Code/UTIL1.c **** **         strcatNum16sFormatted   - void UTIL1_strcatNum16sFormatted(uint8_t *dst, size_t dstSize,
  38:../Generated_Code/UTIL1.c **** **         strcatNum32uFormatted   - void UTIL1_strcatNum32uFormatted(uint8_t *dst, size_t dstSize,
  39:../Generated_Code/UTIL1.c **** **         strcatNum32sFormatted   - void UTIL1_strcatNum32sFormatted(uint8_t *dst, size_t dstSize,
  40:../Generated_Code/UTIL1.c **** **         strcatNum8Hex           - void UTIL1_strcatNum8Hex(uint8_t *dst, size_t dstSize, uint8_t
  41:../Generated_Code/UTIL1.c **** **         strcatNum16Hex          - void UTIL1_strcatNum16Hex(uint8_t *dst, size_t dstSize, uint16
  42:../Generated_Code/UTIL1.c **** **         strcatNum24Hex          - void UTIL1_strcatNum24Hex(uint8_t *dst, size_t dstSize, uint32
  43:../Generated_Code/UTIL1.c **** **         strcatNum32Hex          - void UTIL1_strcatNum32Hex(uint8_t *dst, size_t dstSize, uint32
  44:../Generated_Code/UTIL1.c **** **         strcatNum32sDotValue100 - void UTIL1_strcatNum32sDotValue100(uint8_t *dst, size_t dstSiz
  45:../Generated_Code/UTIL1.c **** **         strcatNumFloat          - void UTIL1_strcatNumFloat(uint8_t *dst, size_t dstSize, float 
  46:../Generated_Code/UTIL1.c **** **         IsLeapYear              - bool UTIL1_IsLeapYear(uint16_t year);
  47:../Generated_Code/UTIL1.c **** **         WeekDay                 - uint8_t UTIL1_WeekDay(uint16_t year, uint8_t month, uint8_t da
  48:../Generated_Code/UTIL1.c **** **         ReadEscapedName         - uint8_t UTIL1_ReadEscapedName(const unsigned char *filename, u
  49:../Generated_Code/UTIL1.c **** **         xatoi                   - uint8_t UTIL1_xatoi(const unsigned char **str, int32_t *res);
  50:../Generated_Code/UTIL1.c **** **         ScanDate                - uint8_t UTIL1_ScanDate(const unsigned char **str, uint8_t *day
  51:../Generated_Code/UTIL1.c **** **         ScanTime                - uint8_t UTIL1_ScanTime(const unsigned char **str, uint8_t *hou
  52:../Generated_Code/UTIL1.c **** **         ScanDecimal8uNumber     - uint8_t UTIL1_ScanDecimal8uNumber(const unsigned char **str, u
  53:../Generated_Code/UTIL1.c **** **         ScanDecimal8sNumber     - uint8_t UTIL1_ScanDecimal8sNumber(const unsigned char **str, s
  54:../Generated_Code/UTIL1.c **** **         ScanDecimal16uNumber    - uint8_t UTIL1_ScanDecimal16uNumber(const unsigned char **str, 
  55:../Generated_Code/UTIL1.c **** **         ScanDecimal16sNumber    - uint8_t UTIL1_ScanDecimal16sNumber(const unsigned char **str, 
  56:../Generated_Code/UTIL1.c **** **         ScanDecimal32uNumber    - uint8_t UTIL1_ScanDecimal32uNumber(const unsigned char **str, 
  57:../Generated_Code/UTIL1.c **** **         ScanDecimal32sNumber    - uint8_t UTIL1_ScanDecimal32sNumber(const unsigned char **str, 
  58:../Generated_Code/UTIL1.c **** **         ScanDecimal32sDotNumber - uint8_t UTIL1_ScanDecimal32sDotNumber(const unsigned char **st
  59:../Generated_Code/UTIL1.c **** **         ScanHex8uNumber         - uint8_t UTIL1_ScanHex8uNumber(const unsigned char **str, uint8
  60:../Generated_Code/UTIL1.c **** **         ScanHex8uNumberNoPrefix - uint8_t UTIL1_ScanHex8uNumberNoPrefix(const unsigned char **st
  61:../Generated_Code/UTIL1.c **** **         ScanHex16uNumber        - uint8_t UTIL1_ScanHex16uNumber(const unsigned char **str, uint
  62:../Generated_Code/UTIL1.c **** **         ScanHex32uNumber        - uint8_t UTIL1_ScanHex32uNumber(const unsigned char **str, uint
  63:../Generated_Code/UTIL1.c **** **         ScanSeparatedNumbers    - uint8_t UTIL1_ScanSeparatedNumbers(const unsigned char **str, 
  64:../Generated_Code/UTIL1.c **** **         ScanDoubleQuotedString  - uint8_t UTIL1_ScanDoubleQuotedString(const uint8_t **cmd, uint
  65:../Generated_Code/UTIL1.c **** **         strcmp                  - int16_t UTIL1_strcmp(const char *, const char *);
  66:../Generated_Code/UTIL1.c **** **         strncmp                 - int16_t UTIL1_strncmp(const char *, const char *, size_t size)
  67:../Generated_Code/UTIL1.c **** **         strFind                 - int16_t UTIL1_strFind(uint8_t *str, uint8_t *subStr);
  68:../Generated_Code/UTIL1.c **** **         strtailcmp              - uint8_t UTIL1_strtailcmp(const uint8_t *str, const uint8_t *ta
  69:../Generated_Code/UTIL1.c **** **         strlen                  - uint16_t UTIL1_strlen(const char *);
  70:../Generated_Code/UTIL1.c **** **         strCutTail              - uint8_t UTIL1_strCutTail(uint8_t *str, uint8_t *tail);
  71:../Generated_Code/UTIL1.c **** **         GetValue16LE            - uint16_t UTIL1_GetValue16LE(uint8_t *dataP);
  72:../Generated_Code/UTIL1.c **** **         GetValue24LE            - uint32_t UTIL1_GetValue24LE(uint8_t *dataP);
  73:../Generated_Code/UTIL1.c **** **         GetValue32LE            - uint32_t UTIL1_GetValue32LE(uint8_t *dataP);
  74:../Generated_Code/UTIL1.c **** **         SetValue16LE            - void UTIL1_SetValue16LE(uint16_t data, uint8_t *dataP);
  75:../Generated_Code/UTIL1.c **** **         SetValue24LE            - void UTIL1_SetValue24LE(uint32_t data, uint8_t *dataP);
  76:../Generated_Code/UTIL1.c **** **         SetValue32LE            - void UTIL1_SetValue32LE(uint32_t data, uint8_t *dataP);
  77:../Generated_Code/UTIL1.c **** **         map                     - int32_t UTIL1_map(int32_t x, int32_t in_min, int32_t in_max, i
  78:../Generated_Code/UTIL1.c **** **         map64                   - int64_t UTIL1_map64(int64_t x, int64_t in_min, int64_t in_max,
  79:../Generated_Code/UTIL1.c **** **         constrain               - int32_t UTIL1_constrain(int32_t val, int32_t min, int32_t max)
  80:../Generated_Code/UTIL1.c **** **         random                  - int32_t UTIL1_random(int32_t min, int32_t max);
  81:../Generated_Code/UTIL1.c **** **         randomSetSeed           - void UTIL1_randomSetSeed(unsigned int seed);
  82:../Generated_Code/UTIL1.c **** **         Deinit                  - void UTIL1_Deinit(void);
  83:../Generated_Code/UTIL1.c **** **         Init                    - void UTIL1_Init(void);
  84:../Generated_Code/UTIL1.c **** **
  85:../Generated_Code/UTIL1.c **** **     * Copyright (c) 2014-2018, Erich Styger
  86:../Generated_Code/UTIL1.c **** **      * Web:         https://mcuoneclipse.com
  87:../Generated_Code/UTIL1.c **** **      * SourceForge: https://sourceforge.net/projects/mcuoneclipse
  88:../Generated_Code/UTIL1.c **** **      * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
  89:../Generated_Code/UTIL1.c **** **      * All rights reserved.
  90:../Generated_Code/UTIL1.c **** **      *
  91:../Generated_Code/UTIL1.c **** **      * Redistribution and use in source and binary forms, with or without modification,
  92:../Generated_Code/UTIL1.c **** **      * are permitted provided that the following conditions are met:
  93:../Generated_Code/UTIL1.c **** **      *
  94:../Generated_Code/UTIL1.c **** **      * - Redistributions of source code must retain the above copyright notice, this list
  95:../Generated_Code/UTIL1.c **** **      *   of conditions and the following disclaimer.
  96:../Generated_Code/UTIL1.c **** **      *
  97:../Generated_Code/UTIL1.c **** **      * - Redistributions in binary form must reproduce the above copyright notice, this
  98:../Generated_Code/UTIL1.c **** **      *   list of conditions and the following disclaimer in the documentation and/or
  99:../Generated_Code/UTIL1.c **** **      *   other materials provided with the distribution.
 100:../Generated_Code/UTIL1.c **** **      *
 101:../Generated_Code/UTIL1.c **** **      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 102:../Generated_Code/UTIL1.c **** **      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 103:../Generated_Code/UTIL1.c **** **      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 104:../Generated_Code/UTIL1.c **** **      * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 105:../Generated_Code/UTIL1.c **** **      * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 106:../Generated_Code/UTIL1.c **** **      * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 107:../Generated_Code/UTIL1.c **** **      * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 108:../Generated_Code/UTIL1.c **** **      * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 109:../Generated_Code/UTIL1.c **** **      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 110:../Generated_Code/UTIL1.c **** **      * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 111:../Generated_Code/UTIL1.c **** ** ###################################################################*/
 112:../Generated_Code/UTIL1.c **** /*!
 113:../Generated_Code/UTIL1.c **** ** @file UTIL1.c
 114:../Generated_Code/UTIL1.c **** ** @version 01.00
 115:../Generated_Code/UTIL1.c **** ** @brief
 116:../Generated_Code/UTIL1.c **** **          Contains various utility functions.
 117:../Generated_Code/UTIL1.c **** */         
 118:../Generated_Code/UTIL1.c **** /*!
 119:../Generated_Code/UTIL1.c **** **  @addtogroup UTIL1_module UTIL1 module documentation
 120:../Generated_Code/UTIL1.c **** **  @{
 121:../Generated_Code/UTIL1.c **** */         
 122:../Generated_Code/UTIL1.c **** 
 123:../Generated_Code/UTIL1.c **** /* MODULE UTIL1. */
 124:../Generated_Code/UTIL1.c **** 
 125:../Generated_Code/UTIL1.c **** #include "UTIL1.h"
 126:../Generated_Code/UTIL1.c **** #include <stdlib.h> /* for rand() */
 127:../Generated_Code/UTIL1.c **** 
 128:../Generated_Code/UTIL1.c **** /* Internal method prototypes */
 129:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(uint8_t *dst, uint8_t fill, uint8_t nofFill);
 130:../Generated_Code/UTIL1.c **** 
 131:../Generated_Code/UTIL1.c **** /*
 132:../Generated_Code/UTIL1.c **** ** ===================================================================
 133:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcpy (component Utility)
 134:../Generated_Code/UTIL1.c **** **     Description :
 135:../Generated_Code/UTIL1.c **** **         Same as normal strcpy, but safe as it does not write beyond
 136:../Generated_Code/UTIL1.c **** **         the buffer.
 137:../Generated_Code/UTIL1.c **** **     Parameters  :
 138:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 139:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 140:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 141:../Generated_Code/UTIL1.c **** **                           bytes).
 142:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
 143:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 144:../Generated_Code/UTIL1.c **** ** ===================================================================
 145:../Generated_Code/UTIL1.c **** */
 146:../Generated_Code/UTIL1.c **** /*!
 147:../Generated_Code/UTIL1.c ****   \brief copy the string src into dst. It performs the same task as strncpy, except
 148:../Generated_Code/UTIL1.c ****      - always terminates the result string.
 149:../Generated_Code/UTIL1.c ****      - does not zero out the remaining part in dst.
 150:../Generated_Code/UTIL1.c ****      Note: dstSize is the size of dst INCLUDING zero byte.
 151:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 152:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 153:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 154:../Generated_Code/UTIL1.c ****   \param[in] src The source string to copy
 155:../Generated_Code/UTIL1.c **** */
 156:../Generated_Code/UTIL1.c **** void UTIL1_strcpy(uint8_t *dst, size_t dstSize, const unsigned char *src)
 157:../Generated_Code/UTIL1.c **** {
  26              		.loc 1 157 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 84B0     		sub	sp, sp, #16
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 24
  36 0004 00AF     		add	r7, sp, #0
  37              	.LCFI2:
  38              		.cfi_def_cfa_register 7
  39 0006 F860     		str	r0, [r7, #12]
  40 0008 B960     		str	r1, [r7, #8]
  41 000a 7A60     		str	r2, [r7, #4]
 158:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
  42              		.loc 1 158 0
  43 000c BB68     		ldr	r3, [r7, #8]
  44 000e 013B     		sub	r3, r3, #1
  45 0010 BB60     		str	r3, [r7, #8]
 159:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
  46              		.loc 1 159 0
  47 0012 0CE0     		b	.L2
  48              	.L4:
 160:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
  49              		.loc 1 160 0
  50 0014 7B68     		ldr	r3, [r7, #4]
  51 0016 1A78     		ldrb	r2, [r3]
  52 0018 FB68     		ldr	r3, [r7, #12]
  53 001a 1A70     		strb	r2, [r3]
  54 001c FB68     		ldr	r3, [r7, #12]
  55 001e 0133     		add	r3, r3, #1
  56 0020 FB60     		str	r3, [r7, #12]
  57 0022 7B68     		ldr	r3, [r7, #4]
  58 0024 0133     		add	r3, r3, #1
  59 0026 7B60     		str	r3, [r7, #4]
 161:../Generated_Code/UTIL1.c ****     dstSize--;
  60              		.loc 1 161 0
  61 0028 BB68     		ldr	r3, [r7, #8]
  62 002a 013B     		sub	r3, r3, #1
  63 002c BB60     		str	r3, [r7, #8]
  64              	.L2:
 159:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
  65              		.loc 1 159 0
  66 002e BB68     		ldr	r3, [r7, #8]
  67 0030 002B     		cmp	r3, #0
  68 0032 03D0     		beq	.L3
 159:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
  69              		.loc 1 159 0 is_stmt 0
  70 0034 7B68     		ldr	r3, [r7, #4]
  71 0036 1B78     		ldrb	r3, [r3]
  72 0038 002B     		cmp	r3, #0
  73 003a EBD1     		bne	.L4
  74              	.L3:
 162:../Generated_Code/UTIL1.c ****   }
 163:../Generated_Code/UTIL1.c ****   *dst = '\0';
  75              		.loc 1 163 0 is_stmt 1
  76 003c FB68     		ldr	r3, [r7, #12]
  77 003e 0022     		mov	r2, #0
  78 0040 1A70     		strb	r2, [r3]
 164:../Generated_Code/UTIL1.c **** }
  79              		.loc 1 164 0
  80 0042 BD46     		mov	sp, r7
  81 0044 04B0     		add	sp, sp, #16
  82              		@ sp needed for prologue
  83 0046 80BD     		pop	{r7, pc}
  84              		.cfi_endproc
  85              	.LFE0:
  87              		.section	.text.UTIL1_strcat,"ax",%progbits
  88              		.align	2
  89              		.global	UTIL1_strcat
  90              		.code	16
  91              		.thumb_func
  93              	UTIL1_strcat:
  94              	.LFB1:
 165:../Generated_Code/UTIL1.c **** 
 166:../Generated_Code/UTIL1.c **** /*
 167:../Generated_Code/UTIL1.c **** ** ===================================================================
 168:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcat (component Utility)
 169:../Generated_Code/UTIL1.c **** **     Description :
 170:../Generated_Code/UTIL1.c **** **         Same as normal strcat, but safe as it does not write beyond
 171:../Generated_Code/UTIL1.c **** **         the buffer.
 172:../Generated_Code/UTIL1.c **** **     Parameters  :
 173:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 174:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 175:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 176:../Generated_Code/UTIL1.c **** **                           bytes).
 177:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
 178:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 179:../Generated_Code/UTIL1.c **** ** ===================================================================
 180:../Generated_Code/UTIL1.c **** */
 181:../Generated_Code/UTIL1.c **** /*!
 182:../Generated_Code/UTIL1.c ****   \brief Concat the string src into dst. Always terminates the result string.
 183:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 184:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 185:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 186:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 187:../Generated_Code/UTIL1.c ****   \param[in] src The source string to add
 188:../Generated_Code/UTIL1.c ****   */
 189:../Generated_Code/UTIL1.c **** void UTIL1_strcat(uint8_t *dst, size_t dstSize, const unsigned char *src)
 190:../Generated_Code/UTIL1.c **** {
  95              		.loc 1 190 0
  96              		.cfi_startproc
  97 0000 80B5     		push	{r7, lr}
  98              	.LCFI3:
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 84B0     		sub	sp, sp, #16
 103              	.LCFI4:
 104              		.cfi_def_cfa_offset 24
 105 0004 00AF     		add	r7, sp, #0
 106              	.LCFI5:
 107              		.cfi_def_cfa_register 7
 108 0006 F860     		str	r0, [r7, #12]
 109 0008 B960     		str	r1, [r7, #8]
 110 000a 7A60     		str	r2, [r7, #4]
 191:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 111              		.loc 1 191 0
 112 000c BB68     		ldr	r3, [r7, #8]
 113 000e 013B     		sub	r3, r3, #1
 114 0010 BB60     		str	r3, [r7, #8]
 192:../Generated_Code/UTIL1.c ****   /* point to the end of the source */
 193:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 115              		.loc 1 193 0
 116 0012 05E0     		b	.L6
 117              	.L8:
 194:../Generated_Code/UTIL1.c ****     dst++;
 118              		.loc 1 194 0
 119 0014 FB68     		ldr	r3, [r7, #12]
 120 0016 0133     		add	r3, r3, #1
 121 0018 FB60     		str	r3, [r7, #12]
 195:../Generated_Code/UTIL1.c ****     dstSize--;
 122              		.loc 1 195 0
 123 001a BB68     		ldr	r3, [r7, #8]
 124 001c 013B     		sub	r3, r3, #1
 125 001e BB60     		str	r3, [r7, #8]
 126              	.L6:
 193:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 127              		.loc 1 193 0
 128 0020 BB68     		ldr	r3, [r7, #8]
 129 0022 002B     		cmp	r3, #0
 130 0024 11D0     		beq	.L9
 193:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 131              		.loc 1 193 0 is_stmt 0
 132 0026 FB68     		ldr	r3, [r7, #12]
 133 0028 1B78     		ldrb	r3, [r3]
 134 002a 002B     		cmp	r3, #0
 135 002c F2D1     		bne	.L8
 196:../Generated_Code/UTIL1.c ****   }
 197:../Generated_Code/UTIL1.c ****   /* copy the src in the destination */
 198:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 136              		.loc 1 198 0 is_stmt 1
 137 002e 0CE0     		b	.L9
 138              	.L11:
 199:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
 139              		.loc 1 199 0
 140 0030 7B68     		ldr	r3, [r7, #4]
 141 0032 1A78     		ldrb	r2, [r3]
 142 0034 FB68     		ldr	r3, [r7, #12]
 143 0036 1A70     		strb	r2, [r3]
 144 0038 FB68     		ldr	r3, [r7, #12]
 145 003a 0133     		add	r3, r3, #1
 146 003c FB60     		str	r3, [r7, #12]
 147 003e 7B68     		ldr	r3, [r7, #4]
 148 0040 0133     		add	r3, r3, #1
 149 0042 7B60     		str	r3, [r7, #4]
 200:../Generated_Code/UTIL1.c ****     dstSize--;
 150              		.loc 1 200 0
 151 0044 BB68     		ldr	r3, [r7, #8]
 152 0046 013B     		sub	r3, r3, #1
 153 0048 BB60     		str	r3, [r7, #8]
 154              	.L9:
 198:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 155              		.loc 1 198 0
 156 004a BB68     		ldr	r3, [r7, #8]
 157 004c 002B     		cmp	r3, #0
 158 004e 03D0     		beq	.L10
 198:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 159              		.loc 1 198 0 is_stmt 0
 160 0050 7B68     		ldr	r3, [r7, #4]
 161 0052 1B78     		ldrb	r3, [r3]
 162 0054 002B     		cmp	r3, #0
 163 0056 EBD1     		bne	.L11
 164              	.L10:
 201:../Generated_Code/UTIL1.c ****   }
 202:../Generated_Code/UTIL1.c ****   /* terminate the string */
 203:../Generated_Code/UTIL1.c ****   *dst = '\0';
 165              		.loc 1 203 0 is_stmt 1
 166 0058 FB68     		ldr	r3, [r7, #12]
 167 005a 0022     		mov	r2, #0
 168 005c 1A70     		strb	r2, [r3]
 204:../Generated_Code/UTIL1.c **** }
 169              		.loc 1 204 0
 170 005e BD46     		mov	sp, r7
 171 0060 04B0     		add	sp, sp, #16
 172              		@ sp needed for prologue
 173 0062 80BD     		pop	{r7, pc}
 174              		.cfi_endproc
 175              	.LFE1:
 177              		.section	.text.UTIL1_chcat,"ax",%progbits
 178              		.align	2
 179              		.global	UTIL1_chcat
 180              		.code	16
 181              		.thumb_func
 183              	UTIL1_chcat:
 184              	.LFB2:
 205:../Generated_Code/UTIL1.c **** 
 206:../Generated_Code/UTIL1.c **** /*
 207:../Generated_Code/UTIL1.c **** ** ===================================================================
 208:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_chcat (component Utility)
 209:../Generated_Code/UTIL1.c **** **     Description :
 210:../Generated_Code/UTIL1.c **** **         Adds a single character to a zero byte terminated string
 211:../Generated_Code/UTIL1.c **** **         buffer. It cares about buffer overflow.
 212:../Generated_Code/UTIL1.c **** **     Parameters  :
 213:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 214:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 215:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 216:../Generated_Code/UTIL1.c **** **                           bytes).
 217:../Generated_Code/UTIL1.c **** **         ch              - character to append
 218:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 219:../Generated_Code/UTIL1.c **** ** ===================================================================
 220:../Generated_Code/UTIL1.c **** */
 221:../Generated_Code/UTIL1.c **** void UTIL1_chcat(uint8_t *dst, size_t dstSize, uint8_t ch)
 222:../Generated_Code/UTIL1.c **** {
 185              		.loc 1 222 0
 186              		.cfi_startproc
 187 0000 80B5     		push	{r7, lr}
 188              	.LCFI6:
 189              		.cfi_def_cfa_offset 8
 190              		.cfi_offset 7, -8
 191              		.cfi_offset 14, -4
 192 0002 84B0     		sub	sp, sp, #16
 193              	.LCFI7:
 194              		.cfi_def_cfa_offset 24
 195 0004 00AF     		add	r7, sp, #0
 196              	.LCFI8:
 197              		.cfi_def_cfa_register 7
 198 0006 F860     		str	r0, [r7, #12]
 199 0008 B960     		str	r1, [r7, #8]
 200 000a FB1D     		add	r3, r7, #7
 201 000c 1A70     		strb	r2, [r3]
 223:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 202              		.loc 1 223 0
 203 000e BB68     		ldr	r3, [r7, #8]
 204 0010 013B     		sub	r3, r3, #1
 205 0012 BB60     		str	r3, [r7, #8]
 224:../Generated_Code/UTIL1.c ****   /* point to the end of the source */
 225:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 206              		.loc 1 225 0
 207 0014 05E0     		b	.L13
 208              	.L15:
 226:../Generated_Code/UTIL1.c ****     dst++;
 209              		.loc 1 226 0
 210 0016 FB68     		ldr	r3, [r7, #12]
 211 0018 0133     		add	r3, r3, #1
 212 001a FB60     		str	r3, [r7, #12]
 227:../Generated_Code/UTIL1.c ****     dstSize--;
 213              		.loc 1 227 0
 214 001c BB68     		ldr	r3, [r7, #8]
 215 001e 013B     		sub	r3, r3, #1
 216 0020 BB60     		str	r3, [r7, #8]
 217              	.L13:
 225:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 218              		.loc 1 225 0
 219 0022 BB68     		ldr	r3, [r7, #8]
 220 0024 002B     		cmp	r3, #0
 221 0026 03D0     		beq	.L14
 225:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 222              		.loc 1 225 0 is_stmt 0
 223 0028 FB68     		ldr	r3, [r7, #12]
 224 002a 1B78     		ldrb	r3, [r3]
 225 002c 002B     		cmp	r3, #0
 226 002e F2D1     		bne	.L15
 227              	.L14:
 228:../Generated_Code/UTIL1.c ****   }
 229:../Generated_Code/UTIL1.c ****   /* copy the ch in the destination */
 230:../Generated_Code/UTIL1.c ****   if (dstSize > 0) {
 228              		.loc 1 230 0 is_stmt 1
 229 0030 BB68     		ldr	r3, [r7, #8]
 230 0032 002B     		cmp	r3, #0
 231 0034 06D0     		beq	.L16
 231:../Generated_Code/UTIL1.c ****     *dst++ = ch;
 232              		.loc 1 231 0
 233 0036 FB68     		ldr	r3, [r7, #12]
 234 0038 FA1D     		add	r2, r7, #7
 235 003a 1278     		ldrb	r2, [r2]
 236 003c 1A70     		strb	r2, [r3]
 237 003e FB68     		ldr	r3, [r7, #12]
 238 0040 0133     		add	r3, r3, #1
 239 0042 FB60     		str	r3, [r7, #12]
 240              	.L16:
 232:../Generated_Code/UTIL1.c ****   }
 233:../Generated_Code/UTIL1.c ****   /* terminate the string */
 234:../Generated_Code/UTIL1.c ****   *dst = '\0';
 241              		.loc 1 234 0
 242 0044 FB68     		ldr	r3, [r7, #12]
 243 0046 0022     		mov	r2, #0
 244 0048 1A70     		strb	r2, [r3]
 235:../Generated_Code/UTIL1.c **** }
 245              		.loc 1 235 0
 246 004a BD46     		mov	sp, r7
 247 004c 04B0     		add	sp, sp, #16
 248              		@ sp needed for prologue
 249 004e 80BD     		pop	{r7, pc}
 250              		.cfi_endproc
 251              	.LFE2:
 253              		.section	.text.UTIL1_Num8uToStr,"ax",%progbits
 254              		.align	2
 255              		.global	UTIL1_Num8uToStr
 256              		.code	16
 257              		.thumb_func
 259              	UTIL1_Num8uToStr:
 260              	.LFB3:
 236:../Generated_Code/UTIL1.c **** 
 237:../Generated_Code/UTIL1.c **** /*
 238:../Generated_Code/UTIL1.c **** ** ===================================================================
 239:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num8uToStr (component Utility)
 240:../Generated_Code/UTIL1.c **** **     Description :
 241:../Generated_Code/UTIL1.c **** **         Converts an unsigned 8bit value into a string.
 242:../Generated_Code/UTIL1.c **** **     Parameters  :
 243:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 244:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 245:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 246:../Generated_Code/UTIL1.c **** **                           bytes).
 247:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 248:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 249:../Generated_Code/UTIL1.c **** ** ===================================================================
 250:../Generated_Code/UTIL1.c **** */
 251:../Generated_Code/UTIL1.c **** /*!
 252:../Generated_Code/UTIL1.c ****   \brief Converts an 8bit unsigned number into a string.
 253:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 254:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in uint8_ts.
 255:../Generated_Code/UTIL1.c ****   \param[in] val 8bit unsigned number to convert.
 256:../Generated_Code/UTIL1.c ****  */
 257:../Generated_Code/UTIL1.c **** void UTIL1_Num8uToStr(uint8_t *dst, size_t dstSize, uint8_t val)
 258:../Generated_Code/UTIL1.c **** {
 261              		.loc 1 258 0
 262              		.cfi_startproc
 263 0000 80B5     		push	{r7, lr}
 264              	.LCFI9:
 265              		.cfi_def_cfa_offset 8
 266              		.cfi_offset 7, -8
 267              		.cfi_offset 14, -4
 268 0002 84B0     		sub	sp, sp, #16
 269              	.LCFI10:
 270              		.cfi_def_cfa_offset 24
 271 0004 00AF     		add	r7, sp, #0
 272              	.LCFI11:
 273              		.cfi_def_cfa_register 7
 274 0006 F860     		str	r0, [r7, #12]
 275 0008 B960     		str	r1, [r7, #8]
 276 000a FB1D     		add	r3, r7, #7
 277 000c 1A70     		strb	r2, [r3]
 259:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, (uint16_t)val);
 278              		.loc 1 259 0
 279 000e FB1D     		add	r3, r7, #7
 280 0010 1B78     		ldrb	r3, [r3]
 281 0012 9BB2     		uxth	r3, r3
 282 0014 F968     		ldr	r1, [r7, #12]
 283 0016 BA68     		ldr	r2, [r7, #8]
 284 0018 081C     		mov	r0, r1
 285 001a 111C     		mov	r1, r2
 286 001c 1A1C     		mov	r2, r3
 287 001e FFF7FEFF 		bl	UTIL1_Num16uToStr
 260:../Generated_Code/UTIL1.c **** }
 288              		.loc 1 260 0
 289 0022 BD46     		mov	sp, r7
 290 0024 04B0     		add	sp, sp, #16
 291              		@ sp needed for prologue
 292 0026 80BD     		pop	{r7, pc}
 293              		.cfi_endproc
 294              	.LFE3:
 296              		.section	.text.UTIL1_Num8sToStr,"ax",%progbits
 297              		.align	2
 298              		.global	UTIL1_Num8sToStr
 299              		.code	16
 300              		.thumb_func
 302              	UTIL1_Num8sToStr:
 303              	.LFB4:
 261:../Generated_Code/UTIL1.c **** 
 262:../Generated_Code/UTIL1.c **** /*
 263:../Generated_Code/UTIL1.c **** ** ===================================================================
 264:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num8sToStr (component Utility)
 265:../Generated_Code/UTIL1.c **** **     Description :
 266:../Generated_Code/UTIL1.c **** **         Converts a signed 8bit value into a string.
 267:../Generated_Code/UTIL1.c **** **     Parameters  :
 268:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 269:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 270:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 271:../Generated_Code/UTIL1.c **** **                           bytes).
 272:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 273:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 274:../Generated_Code/UTIL1.c **** ** ===================================================================
 275:../Generated_Code/UTIL1.c **** */
 276:../Generated_Code/UTIL1.c **** /*!
 277:../Generated_Code/UTIL1.c ****   \brief Converts an 8bit signed number into a string.
 278:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 279:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in uint8_ts.
 280:../Generated_Code/UTIL1.c ****   \param[in] val 8bit signed number to convert.
 281:../Generated_Code/UTIL1.c ****  */
 282:../Generated_Code/UTIL1.c **** void UTIL1_Num8sToStr(uint8_t *dst, size_t dstSize, signed char val)
 283:../Generated_Code/UTIL1.c **** {
 304              		.loc 1 283 0
 305              		.cfi_startproc
 306 0000 80B5     		push	{r7, lr}
 307              	.LCFI12:
 308              		.cfi_def_cfa_offset 8
 309              		.cfi_offset 7, -8
 310              		.cfi_offset 14, -4
 311 0002 84B0     		sub	sp, sp, #16
 312              	.LCFI13:
 313              		.cfi_def_cfa_offset 24
 314 0004 00AF     		add	r7, sp, #0
 315              	.LCFI14:
 316              		.cfi_def_cfa_register 7
 317 0006 F860     		str	r0, [r7, #12]
 318 0008 B960     		str	r1, [r7, #8]
 319 000a FB1D     		add	r3, r7, #7
 320 000c 1A70     		strb	r2, [r3]
 284:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, (int16_t)val);
 321              		.loc 1 284 0
 322 000e FB1D     		add	r3, r7, #7
 323 0010 1B78     		ldrb	r3, [r3]
 324 0012 5BB2     		sxtb	r3, r3
 325 0014 9BB2     		uxth	r3, r3
 326 0016 F968     		ldr	r1, [r7, #12]
 327 0018 BA68     		ldr	r2, [r7, #8]
 328 001a 1BB2     		sxth	r3, r3
 329 001c 081C     		mov	r0, r1
 330 001e 111C     		mov	r1, r2
 331 0020 1A1C     		mov	r2, r3
 332 0022 FFF7FEFF 		bl	UTIL1_Num16sToStr
 285:../Generated_Code/UTIL1.c **** }
 333              		.loc 1 285 0
 334 0026 BD46     		mov	sp, r7
 335 0028 04B0     		add	sp, sp, #16
 336              		@ sp needed for prologue
 337 002a 80BD     		pop	{r7, pc}
 338              		.cfi_endproc
 339              	.LFE4:
 341              		.global	__aeabi_uidivmod
 342              		.global	__aeabi_uidiv
 343              		.section	.text.UTIL1_Num16uToStr,"ax",%progbits
 344              		.align	2
 345              		.global	UTIL1_Num16uToStr
 346              		.code	16
 347              		.thumb_func
 349              	UTIL1_Num16uToStr:
 350              	.LFB5:
 286:../Generated_Code/UTIL1.c **** 
 287:../Generated_Code/UTIL1.c **** /*
 288:../Generated_Code/UTIL1.c **** ** ===================================================================
 289:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16uToStr (component Utility)
 290:../Generated_Code/UTIL1.c **** **     Description :
 291:../Generated_Code/UTIL1.c **** **         Converts a signed 16bit value into a string.
 292:../Generated_Code/UTIL1.c **** **     Parameters  :
 293:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 294:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 295:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 296:../Generated_Code/UTIL1.c **** **                           bytes).
 297:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 298:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 299:../Generated_Code/UTIL1.c **** ** ===================================================================
 300:../Generated_Code/UTIL1.c **** */
 301:../Generated_Code/UTIL1.c **** /*!
 302:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit unsigned number into a string.
 303:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 304:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in uint8_ts.
 305:../Generated_Code/UTIL1.c ****   \param[in] val 16bit unsigned number to convert.
 306:../Generated_Code/UTIL1.c ****  */
 307:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStr(uint8_t *dst, size_t dstSize, uint16_t val)
 308:../Generated_Code/UTIL1.c **** {
 351              		.loc 1 308 0
 352              		.cfi_startproc
 353 0000 90B5     		push	{r4, r7, lr}
 354              	.LCFI15:
 355              		.cfi_def_cfa_offset 12
 356              		.cfi_offset 4, -12
 357              		.cfi_offset 7, -8
 358              		.cfi_offset 14, -4
 359 0002 89B0     		sub	sp, sp, #36
 360              	.LCFI16:
 361              		.cfi_def_cfa_offset 48
 362 0004 00AF     		add	r7, sp, #0
 363              	.LCFI17:
 364              		.cfi_def_cfa_register 7
 365 0006 F860     		str	r0, [r7, #12]
 366 0008 B960     		str	r1, [r7, #8]
 367 000a BB1D     		add	r3, r7, #6
 368 000c 1A80     		strh	r2, [r3]
 309:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
 369              		.loc 1 309 0
 370 000e FB68     		ldr	r3, [r7, #12]
 371 0010 BB61     		str	r3, [r7, #24]
 310:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 372              		.loc 1 310 0
 373 0012 3B1C     		mov	r3, r7
 374 0014 1F33     		add	r3, r3, #31
 375 0016 0022     		mov	r2, #0
 376 0018 1A70     		strb	r2, [r3]
 311:../Generated_Code/UTIL1.c ****   unsigned char tmp;
 312:../Generated_Code/UTIL1.c **** 
 313:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 377              		.loc 1 313 0
 378 001a BB68     		ldr	r3, [r7, #8]
 379 001c 013B     		sub	r3, r3, #1
 380 001e BB60     		str	r3, [r7, #8]
 314:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 381              		.loc 1 314 0
 382 0020 BB1D     		add	r3, r7, #6
 383 0022 1B88     		ldrh	r3, [r3]
 384 0024 002B     		cmp	r3, #0
 385 0026 38D1     		bne	.L21
 386              		.loc 1 314 0 is_stmt 0
 387 0028 BB68     		ldr	r3, [r7, #8]
 388 002a 002B     		cmp	r3, #0
 389 002c 35D0     		beq	.L21
 315:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 390              		.loc 1 315 0 is_stmt 1
 391 002e 3B1C     		mov	r3, r7
 392 0030 1F33     		add	r3, r3, #31
 393 0032 1B78     		ldrb	r3, [r3]
 394 0034 BA69     		ldr	r2, [r7, #24]
 395 0036 D318     		add	r3, r2, r3
 396 0038 3022     		mov	r2, #48
 397 003a 1A70     		strb	r2, [r3]
 398 003c 3B1C     		mov	r3, r7
 399 003e 1F33     		add	r3, r3, #31
 400 0040 3A1C     		mov	r2, r7
 401 0042 1F32     		add	r2, r2, #31
 402 0044 1278     		ldrb	r2, [r2]
 403 0046 0132     		add	r2, r2, #1
 404 0048 1A70     		strb	r2, [r3]
 316:../Generated_Code/UTIL1.c ****     dstSize--;
 405              		.loc 1 316 0
 406 004a BB68     		ldr	r3, [r7, #8]
 407 004c 013B     		sub	r3, r3, #1
 408 004e BB60     		str	r3, [r7, #8]
 317:../Generated_Code/UTIL1.c ****   }
 318:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 409              		.loc 1 318 0
 410 0050 23E0     		b	.L21
 411              	.L23:
 319:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 412              		.loc 1 319 0
 413 0052 3B1C     		mov	r3, r7
 414 0054 1F33     		add	r3, r3, #31
 415 0056 1B78     		ldrb	r3, [r3]
 416 0058 BA69     		ldr	r2, [r7, #24]
 417 005a D418     		add	r4, r2, r3
 418 005c BB1D     		add	r3, r7, #6
 419 005e 1B88     		ldrh	r3, [r3]
 420 0060 181C     		mov	r0, r3
 421 0062 0A21     		mov	r1, #10
 422 0064 FFF7FEFF 		bl	__aeabi_uidivmod
 423 0068 0B1C     		mov	r3, r1
 424 006a 9BB2     		uxth	r3, r3
 425 006c DBB2     		uxtb	r3, r3
 426 006e 3033     		add	r3, r3, #48
 427 0070 DBB2     		uxtb	r3, r3
 428 0072 2370     		strb	r3, [r4]
 429 0074 3B1C     		mov	r3, r7
 430 0076 1F33     		add	r3, r3, #31
 431 0078 3A1C     		mov	r2, r7
 432 007a 1F32     		add	r2, r2, #31
 433 007c 1278     		ldrb	r2, [r2]
 434 007e 0132     		add	r2, r2, #1
 435 0080 1A70     		strb	r2, [r3]
 320:../Generated_Code/UTIL1.c ****     dstSize--;
 436              		.loc 1 320 0
 437 0082 BB68     		ldr	r3, [r7, #8]
 438 0084 013B     		sub	r3, r3, #1
 439 0086 BB60     		str	r3, [r7, #8]
 321:../Generated_Code/UTIL1.c ****     val /= 10;
 440              		.loc 1 321 0
 441 0088 BC1D     		add	r4, r7, #6
 442 008a BB1D     		add	r3, r7, #6
 443 008c 1B88     		ldrh	r3, [r3]
 444 008e 181C     		mov	r0, r3
 445 0090 0A21     		mov	r1, #10
 446 0092 FFF7FEFF 		bl	__aeabi_uidiv
 447 0096 031C     		mov	r3, r0
 448 0098 2380     		strh	r3, [r4]
 449              	.L21:
 318:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 450              		.loc 1 318 0
 451 009a BB1D     		add	r3, r7, #6
 452 009c 1B88     		ldrh	r3, [r3]
 453 009e 002B     		cmp	r3, #0
 454 00a0 02D0     		beq	.L22
 318:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 455              		.loc 1 318 0 is_stmt 0
 456 00a2 BB68     		ldr	r3, [r7, #8]
 457 00a4 002B     		cmp	r3, #0
 458 00a6 D4D1     		bne	.L23
 459              	.L22:
 322:../Generated_Code/UTIL1.c ****   }
 323:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 460              		.loc 1 323 0 is_stmt 1
 461 00a8 3B1C     		mov	r3, r7
 462 00aa 1E33     		add	r3, r3, #30
 463 00ac 0022     		mov	r2, #0
 464 00ae 1A70     		strb	r2, [r3]
 465 00b0 2EE0     		b	.L24
 466              	.L25:
 324:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 467              		.loc 1 324 0
 468 00b2 3B1C     		mov	r3, r7
 469 00b4 1E33     		add	r3, r3, #30
 470 00b6 1B78     		ldrb	r3, [r3]
 471 00b8 BA69     		ldr	r2, [r7, #24]
 472 00ba D218     		add	r2, r2, r3
 473 00bc 3B1C     		mov	r3, r7
 474 00be 1733     		add	r3, r3, #23
 475 00c0 1278     		ldrb	r2, [r2]
 476 00c2 1A70     		strb	r2, [r3]
 325:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 477              		.loc 1 325 0
 478 00c4 3B1C     		mov	r3, r7
 479 00c6 1E33     		add	r3, r3, #30
 480 00c8 1B78     		ldrb	r3, [r3]
 481 00ca BA69     		ldr	r2, [r7, #24]
 482 00cc D318     		add	r3, r2, r3
 483 00ce 3A1C     		mov	r2, r7
 484 00d0 1F32     		add	r2, r2, #31
 485 00d2 1178     		ldrb	r1, [r2]
 486 00d4 3A1C     		mov	r2, r7
 487 00d6 1E32     		add	r2, r2, #30
 488 00d8 1278     		ldrb	r2, [r2]
 489 00da 8A1A     		sub	r2, r1, r2
 490 00dc 013A     		sub	r2, r2, #1
 491 00de B969     		ldr	r1, [r7, #24]
 492 00e0 8A18     		add	r2, r1, r2
 493 00e2 1278     		ldrb	r2, [r2]
 494 00e4 1A70     		strb	r2, [r3]
 326:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 495              		.loc 1 326 0
 496 00e6 3B1C     		mov	r3, r7
 497 00e8 1F33     		add	r3, r3, #31
 498 00ea 1A78     		ldrb	r2, [r3]
 499 00ec 3B1C     		mov	r3, r7
 500 00ee 1E33     		add	r3, r3, #30
 501 00f0 1B78     		ldrb	r3, [r3]
 502 00f2 D31A     		sub	r3, r2, r3
 503 00f4 013B     		sub	r3, r3, #1
 504 00f6 BA69     		ldr	r2, [r7, #24]
 505 00f8 D318     		add	r3, r2, r3
 506 00fa 3A1C     		mov	r2, r7
 507 00fc 1732     		add	r2, r2, #23
 508 00fe 1278     		ldrb	r2, [r2]
 509 0100 1A70     		strb	r2, [r3]
 323:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 510              		.loc 1 323 0
 511 0102 3B1C     		mov	r3, r7
 512 0104 1E33     		add	r3, r3, #30
 513 0106 3A1C     		mov	r2, r7
 514 0108 1E32     		add	r2, r2, #30
 515 010a 1278     		ldrb	r2, [r2]
 516 010c 0132     		add	r2, r2, #1
 517 010e 1A70     		strb	r2, [r3]
 518              	.L24:
 323:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 519              		.loc 1 323 0 is_stmt 0
 520 0110 3B1C     		mov	r3, r7
 521 0112 1F33     		add	r3, r3, #31
 522 0114 1B78     		ldrb	r3, [r3]
 523 0116 5B08     		lsr	r3, r3, #1
 524 0118 DBB2     		uxtb	r3, r3
 525 011a 3A1C     		mov	r2, r7
 526 011c 1E32     		add	r2, r2, #30
 527 011e 1278     		ldrb	r2, [r2]
 528 0120 9A42     		cmp	r2, r3
 529 0122 C6D3     		bcc	.L25
 327:../Generated_Code/UTIL1.c ****   }
 328:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 530              		.loc 1 328 0 is_stmt 1
 531 0124 3B1C     		mov	r3, r7
 532 0126 1F33     		add	r3, r3, #31
 533 0128 1B78     		ldrb	r3, [r3]
 534 012a BA69     		ldr	r2, [r7, #24]
 535 012c D318     		add	r3, r2, r3
 536 012e 0022     		mov	r2, #0
 537 0130 1A70     		strb	r2, [r3]
 329:../Generated_Code/UTIL1.c **** }
 538              		.loc 1 329 0
 539 0132 BD46     		mov	sp, r7
 540 0134 09B0     		add	sp, sp, #36
 541              		@ sp needed for prologue
 542 0136 90BD     		pop	{r4, r7, pc}
 543              		.cfi_endproc
 544              	.LFE5:
 546              		.section	.rodata
 547              		.align	2
 548              	.LC0:
 549 0000 2D333237 		.ascii	"-32768\000"
 549      363800
 550              		.global	__aeabi_idivmod
 551              		.global	__aeabi_idiv
 552              		.section	.text.UTIL1_Num16sToStr,"ax",%progbits
 553              		.align	2
 554              		.global	UTIL1_Num16sToStr
 555              		.code	16
 556              		.thumb_func
 558              	UTIL1_Num16sToStr:
 559              	.LFB6:
 330:../Generated_Code/UTIL1.c **** 
 331:../Generated_Code/UTIL1.c **** /*
 332:../Generated_Code/UTIL1.c **** ** ===================================================================
 333:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16sToStr (component Utility)
 334:../Generated_Code/UTIL1.c **** **     Description :
 335:../Generated_Code/UTIL1.c **** **         Converts a signed 16bit value into a string.
 336:../Generated_Code/UTIL1.c **** **     Parameters  :
 337:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 338:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 339:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 340:../Generated_Code/UTIL1.c **** **                           bytes).
 341:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 342:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 343:../Generated_Code/UTIL1.c **** ** ===================================================================
 344:../Generated_Code/UTIL1.c **** */
 345:../Generated_Code/UTIL1.c **** /*!
 346:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit signed number into a string.
 347:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 348:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in uint8_ts.
 349:../Generated_Code/UTIL1.c ****   \param[in] val 16bit signed number to convert.
 350:../Generated_Code/UTIL1.c ****  */
 351:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStr(uint8_t *dst, size_t dstSize, int16_t val)
 352:../Generated_Code/UTIL1.c **** {
 560              		.loc 1 352 0
 561              		.cfi_startproc
 562 0000 90B5     		push	{r4, r7, lr}
 563              	.LCFI18:
 564              		.cfi_def_cfa_offset 12
 565              		.cfi_offset 4, -12
 566              		.cfi_offset 7, -8
 567              		.cfi_offset 14, -4
 568 0002 89B0     		sub	sp, sp, #36
 569              	.LCFI19:
 570              		.cfi_def_cfa_offset 48
 571 0004 00AF     		add	r7, sp, #0
 572              	.LCFI20:
 573              		.cfi_def_cfa_register 7
 574 0006 F860     		str	r0, [r7, #12]
 575 0008 B960     		str	r1, [r7, #8]
 576 000a BB1D     		add	r3, r7, #6
 577 000c 1A80     		strh	r2, [r3]
 353:../Generated_Code/UTIL1.c ****   unsigned char *ptr =  ((unsigned char *)dst);
 578              		.loc 1 353 0
 579 000e FB68     		ldr	r3, [r7, #12]
 580 0010 BB61     		str	r3, [r7, #24]
 354:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 581              		.loc 1 354 0
 582 0012 3B1C     		mov	r3, r7
 583 0014 1F33     		add	r3, r3, #31
 584 0016 0022     		mov	r2, #0
 585 0018 1A70     		strb	r2, [r3]
 355:../Generated_Code/UTIL1.c ****   unsigned char tmp;
 356:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 586              		.loc 1 356 0
 587 001a BB1D     		add	r3, r7, #6
 588 001c 1B88     		ldrh	r3, [r3]
 589 001e DB0B     		lsr	r3, r3, #15
 590 0020 DAB2     		uxtb	r2, r3
 591 0022 3B1C     		mov	r3, r7
 592 0024 1733     		add	r3, r3, #23
 593 0026 1A70     		strb	r2, [r3]
 357:../Generated_Code/UTIL1.c **** 
 358:../Generated_Code/UTIL1.c ****   if (val==(int16_t)(0x8000)) { /* special case 0x8000/-32768: prevent overflow below. */
 594              		.loc 1 358 0
 595 0028 BB1D     		add	r3, r7, #6
 596 002a 0021     		mov	r1, #0
 597 002c 5A5E     		ldrsh	r2, [r3, r1]
 598 002e 604B     		ldr	r3, .L37
 599 0030 9A42     		cmp	r2, r3
 600 0032 08D1     		bne	.L27
 359:../Generated_Code/UTIL1.c ****     UTIL1_strcpy(dst, dstSize, (unsigned char*)"-32768");
 601              		.loc 1 359 0
 602 0034 F968     		ldr	r1, [r7, #12]
 603 0036 BA68     		ldr	r2, [r7, #8]
 604 0038 5E4B     		ldr	r3, .L37+4
 605 003a 081C     		mov	r0, r1
 606 003c 111C     		mov	r1, r2
 607 003e 1A1C     		mov	r2, r3
 608 0040 FFF7FEFF 		bl	UTIL1_strcpy
 360:../Generated_Code/UTIL1.c ****     return;
 609              		.loc 1 360 0
 610 0044 B0E0     		b	.L26
 611              	.L27:
 361:../Generated_Code/UTIL1.c ****   }
 362:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 612              		.loc 1 362 0
 613 0046 BB68     		ldr	r3, [r7, #8]
 614 0048 013B     		sub	r3, r3, #1
 615 004a BB60     		str	r3, [r7, #8]
 363:../Generated_Code/UTIL1.c ****   if (sign) {
 616              		.loc 1 363 0
 617 004c 3B1C     		mov	r3, r7
 618 004e 1733     		add	r3, r3, #23
 619 0050 1B78     		ldrb	r3, [r3]
 620 0052 002B     		cmp	r3, #0
 621 0054 05D0     		beq	.L29
 364:../Generated_Code/UTIL1.c ****     val = (int16_t)(-val);
 622              		.loc 1 364 0
 623 0056 BB1D     		add	r3, r7, #6
 624 0058 1B88     		ldrh	r3, [r3]
 625 005a 5B42     		neg	r3, r3
 626 005c 9AB2     		uxth	r2, r3
 627 005e BB1D     		add	r3, r7, #6
 628 0060 1A80     		strh	r2, [r3]
 629              	.L29:
 365:../Generated_Code/UTIL1.c ****   }
 366:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 630              		.loc 1 366 0
 631 0062 BB1D     		add	r3, r7, #6
 632 0064 0022     		mov	r2, #0
 633 0066 9B5E     		ldrsh	r3, [r3, r2]
 634 0068 002B     		cmp	r3, #0
 635 006a 3AD1     		bne	.L31
 636              		.loc 1 366 0 is_stmt 0
 637 006c BB68     		ldr	r3, [r7, #8]
 638 006e 002B     		cmp	r3, #0
 639 0070 37D0     		beq	.L31
 367:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 640              		.loc 1 367 0 is_stmt 1
 641 0072 3B1C     		mov	r3, r7
 642 0074 1F33     		add	r3, r3, #31
 643 0076 1B78     		ldrb	r3, [r3]
 644 0078 BA69     		ldr	r2, [r7, #24]
 645 007a D318     		add	r3, r2, r3
 646 007c 3022     		mov	r2, #48
 647 007e 1A70     		strb	r2, [r3]
 648 0080 3B1C     		mov	r3, r7
 649 0082 1F33     		add	r3, r3, #31
 650 0084 3A1C     		mov	r2, r7
 651 0086 1F32     		add	r2, r2, #31
 652 0088 1278     		ldrb	r2, [r2]
 653 008a 0132     		add	r2, r2, #1
 654 008c 1A70     		strb	r2, [r3]
 368:../Generated_Code/UTIL1.c ****     dstSize--;
 655              		.loc 1 368 0
 656 008e BB68     		ldr	r3, [r7, #8]
 657 0090 013B     		sub	r3, r3, #1
 658 0092 BB60     		str	r3, [r7, #8]
 369:../Generated_Code/UTIL1.c ****   }
 370:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 659              		.loc 1 370 0
 660 0094 25E0     		b	.L31
 661              	.L33:
 371:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 662              		.loc 1 371 0
 663 0096 3B1C     		mov	r3, r7
 664 0098 1F33     		add	r3, r3, #31
 665 009a 1B78     		ldrb	r3, [r3]
 666 009c BA69     		ldr	r2, [r7, #24]
 667 009e D418     		add	r4, r2, r3
 668 00a0 BB1D     		add	r3, r7, #6
 669 00a2 0021     		mov	r1, #0
 670 00a4 5B5E     		ldrsh	r3, [r3, r1]
 671 00a6 181C     		mov	r0, r3
 672 00a8 0A21     		mov	r1, #10
 673 00aa FFF7FEFF 		bl	__aeabi_idivmod
 674 00ae 0B1C     		mov	r3, r1
 675 00b0 9BB2     		uxth	r3, r3
 676 00b2 DBB2     		uxtb	r3, r3
 677 00b4 3033     		add	r3, r3, #48
 678 00b6 DBB2     		uxtb	r3, r3
 679 00b8 2370     		strb	r3, [r4]
 680 00ba 3B1C     		mov	r3, r7
 681 00bc 1F33     		add	r3, r3, #31
 682 00be 3A1C     		mov	r2, r7
 683 00c0 1F32     		add	r2, r2, #31
 684 00c2 1278     		ldrb	r2, [r2]
 685 00c4 0132     		add	r2, r2, #1
 686 00c6 1A70     		strb	r2, [r3]
 372:../Generated_Code/UTIL1.c ****     dstSize--;
 687              		.loc 1 372 0
 688 00c8 BB68     		ldr	r3, [r7, #8]
 689 00ca 013B     		sub	r3, r3, #1
 690 00cc BB60     		str	r3, [r7, #8]
 373:../Generated_Code/UTIL1.c ****     val /= 10;
 691              		.loc 1 373 0
 692 00ce BC1D     		add	r4, r7, #6
 693 00d0 BB1D     		add	r3, r7, #6
 694 00d2 0022     		mov	r2, #0
 695 00d4 9B5E     		ldrsh	r3, [r3, r2]
 696 00d6 181C     		mov	r0, r3
 697 00d8 0A21     		mov	r1, #10
 698 00da FFF7FEFF 		bl	__aeabi_idiv
 699 00de 031C     		mov	r3, r0
 700 00e0 2380     		strh	r3, [r4]
 701              	.L31:
 370:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 702              		.loc 1 370 0
 703 00e2 BB1D     		add	r3, r7, #6
 704 00e4 0021     		mov	r1, #0
 705 00e6 5B5E     		ldrsh	r3, [r3, r1]
 706 00e8 002B     		cmp	r3, #0
 707 00ea 02DD     		ble	.L32
 370:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 708              		.loc 1 370 0 is_stmt 0
 709 00ec BB68     		ldr	r3, [r7, #8]
 710 00ee 002B     		cmp	r3, #0
 711 00f0 D1D1     		bne	.L33
 712              	.L32:
 374:../Generated_Code/UTIL1.c ****   }
 375:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 713              		.loc 1 375 0 is_stmt 1
 714 00f2 3B1C     		mov	r3, r7
 715 00f4 1733     		add	r3, r3, #23
 716 00f6 1B78     		ldrb	r3, [r3]
 717 00f8 002B     		cmp	r3, #0
 718 00fa 10D0     		beq	.L34
 719              		.loc 1 375 0 is_stmt 0
 720 00fc BB68     		ldr	r3, [r7, #8]
 721 00fe 002B     		cmp	r3, #0
 722 0100 0DD0     		beq	.L34
 376:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 723              		.loc 1 376 0 is_stmt 1
 724 0102 3B1C     		mov	r3, r7
 725 0104 1F33     		add	r3, r3, #31
 726 0106 1B78     		ldrb	r3, [r3]
 727 0108 BA69     		ldr	r2, [r7, #24]
 728 010a D318     		add	r3, r2, r3
 729 010c 2D22     		mov	r2, #45
 730 010e 1A70     		strb	r2, [r3]
 731 0110 3B1C     		mov	r3, r7
 732 0112 1F33     		add	r3, r3, #31
 733 0114 3A1C     		mov	r2, r7
 734 0116 1F32     		add	r2, r2, #31
 735 0118 1278     		ldrb	r2, [r2]
 736 011a 0132     		add	r2, r2, #1
 737 011c 1A70     		strb	r2, [r3]
 738              	.L34:
 377:../Generated_Code/UTIL1.c ****   }
 378:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 739              		.loc 1 378 0
 740 011e 3B1C     		mov	r3, r7
 741 0120 1E33     		add	r3, r3, #30
 742 0122 0022     		mov	r2, #0
 743 0124 1A70     		strb	r2, [r3]
 744 0126 2EE0     		b	.L35
 745              	.L36:
 379:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 746              		.loc 1 379 0
 747 0128 3B1C     		mov	r3, r7
 748 012a 1E33     		add	r3, r3, #30
 749 012c 1B78     		ldrb	r3, [r3]
 750 012e BA69     		ldr	r2, [r7, #24]
 751 0130 D218     		add	r2, r2, r3
 752 0132 3B1C     		mov	r3, r7
 753 0134 1633     		add	r3, r3, #22
 754 0136 1278     		ldrb	r2, [r2]
 755 0138 1A70     		strb	r2, [r3]
 380:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 756              		.loc 1 380 0
 757 013a 3B1C     		mov	r3, r7
 758 013c 1E33     		add	r3, r3, #30
 759 013e 1B78     		ldrb	r3, [r3]
 760 0140 BA69     		ldr	r2, [r7, #24]
 761 0142 D318     		add	r3, r2, r3
 762 0144 3A1C     		mov	r2, r7
 763 0146 1F32     		add	r2, r2, #31
 764 0148 1178     		ldrb	r1, [r2]
 765 014a 3A1C     		mov	r2, r7
 766 014c 1E32     		add	r2, r2, #30
 767 014e 1278     		ldrb	r2, [r2]
 768 0150 8A1A     		sub	r2, r1, r2
 769 0152 013A     		sub	r2, r2, #1
 770 0154 B969     		ldr	r1, [r7, #24]
 771 0156 8A18     		add	r2, r1, r2
 772 0158 1278     		ldrb	r2, [r2]
 773 015a 1A70     		strb	r2, [r3]
 381:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 774              		.loc 1 381 0
 775 015c 3B1C     		mov	r3, r7
 776 015e 1F33     		add	r3, r3, #31
 777 0160 1A78     		ldrb	r2, [r3]
 778 0162 3B1C     		mov	r3, r7
 779 0164 1E33     		add	r3, r3, #30
 780 0166 1B78     		ldrb	r3, [r3]
 781 0168 D31A     		sub	r3, r2, r3
 782 016a 013B     		sub	r3, r3, #1
 783 016c BA69     		ldr	r2, [r7, #24]
 784 016e D318     		add	r3, r2, r3
 785 0170 3A1C     		mov	r2, r7
 786 0172 1632     		add	r2, r2, #22
 787 0174 1278     		ldrb	r2, [r2]
 788 0176 1A70     		strb	r2, [r3]
 378:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 789              		.loc 1 378 0
 790 0178 3B1C     		mov	r3, r7
 791 017a 1E33     		add	r3, r3, #30
 792 017c 3A1C     		mov	r2, r7
 793 017e 1E32     		add	r2, r2, #30
 794 0180 1278     		ldrb	r2, [r2]
 795 0182 0132     		add	r2, r2, #1
 796 0184 1A70     		strb	r2, [r3]
 797              	.L35:
 378:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 798              		.loc 1 378 0 is_stmt 0
 799 0186 3B1C     		mov	r3, r7
 800 0188 1F33     		add	r3, r3, #31
 801 018a 1B78     		ldrb	r3, [r3]
 802 018c 5B08     		lsr	r3, r3, #1
 803 018e DBB2     		uxtb	r3, r3
 804 0190 3A1C     		mov	r2, r7
 805 0192 1E32     		add	r2, r2, #30
 806 0194 1278     		ldrb	r2, [r2]
 807 0196 9A42     		cmp	r2, r3
 808 0198 C6D3     		bcc	.L36
 382:../Generated_Code/UTIL1.c ****   }
 383:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 809              		.loc 1 383 0 is_stmt 1
 810 019a 3B1C     		mov	r3, r7
 811 019c 1F33     		add	r3, r3, #31
 812 019e 1B78     		ldrb	r3, [r3]
 813 01a0 BA69     		ldr	r2, [r7, #24]
 814 01a2 D318     		add	r3, r2, r3
 815 01a4 0022     		mov	r2, #0
 816 01a6 1A70     		strb	r2, [r3]
 817              	.L26:
 384:../Generated_Code/UTIL1.c **** }
 818              		.loc 1 384 0
 819 01a8 BD46     		mov	sp, r7
 820 01aa 09B0     		add	sp, sp, #36
 821              		@ sp needed for prologue
 822 01ac 90BD     		pop	{r4, r7, pc}
 823              	.L38:
 824 01ae C046     		.align	2
 825              	.L37:
 826 01b0 0080FFFF 		.word	-32768
 827 01b4 00000000 		.word	.LC0
 828              		.cfi_endproc
 829              	.LFE6:
 831              		.section	.text.ShiftRightAndFill,"ax",%progbits
 832              		.align	2
 833              		.code	16
 834              		.thumb_func
 836              	ShiftRightAndFill:
 837              	.LFB7:
 385:../Generated_Code/UTIL1.c **** 
 386:../Generated_Code/UTIL1.c **** /*
 387:../Generated_Code/UTIL1.c **** ** ===================================================================
 388:../Generated_Code/UTIL1.c **** **     Method      :  ShiftRightAndFill (component Utility)
 389:../Generated_Code/UTIL1.c **** **
 390:../Generated_Code/UTIL1.c **** **     Description :
 391:../Generated_Code/UTIL1.c **** **         Moves the content of a string to the right and fills the space 
 392:../Generated_Code/UTIL1.c **** **         on the left side with a pattern
 393:../Generated_Code/UTIL1.c **** **         This method is internal. It is used by Processor Expert only.
 394:../Generated_Code/UTIL1.c **** ** ===================================================================
 395:../Generated_Code/UTIL1.c **** */
 396:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(uint8_t *dst, uint8_t fill, uint8_t nofFill)
 397:../Generated_Code/UTIL1.c **** {
 838              		.loc 1 397 0
 839              		.cfi_startproc
 840 0000 80B5     		push	{r7, lr}
 841              	.LCFI21:
 842              		.cfi_def_cfa_offset 8
 843              		.cfi_offset 7, -8
 844              		.cfi_offset 14, -4
 845 0002 84B0     		sub	sp, sp, #16
 846              	.LCFI22:
 847              		.cfi_def_cfa_offset 24
 848 0004 00AF     		add	r7, sp, #0
 849              	.LCFI23:
 850              		.cfi_def_cfa_register 7
 851 0006 7860     		str	r0, [r7, #4]
 852 0008 FB1C     		add	r3, r7, #3
 853 000a 1970     		strb	r1, [r3]
 854 000c BB1C     		add	r3, r7, #2
 855 000e 1A70     		strb	r2, [r3]
 398:../Generated_Code/UTIL1.c ****   signed char i, j;
 399:../Generated_Code/UTIL1.c **** 
 400:../Generated_Code/UTIL1.c ****   j = 0;
 856              		.loc 1 400 0
 857 0010 3B1C     		mov	r3, r7
 858 0012 0E33     		add	r3, r3, #14
 859 0014 0022     		mov	r2, #0
 860 0016 1A70     		strb	r2, [r3]
 401:../Generated_Code/UTIL1.c ****   while(dst[j] != '\0') {
 861              		.loc 1 401 0
 862 0018 06E0     		b	.L40
 863              	.L41:
 402:../Generated_Code/UTIL1.c ****     j++;
 864              		.loc 1 402 0
 865 001a 3B1C     		mov	r3, r7
 866 001c 0E33     		add	r3, r3, #14
 867 001e 3A1C     		mov	r2, r7
 868 0020 0E32     		add	r2, r2, #14
 869 0022 1278     		ldrb	r2, [r2]
 870 0024 0132     		add	r2, r2, #1
 871 0026 1A70     		strb	r2, [r3]
 872              	.L40:
 401:../Generated_Code/UTIL1.c ****   while(dst[j] != '\0') {
 873              		.loc 1 401 0
 874 0028 3B1C     		mov	r3, r7
 875 002a 0E33     		add	r3, r3, #14
 876 002c 1B78     		ldrb	r3, [r3]
 877 002e 5BB2     		sxtb	r3, r3
 878 0030 7A68     		ldr	r2, [r7, #4]
 879 0032 D318     		add	r3, r2, r3
 880 0034 1B78     		ldrb	r3, [r3]
 881 0036 002B     		cmp	r3, #0
 882 0038 EFD1     		bne	.L41
 403:../Generated_Code/UTIL1.c ****   }
 404:../Generated_Code/UTIL1.c ****   i = (signed char)nofFill;
 883              		.loc 1 404 0
 884 003a 3B1C     		mov	r3, r7
 885 003c 0F33     		add	r3, r3, #15
 886 003e BA1C     		add	r2, r7, #2
 887 0040 1278     		ldrb	r2, [r2]
 888 0042 1A70     		strb	r2, [r3]
 405:../Generated_Code/UTIL1.c ****   if (i==j) {
 889              		.loc 1 405 0
 890 0044 3A1C     		mov	r2, r7
 891 0046 0F32     		add	r2, r2, #15
 892 0048 3B1C     		mov	r3, r7
 893 004a 0E33     		add	r3, r3, #14
 894 004c 1278     		ldrb	r2, [r2]
 895 004e 52B2     		sxtb	r2, r2
 896 0050 1B78     		ldrb	r3, [r3]
 897 0052 5BB2     		sxtb	r3, r3
 898 0054 9A42     		cmp	r2, r3
 899 0056 41D0     		beq	.L39
 406:../Generated_Code/UTIL1.c ****     /* nothing to do, we are done */
 407:../Generated_Code/UTIL1.c ****   } else if (i>j) {
 900              		.loc 1 407 0
 901 0058 3A1C     		mov	r2, r7
 902 005a 0F32     		add	r2, r2, #15
 903 005c 3B1C     		mov	r3, r7
 904 005e 0E33     		add	r3, r3, #14
 905 0060 1278     		ldrb	r2, [r2]
 906 0062 52B2     		sxtb	r2, r2
 907 0064 1B78     		ldrb	r3, [r3]
 908 0066 5BB2     		sxtb	r3, r3
 909 0068 9A42     		cmp	r2, r3
 910 006a 37DD     		ble	.L39
 408:../Generated_Code/UTIL1.c ****     while (j>=0) {
 911              		.loc 1 408 0
 912 006c 1BE0     		b	.L43
 913              	.L44:
 409:../Generated_Code/UTIL1.c ****       dst[i] = dst[j];
 914              		.loc 1 409 0
 915 006e 3B1C     		mov	r3, r7
 916 0070 0F33     		add	r3, r3, #15
 917 0072 1B78     		ldrb	r3, [r3]
 918 0074 5BB2     		sxtb	r3, r3
 919 0076 7A68     		ldr	r2, [r7, #4]
 920 0078 D318     		add	r3, r2, r3
 921 007a 3A1C     		mov	r2, r7
 922 007c 0E32     		add	r2, r2, #14
 923 007e 1278     		ldrb	r2, [r2]
 924 0080 52B2     		sxtb	r2, r2
 925 0082 7968     		ldr	r1, [r7, #4]
 926 0084 8A18     		add	r2, r1, r2
 927 0086 1278     		ldrb	r2, [r2]
 928 0088 1A70     		strb	r2, [r3]
 410:../Generated_Code/UTIL1.c ****       i--; j--;
 929              		.loc 1 410 0
 930 008a 3B1C     		mov	r3, r7
 931 008c 0F33     		add	r3, r3, #15
 932 008e 3A1C     		mov	r2, r7
 933 0090 0F32     		add	r2, r2, #15
 934 0092 1278     		ldrb	r2, [r2]
 935 0094 013A     		sub	r2, r2, #1
 936 0096 1A70     		strb	r2, [r3]
 937 0098 3B1C     		mov	r3, r7
 938 009a 0E33     		add	r3, r3, #14
 939 009c 3A1C     		mov	r2, r7
 940 009e 0E32     		add	r2, r2, #14
 941 00a0 1278     		ldrb	r2, [r2]
 942 00a2 013A     		sub	r2, r2, #1
 943 00a4 1A70     		strb	r2, [r3]
 944              	.L43:
 408:../Generated_Code/UTIL1.c ****     while (j>=0) {
 945              		.loc 1 408 0
 946 00a6 3B1C     		mov	r3, r7
 947 00a8 0E33     		add	r3, r3, #14
 948 00aa 1B78     		ldrb	r3, [r3]
 949 00ac 7F2B     		cmp	r3, #127
 950 00ae DED9     		bls	.L44
 411:../Generated_Code/UTIL1.c ****     }
 412:../Generated_Code/UTIL1.c ****     while(i>=0) {
 951              		.loc 1 412 0
 952 00b0 0FE0     		b	.L45
 953              	.L46:
 413:../Generated_Code/UTIL1.c ****       dst[i] = fill;
 954              		.loc 1 413 0
 955 00b2 3B1C     		mov	r3, r7
 956 00b4 0F33     		add	r3, r3, #15
 957 00b6 1B78     		ldrb	r3, [r3]
 958 00b8 5BB2     		sxtb	r3, r3
 959 00ba 7A68     		ldr	r2, [r7, #4]
 960 00bc D318     		add	r3, r2, r3
 961 00be FA1C     		add	r2, r7, #3
 962 00c0 1278     		ldrb	r2, [r2]
 963 00c2 1A70     		strb	r2, [r3]
 414:../Generated_Code/UTIL1.c ****       i--;
 964              		.loc 1 414 0
 965 00c4 3B1C     		mov	r3, r7
 966 00c6 0F33     		add	r3, r3, #15
 967 00c8 3A1C     		mov	r2, r7
 968 00ca 0F32     		add	r2, r2, #15
 969 00cc 1278     		ldrb	r2, [r2]
 970 00ce 013A     		sub	r2, r2, #1
 971 00d0 1A70     		strb	r2, [r3]
 972              	.L45:
 412:../Generated_Code/UTIL1.c ****     while(i>=0) {
 973              		.loc 1 412 0
 974 00d2 3B1C     		mov	r3, r7
 975 00d4 0F33     		add	r3, r3, #15
 976 00d6 1B78     		ldrb	r3, [r3]
 977 00d8 7F2B     		cmp	r3, #127
 978 00da EAD9     		bls	.L46
 979              	.L39:
 415:../Generated_Code/UTIL1.c ****     }
 416:../Generated_Code/UTIL1.c ****   } else {
 417:../Generated_Code/UTIL1.c ****     /* hmmm, not enough space, return what we have, do nothing */
 418:../Generated_Code/UTIL1.c ****   }
 419:../Generated_Code/UTIL1.c **** }
 980              		.loc 1 419 0
 981 00dc BD46     		mov	sp, r7
 982 00de 04B0     		add	sp, sp, #16
 983              		@ sp needed for prologue
 984 00e0 80BD     		pop	{r7, pc}
 985              		.cfi_endproc
 986              	.LFE7:
 988 00e2 C046     		.section	.text.UTIL1_Num16sToStrFormatted,"ax",%progbits
 989              		.align	2
 990              		.global	UTIL1_Num16sToStrFormatted
 991              		.code	16
 992              		.thumb_func
 994              	UTIL1_Num16sToStrFormatted:
 995              	.LFB8:
 420:../Generated_Code/UTIL1.c **** 
 421:../Generated_Code/UTIL1.c **** /*
 422:../Generated_Code/UTIL1.c **** ** ===================================================================
 423:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16sToStrFormatted (component Utility)
 424:../Generated_Code/UTIL1.c **** **     Description :
 425:../Generated_Code/UTIL1.c **** **         Converts a 16bit signed value to string.
 426:../Generated_Code/UTIL1.c **** **     Parameters  :
 427:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 428:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 429:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 430:../Generated_Code/UTIL1.c **** **                           bytes).
 431:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 432:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 433:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 434:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 435:../Generated_Code/UTIL1.c **** ** ===================================================================
 436:../Generated_Code/UTIL1.c **** */
 437:../Generated_Code/UTIL1.c **** /*!
 438:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit signed number to a string, in a formatted way (like printf with "%0d").
 439:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 440:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 441:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 442:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 443:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in uint8_ts.
 444:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 445:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 446:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 447:../Generated_Code/UTIL1.c **** */
 448:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStrFormatted(uint8_t *dst, size_t dstSize, int16_t val, char fill, uint8_t nofFi
 449:../Generated_Code/UTIL1.c **** {
 996              		.loc 1 449 0
 997              		.cfi_startproc
 998 0000 80B5     		push	{r7, lr}
 999              	.LCFI24:
 1000              		.cfi_def_cfa_offset 8
 1001              		.cfi_offset 7, -8
 1002              		.cfi_offset 14, -4
 1003 0002 84B0     		sub	sp, sp, #16
 1004              	.LCFI25:
 1005              		.cfi_def_cfa_offset 24
 1006 0004 00AF     		add	r7, sp, #0
 1007              	.LCFI26:
 1008              		.cfi_def_cfa_register 7
 1009 0006 F860     		str	r0, [r7, #12]
 1010 0008 B960     		str	r1, [r7, #8]
 1011 000a 111C     		mov	r1, r2
 1012 000c 1A1C     		mov	r2, r3
 1013 000e BB1D     		add	r3, r7, #6
 1014 0010 1980     		strh	r1, [r3]
 1015 0012 7B1D     		add	r3, r7, #5
 1016 0014 1A70     		strb	r2, [r3]
 450:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, val);
 1017              		.loc 1 450 0
 1018 0016 F968     		ldr	r1, [r7, #12]
 1019 0018 BA68     		ldr	r2, [r7, #8]
 1020 001a BB1D     		add	r3, r7, #6
 1021 001c 0020     		mov	r0, #0
 1022 001e 1B5E     		ldrsh	r3, [r3, r0]
 1023 0020 081C     		mov	r0, r1
 1024 0022 111C     		mov	r1, r2
 1025 0024 1A1C     		mov	r2, r3
 1026 0026 FFF7FEFF 		bl	UTIL1_Num16sToStr
 451:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1027              		.loc 1 451 0
 1028 002a F968     		ldr	r1, [r7, #12]
 1029 002c 7B1D     		add	r3, r7, #5
 1030 002e 1A78     		ldrb	r2, [r3]
 1031 0030 3B1C     		mov	r3, r7
 1032 0032 1833     		add	r3, r3, #24
 1033 0034 1B78     		ldrb	r3, [r3]
 1034 0036 081C     		mov	r0, r1
 1035 0038 111C     		mov	r1, r2
 1036 003a 1A1C     		mov	r2, r3
 1037 003c FFF7FEFF 		bl	ShiftRightAndFill
 452:../Generated_Code/UTIL1.c **** }
 1038              		.loc 1 452 0
 1039 0040 BD46     		mov	sp, r7
 1040 0042 04B0     		add	sp, sp, #16
 1041              		@ sp needed for prologue
 1042 0044 80BD     		pop	{r7, pc}
 1043              		.cfi_endproc
 1044              	.LFE8:
 1046 0046 C046     		.section	.text.UTIL1_Num16uToStrFormatted,"ax",%progbits
 1047              		.align	2
 1048              		.global	UTIL1_Num16uToStrFormatted
 1049              		.code	16
 1050              		.thumb_func
 1052              	UTIL1_Num16uToStrFormatted:
 1053              	.LFB9:
 453:../Generated_Code/UTIL1.c **** 
 454:../Generated_Code/UTIL1.c **** /*
 455:../Generated_Code/UTIL1.c **** ** ===================================================================
 456:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16uToStrFormatted (component Utility)
 457:../Generated_Code/UTIL1.c **** **     Description :
 458:../Generated_Code/UTIL1.c **** **         Converts a 16bit unsigned value to string.
 459:../Generated_Code/UTIL1.c **** **     Parameters  :
 460:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 461:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 462:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 463:../Generated_Code/UTIL1.c **** **                           bytes).
 464:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 465:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 466:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 467:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 468:../Generated_Code/UTIL1.c **** ** ===================================================================
 469:../Generated_Code/UTIL1.c **** */
 470:../Generated_Code/UTIL1.c **** /*!
 471:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit unsigned number to a string, in a formatted way (like printf with "%0d").
 472:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 473:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 474:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 475:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 476:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in uint8_ts.
 477:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 478:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 479:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 480:../Generated_Code/UTIL1.c **** */
 481:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStrFormatted(uint8_t *dst, size_t dstSize, uint16_t val, char fill, uint8_t nofF
 482:../Generated_Code/UTIL1.c **** {
 1054              		.loc 1 482 0
 1055              		.cfi_startproc
 1056 0000 80B5     		push	{r7, lr}
 1057              	.LCFI27:
 1058              		.cfi_def_cfa_offset 8
 1059              		.cfi_offset 7, -8
 1060              		.cfi_offset 14, -4
 1061 0002 84B0     		sub	sp, sp, #16
 1062              	.LCFI28:
 1063              		.cfi_def_cfa_offset 24
 1064 0004 00AF     		add	r7, sp, #0
 1065              	.LCFI29:
 1066              		.cfi_def_cfa_register 7
 1067 0006 F860     		str	r0, [r7, #12]
 1068 0008 B960     		str	r1, [r7, #8]
 1069 000a 111C     		mov	r1, r2
 1070 000c 1A1C     		mov	r2, r3
 1071 000e BB1D     		add	r3, r7, #6
 1072 0010 1980     		strh	r1, [r3]
 1073 0012 7B1D     		add	r3, r7, #5
 1074 0014 1A70     		strb	r2, [r3]
 483:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, val);
 1075              		.loc 1 483 0
 1076 0016 F968     		ldr	r1, [r7, #12]
 1077 0018 BA68     		ldr	r2, [r7, #8]
 1078 001a BB1D     		add	r3, r7, #6
 1079 001c 1B88     		ldrh	r3, [r3]
 1080 001e 081C     		mov	r0, r1
 1081 0020 111C     		mov	r1, r2
 1082 0022 1A1C     		mov	r2, r3
 1083 0024 FFF7FEFF 		bl	UTIL1_Num16uToStr
 484:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1084              		.loc 1 484 0
 1085 0028 F968     		ldr	r1, [r7, #12]
 1086 002a 7B1D     		add	r3, r7, #5
 1087 002c 1A78     		ldrb	r2, [r3]
 1088 002e 3B1C     		mov	r3, r7
 1089 0030 1833     		add	r3, r3, #24
 1090 0032 1B78     		ldrb	r3, [r3]
 1091 0034 081C     		mov	r0, r1
 1092 0036 111C     		mov	r1, r2
 1093 0038 1A1C     		mov	r2, r3
 1094 003a FFF7FEFF 		bl	ShiftRightAndFill
 485:../Generated_Code/UTIL1.c **** }
 1095              		.loc 1 485 0
 1096 003e BD46     		mov	sp, r7
 1097 0040 04B0     		add	sp, sp, #16
 1098              		@ sp needed for prologue
 1099 0042 80BD     		pop	{r7, pc}
 1100              		.cfi_endproc
 1101              	.LFE9:
 1103              		.section	.text.UTIL1_Num32uToStrFormatted,"ax",%progbits
 1104              		.align	2
 1105              		.global	UTIL1_Num32uToStrFormatted
 1106              		.code	16
 1107              		.thumb_func
 1109              	UTIL1_Num32uToStrFormatted:
 1110              	.LFB10:
 486:../Generated_Code/UTIL1.c **** 
 487:../Generated_Code/UTIL1.c **** /*
 488:../Generated_Code/UTIL1.c **** ** ===================================================================
 489:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32uToStrFormatted (component Utility)
 490:../Generated_Code/UTIL1.c **** **     Description :
 491:../Generated_Code/UTIL1.c **** **         Converts a 32bit unsigned value to string.
 492:../Generated_Code/UTIL1.c **** **     Parameters  :
 493:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 494:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 495:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 496:../Generated_Code/UTIL1.c **** **                           bytes).
 497:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 498:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 499:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 500:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 501:../Generated_Code/UTIL1.c **** ** ===================================================================
 502:../Generated_Code/UTIL1.c **** */
 503:../Generated_Code/UTIL1.c **** /*!
 504:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit unsigned number to a string, in a formatted way (like printf with "%0d").
 505:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 506:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 507:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 508:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 509:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in uint8_ts.
 510:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 511:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 512:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 513:../Generated_Code/UTIL1.c **** */
 514:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStrFormatted(uint8_t *dst, size_t dstSize, uint32_t val, char fill, uint8_t nofF
 515:../Generated_Code/UTIL1.c **** {
 1111              		.loc 1 515 0
 1112              		.cfi_startproc
 1113 0000 80B5     		push	{r7, lr}
 1114              	.LCFI30:
 1115              		.cfi_def_cfa_offset 8
 1116              		.cfi_offset 7, -8
 1117              		.cfi_offset 14, -4
 1118 0002 84B0     		sub	sp, sp, #16
 1119              	.LCFI31:
 1120              		.cfi_def_cfa_offset 24
 1121 0004 00AF     		add	r7, sp, #0
 1122              	.LCFI32:
 1123              		.cfi_def_cfa_register 7
 1124 0006 F860     		str	r0, [r7, #12]
 1125 0008 B960     		str	r1, [r7, #8]
 1126 000a 7A60     		str	r2, [r7, #4]
 1127 000c 1A1C     		mov	r2, r3
 1128 000e FB1C     		add	r3, r7, #3
 1129 0010 1A70     		strb	r2, [r3]
 516:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(dst, dstSize, val);
 1130              		.loc 1 516 0
 1131 0012 F968     		ldr	r1, [r7, #12]
 1132 0014 BA68     		ldr	r2, [r7, #8]
 1133 0016 7B68     		ldr	r3, [r7, #4]
 1134 0018 081C     		mov	r0, r1
 1135 001a 111C     		mov	r1, r2
 1136 001c 1A1C     		mov	r2, r3
 1137 001e FFF7FEFF 		bl	UTIL1_Num32uToStr
 517:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1138              		.loc 1 517 0
 1139 0022 F968     		ldr	r1, [r7, #12]
 1140 0024 FB1C     		add	r3, r7, #3
 1141 0026 1A78     		ldrb	r2, [r3]
 1142 0028 3B1C     		mov	r3, r7
 1143 002a 1833     		add	r3, r3, #24
 1144 002c 1B78     		ldrb	r3, [r3]
 1145 002e 081C     		mov	r0, r1
 1146 0030 111C     		mov	r1, r2
 1147 0032 1A1C     		mov	r2, r3
 1148 0034 FFF7FEFF 		bl	ShiftRightAndFill
 518:../Generated_Code/UTIL1.c **** }
 1149              		.loc 1 518 0
 1150 0038 BD46     		mov	sp, r7
 1151 003a 04B0     		add	sp, sp, #16
 1152              		@ sp needed for prologue
 1153 003c 80BD     		pop	{r7, pc}
 1154              		.cfi_endproc
 1155              	.LFE10:
 1157 003e C046     		.section	.text.UTIL1_Num32sToStrFormatted,"ax",%progbits
 1158              		.align	2
 1159              		.global	UTIL1_Num32sToStrFormatted
 1160              		.code	16
 1161              		.thumb_func
 1163              	UTIL1_Num32sToStrFormatted:
 1164              	.LFB11:
 519:../Generated_Code/UTIL1.c **** 
 520:../Generated_Code/UTIL1.c **** /*
 521:../Generated_Code/UTIL1.c **** ** ===================================================================
 522:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32sToStrFormatted (component Utility)
 523:../Generated_Code/UTIL1.c **** **     Description :
 524:../Generated_Code/UTIL1.c **** **         Converts a 32bit signed value to string.
 525:../Generated_Code/UTIL1.c **** **     Parameters  :
 526:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 527:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 528:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 529:../Generated_Code/UTIL1.c **** **                           bytes).
 530:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 531:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 532:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 533:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 534:../Generated_Code/UTIL1.c **** ** ===================================================================
 535:../Generated_Code/UTIL1.c **** */
 536:../Generated_Code/UTIL1.c **** /*!
 537:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit signed number to a string, in a formatted way (like printf with "%0d").
 538:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 539:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 540:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 541:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 542:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in uint8_ts.
 543:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit signed number to add
 544:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 545:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 546:../Generated_Code/UTIL1.c **** */
 547:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStrFormatted(uint8_t *dst, size_t dstSize, int32_t val, char fill, uint8_t nofFi
 548:../Generated_Code/UTIL1.c **** {
 1165              		.loc 1 548 0
 1166              		.cfi_startproc
 1167 0000 80B5     		push	{r7, lr}
 1168              	.LCFI33:
 1169              		.cfi_def_cfa_offset 8
 1170              		.cfi_offset 7, -8
 1171              		.cfi_offset 14, -4
 1172 0002 84B0     		sub	sp, sp, #16
 1173              	.LCFI34:
 1174              		.cfi_def_cfa_offset 24
 1175 0004 00AF     		add	r7, sp, #0
 1176              	.LCFI35:
 1177              		.cfi_def_cfa_register 7
 1178 0006 F860     		str	r0, [r7, #12]
 1179 0008 B960     		str	r1, [r7, #8]
 1180 000a 7A60     		str	r2, [r7, #4]
 1181 000c 1A1C     		mov	r2, r3
 1182 000e FB1C     		add	r3, r7, #3
 1183 0010 1A70     		strb	r2, [r3]
 549:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(dst, dstSize, val);
 1184              		.loc 1 549 0
 1185 0012 F968     		ldr	r1, [r7, #12]
 1186 0014 BA68     		ldr	r2, [r7, #8]
 1187 0016 7B68     		ldr	r3, [r7, #4]
 1188 0018 081C     		mov	r0, r1
 1189 001a 111C     		mov	r1, r2
 1190 001c 1A1C     		mov	r2, r3
 1191 001e FFF7FEFF 		bl	UTIL1_Num32sToStr
 550:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1192              		.loc 1 550 0
 1193 0022 F968     		ldr	r1, [r7, #12]
 1194 0024 FB1C     		add	r3, r7, #3
 1195 0026 1A78     		ldrb	r2, [r3]
 1196 0028 3B1C     		mov	r3, r7
 1197 002a 1833     		add	r3, r3, #24
 1198 002c 1B78     		ldrb	r3, [r3]
 1199 002e 081C     		mov	r0, r1
 1200 0030 111C     		mov	r1, r2
 1201 0032 1A1C     		mov	r2, r3
 1202 0034 FFF7FEFF 		bl	ShiftRightAndFill
 551:../Generated_Code/UTIL1.c **** }
 1203              		.loc 1 551 0
 1204 0038 BD46     		mov	sp, r7
 1205 003a 04B0     		add	sp, sp, #16
 1206              		@ sp needed for prologue
 1207 003c 80BD     		pop	{r7, pc}
 1208              		.cfi_endproc
 1209              	.LFE11:
 1211 003e C046     		.section	.text.UTIL1_strcatNum8u,"ax",%progbits
 1212              		.align	2
 1213              		.global	UTIL1_strcatNum8u
 1214              		.code	16
 1215              		.thumb_func
 1217              	UTIL1_strcatNum8u:
 1218              	.LFB12:
 552:../Generated_Code/UTIL1.c **** 
 553:../Generated_Code/UTIL1.c **** /*
 554:../Generated_Code/UTIL1.c **** ** ===================================================================
 555:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8u (component Utility)
 556:../Generated_Code/UTIL1.c **** **     Description :
 557:../Generated_Code/UTIL1.c **** **         Appends a 8bit unsigned value to a string buffer.
 558:../Generated_Code/UTIL1.c **** **     Parameters  :
 559:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 560:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 561:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 562:../Generated_Code/UTIL1.c **** **                           bytes).
 563:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 564:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 565:../Generated_Code/UTIL1.c **** ** ===================================================================
 566:../Generated_Code/UTIL1.c **** */
 567:../Generated_Code/UTIL1.c **** /*!
 568:../Generated_Code/UTIL1.c ****   \brief appends a 8bit unsigned number to a string. Always terminates the result string.
 569:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 570:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 571:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 572:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 573:../Generated_Code/UTIL1.c ****   \param[in] val The 8bit unsigned number to add
 574:../Generated_Code/UTIL1.c ****   */
 575:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8u(uint8_t *dst, size_t dstSize, uint8_t val)
 576:../Generated_Code/UTIL1.c **** {
 1219              		.loc 1 576 0
 1220              		.cfi_startproc
 1221 0000 80B5     		push	{r7, lr}
 1222              	.LCFI36:
 1223              		.cfi_def_cfa_offset 8
 1224              		.cfi_offset 7, -8
 1225              		.cfi_offset 14, -4
 1226 0002 86B0     		sub	sp, sp, #24
 1227              	.LCFI37:
 1228              		.cfi_def_cfa_offset 32
 1229 0004 00AF     		add	r7, sp, #0
 1230              	.LCFI38:
 1231              		.cfi_def_cfa_register 7
 1232 0006 F860     		str	r0, [r7, #12]
 1233 0008 B960     		str	r1, [r7, #8]
 1234 000a FB1D     		add	r3, r7, #7
 1235 000c 1A70     		strb	r2, [r3]
 577:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("256")]; /* maximum buffer size we need */
 578:../Generated_Code/UTIL1.c **** 
 579:../Generated_Code/UTIL1.c ****   UTIL1_Num8uToStr(buf, sizeof(buf), val);
 1236              		.loc 1 579 0
 1237 000e 3A1C     		mov	r2, r7
 1238 0010 1432     		add	r2, r2, #20
 1239 0012 FB1D     		add	r3, r7, #7
 1240 0014 1B78     		ldrb	r3, [r3]
 1241 0016 101C     		mov	r0, r2
 1242 0018 0421     		mov	r1, #4
 1243 001a 1A1C     		mov	r2, r3
 1244 001c FFF7FEFF 		bl	UTIL1_Num8uToStr
 580:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1245              		.loc 1 580 0
 1246 0020 F968     		ldr	r1, [r7, #12]
 1247 0022 BA68     		ldr	r2, [r7, #8]
 1248 0024 3B1C     		mov	r3, r7
 1249 0026 1433     		add	r3, r3, #20
 1250 0028 081C     		mov	r0, r1
 1251 002a 111C     		mov	r1, r2
 1252 002c 1A1C     		mov	r2, r3
 1253 002e FFF7FEFF 		bl	UTIL1_strcat
 581:../Generated_Code/UTIL1.c **** }
 1254              		.loc 1 581 0
 1255 0032 BD46     		mov	sp, r7
 1256 0034 06B0     		add	sp, sp, #24
 1257              		@ sp needed for prologue
 1258 0036 80BD     		pop	{r7, pc}
 1259              		.cfi_endproc
 1260              	.LFE12:
 1262              		.section	.text.UTIL1_strcatNum8s,"ax",%progbits
 1263              		.align	2
 1264              		.global	UTIL1_strcatNum8s
 1265              		.code	16
 1266              		.thumb_func
 1268              	UTIL1_strcatNum8s:
 1269              	.LFB13:
 582:../Generated_Code/UTIL1.c **** 
 583:../Generated_Code/UTIL1.c **** /*
 584:../Generated_Code/UTIL1.c **** ** ===================================================================
 585:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8s (component Utility)
 586:../Generated_Code/UTIL1.c **** **     Description :
 587:../Generated_Code/UTIL1.c **** **         Appends a 8bit signed value to a string buffer.
 588:../Generated_Code/UTIL1.c **** **     Parameters  :
 589:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 590:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 591:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 592:../Generated_Code/UTIL1.c **** **                           bytes).
 593:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 594:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 595:../Generated_Code/UTIL1.c **** ** ===================================================================
 596:../Generated_Code/UTIL1.c **** */
 597:../Generated_Code/UTIL1.c **** /*!
 598:../Generated_Code/UTIL1.c ****   \brief appends a 8bit signed number to a string. Always terminates the result string.
 599:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 600:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 601:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 602:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 603:../Generated_Code/UTIL1.c ****   \param[in] val The 8bit signed number to add
 604:../Generated_Code/UTIL1.c ****   */
 605:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8s(uint8_t *dst, size_t dstSize, signed char val)
 606:../Generated_Code/UTIL1.c **** {
 1270              		.loc 1 606 0
 1271              		.cfi_startproc
 1272 0000 80B5     		push	{r7, lr}
 1273              	.LCFI39:
 1274              		.cfi_def_cfa_offset 8
 1275              		.cfi_offset 7, -8
 1276              		.cfi_offset 14, -4
 1277 0002 86B0     		sub	sp, sp, #24
 1278              	.LCFI40:
 1279              		.cfi_def_cfa_offset 32
 1280 0004 00AF     		add	r7, sp, #0
 1281              	.LCFI41:
 1282              		.cfi_def_cfa_register 7
 1283 0006 F860     		str	r0, [r7, #12]
 1284 0008 B960     		str	r1, [r7, #8]
 1285 000a FB1D     		add	r3, r7, #7
 1286 000c 1A70     		strb	r2, [r3]
 607:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-128")]; /* maximum buffer size we need */
 608:../Generated_Code/UTIL1.c **** 
 609:../Generated_Code/UTIL1.c ****   UTIL1_Num8sToStr(buf, sizeof(buf), val);
 1287              		.loc 1 609 0
 1288 000e 3A1C     		mov	r2, r7
 1289 0010 1032     		add	r2, r2, #16
 1290 0012 FB1D     		add	r3, r7, #7
 1291 0014 1B78     		ldrb	r3, [r3]
 1292 0016 5BB2     		sxtb	r3, r3
 1293 0018 101C     		mov	r0, r2
 1294 001a 0521     		mov	r1, #5
 1295 001c 1A1C     		mov	r2, r3
 1296 001e FFF7FEFF 		bl	UTIL1_Num8sToStr
 610:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1297              		.loc 1 610 0
 1298 0022 F968     		ldr	r1, [r7, #12]
 1299 0024 BA68     		ldr	r2, [r7, #8]
 1300 0026 3B1C     		mov	r3, r7
 1301 0028 1033     		add	r3, r3, #16
 1302 002a 081C     		mov	r0, r1
 1303 002c 111C     		mov	r1, r2
 1304 002e 1A1C     		mov	r2, r3
 1305 0030 FFF7FEFF 		bl	UTIL1_strcat
 611:../Generated_Code/UTIL1.c **** }
 1306              		.loc 1 611 0
 1307 0034 BD46     		mov	sp, r7
 1308 0036 06B0     		add	sp, sp, #24
 1309              		@ sp needed for prologue
 1310 0038 80BD     		pop	{r7, pc}
 1311              		.cfi_endproc
 1312              	.LFE13:
 1314 003a C046     		.section	.text.UTIL1_strcatNum16u,"ax",%progbits
 1315              		.align	2
 1316              		.global	UTIL1_strcatNum16u
 1317              		.code	16
 1318              		.thumb_func
 1320              	UTIL1_strcatNum16u:
 1321              	.LFB14:
 612:../Generated_Code/UTIL1.c **** 
 613:../Generated_Code/UTIL1.c **** /*
 614:../Generated_Code/UTIL1.c **** ** ===================================================================
 615:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16u (component Utility)
 616:../Generated_Code/UTIL1.c **** **     Description :
 617:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer.
 618:../Generated_Code/UTIL1.c **** **     Parameters  :
 619:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 620:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 621:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 622:../Generated_Code/UTIL1.c **** **                           bytes).
 623:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 624:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 625:../Generated_Code/UTIL1.c **** ** ===================================================================
 626:../Generated_Code/UTIL1.c **** */
 627:../Generated_Code/UTIL1.c **** /*!
 628:../Generated_Code/UTIL1.c ****   \brief appends a 16bit unsigned number to a string. Always terminates the result string.
 629:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 630:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 631:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 632:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 633:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 634:../Generated_Code/UTIL1.c ****   */
 635:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16u(uint8_t *dst, size_t dstSize, uint16_t val)
 636:../Generated_Code/UTIL1.c **** {
 1322              		.loc 1 636 0
 1323              		.cfi_startproc
 1324 0000 80B5     		push	{r7, lr}
 1325              	.LCFI42:
 1326              		.cfi_def_cfa_offset 8
 1327              		.cfi_offset 7, -8
 1328              		.cfi_offset 14, -4
 1329 0002 86B0     		sub	sp, sp, #24
 1330              	.LCFI43:
 1331              		.cfi_def_cfa_offset 32
 1332 0004 00AF     		add	r7, sp, #0
 1333              	.LCFI44:
 1334              		.cfi_def_cfa_register 7
 1335 0006 F860     		str	r0, [r7, #12]
 1336 0008 B960     		str	r1, [r7, #8]
 1337 000a BB1D     		add	r3, r7, #6
 1338 000c 1A80     		strh	r2, [r3]
 637:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 638:../Generated_Code/UTIL1.c **** 
 639:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(buf, sizeof(buf), val);
 1339              		.loc 1 639 0
 1340 000e 3A1C     		mov	r2, r7
 1341 0010 1032     		add	r2, r2, #16
 1342 0012 BB1D     		add	r3, r7, #6
 1343 0014 1B88     		ldrh	r3, [r3]
 1344 0016 101C     		mov	r0, r2
 1345 0018 0621     		mov	r1, #6
 1346 001a 1A1C     		mov	r2, r3
 1347 001c FFF7FEFF 		bl	UTIL1_Num16uToStr
 640:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1348              		.loc 1 640 0
 1349 0020 F968     		ldr	r1, [r7, #12]
 1350 0022 BA68     		ldr	r2, [r7, #8]
 1351 0024 3B1C     		mov	r3, r7
 1352 0026 1033     		add	r3, r3, #16
 1353 0028 081C     		mov	r0, r1
 1354 002a 111C     		mov	r1, r2
 1355 002c 1A1C     		mov	r2, r3
 1356 002e FFF7FEFF 		bl	UTIL1_strcat
 641:../Generated_Code/UTIL1.c **** }
 1357              		.loc 1 641 0
 1358 0032 BD46     		mov	sp, r7
 1359 0034 06B0     		add	sp, sp, #24
 1360              		@ sp needed for prologue
 1361 0036 80BD     		pop	{r7, pc}
 1362              		.cfi_endproc
 1363              	.LFE14:
 1365              		.section	.text.UTIL1_strcatNum16s,"ax",%progbits
 1366              		.align	2
 1367              		.global	UTIL1_strcatNum16s
 1368              		.code	16
 1369              		.thumb_func
 1371              	UTIL1_strcatNum16s:
 1372              	.LFB15:
 642:../Generated_Code/UTIL1.c **** 
 643:../Generated_Code/UTIL1.c **** /*
 644:../Generated_Code/UTIL1.c **** ** ===================================================================
 645:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16s (component Utility)
 646:../Generated_Code/UTIL1.c **** **     Description :
 647:../Generated_Code/UTIL1.c **** **         Appends a 16bit signed value to a string buffer.
 648:../Generated_Code/UTIL1.c **** **     Parameters  :
 649:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 650:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 651:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 652:../Generated_Code/UTIL1.c **** **                           bytes).
 653:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 654:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 655:../Generated_Code/UTIL1.c **** ** ===================================================================
 656:../Generated_Code/UTIL1.c **** */
 657:../Generated_Code/UTIL1.c **** /*!
 658:../Generated_Code/UTIL1.c ****   \brief appends a 16bit signed number to a string. Always terminates the result string.
 659:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 660:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 661:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 662:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 663:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 664:../Generated_Code/UTIL1.c ****   */
 665:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16s(uint8_t *dst, size_t dstSize, int16_t val)
 666:../Generated_Code/UTIL1.c **** {
 1373              		.loc 1 666 0
 1374              		.cfi_startproc
 1375 0000 80B5     		push	{r7, lr}
 1376              	.LCFI45:
 1377              		.cfi_def_cfa_offset 8
 1378              		.cfi_offset 7, -8
 1379              		.cfi_offset 14, -4
 1380 0002 86B0     		sub	sp, sp, #24
 1381              	.LCFI46:
 1382              		.cfi_def_cfa_offset 32
 1383 0004 00AF     		add	r7, sp, #0
 1384              	.LCFI47:
 1385              		.cfi_def_cfa_register 7
 1386 0006 F860     		str	r0, [r7, #12]
 1387 0008 B960     		str	r1, [r7, #8]
 1388 000a BB1D     		add	r3, r7, #6
 1389 000c 1A80     		strh	r2, [r3]
 667:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 668:../Generated_Code/UTIL1.c **** 
 669:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(buf, sizeof(buf), val);
 1390              		.loc 1 669 0
 1391 000e 3A1C     		mov	r2, r7
 1392 0010 1032     		add	r2, r2, #16
 1393 0012 BB1D     		add	r3, r7, #6
 1394 0014 0021     		mov	r1, #0
 1395 0016 5B5E     		ldrsh	r3, [r3, r1]
 1396 0018 101C     		mov	r0, r2
 1397 001a 0721     		mov	r1, #7
 1398 001c 1A1C     		mov	r2, r3
 1399 001e FFF7FEFF 		bl	UTIL1_Num16sToStr
 670:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1400              		.loc 1 670 0
 1401 0022 F968     		ldr	r1, [r7, #12]
 1402 0024 BA68     		ldr	r2, [r7, #8]
 1403 0026 3B1C     		mov	r3, r7
 1404 0028 1033     		add	r3, r3, #16
 1405 002a 081C     		mov	r0, r1
 1406 002c 111C     		mov	r1, r2
 1407 002e 1A1C     		mov	r2, r3
 1408 0030 FFF7FEFF 		bl	UTIL1_strcat
 671:../Generated_Code/UTIL1.c **** }
 1409              		.loc 1 671 0
 1410 0034 BD46     		mov	sp, r7
 1411 0036 06B0     		add	sp, sp, #24
 1412              		@ sp needed for prologue
 1413 0038 80BD     		pop	{r7, pc}
 1414              		.cfi_endproc
 1415              	.LFE15:
 1417 003a C046     		.section	.text.UTIL1_strcatNum16uFormatted,"ax",%progbits
 1418              		.align	2
 1419              		.global	UTIL1_strcatNum16uFormatted
 1420              		.code	16
 1421              		.thumb_func
 1423              	UTIL1_strcatNum16uFormatted:
 1424              	.LFB16:
 672:../Generated_Code/UTIL1.c **** 
 673:../Generated_Code/UTIL1.c **** /*
 674:../Generated_Code/UTIL1.c **** ** ===================================================================
 675:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16uFormatted (component Utility)
 676:../Generated_Code/UTIL1.c **** **     Description :
 677:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer in a
 678:../Generated_Code/UTIL1.c **** **         formatted way.
 679:../Generated_Code/UTIL1.c **** **     Parameters  :
 680:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 681:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 682:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 683:../Generated_Code/UTIL1.c **** **                           bytes).
 684:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 685:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 686:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 687:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 688:../Generated_Code/UTIL1.c **** ** ===================================================================
 689:../Generated_Code/UTIL1.c **** */
 690:../Generated_Code/UTIL1.c **** /*!
 691:../Generated_Code/UTIL1.c ****   \brief appends a 16bit unsigned number to a string, in a formatted way (like printf with "%0d".
 692:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 693:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 694:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 695:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 696:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 697:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 698:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 699:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 700:../Generated_Code/UTIL1.c ****   */
 701:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16uFormatted(uint8_t *dst, size_t dstSize, uint16_t val, char fill, uint8_t nof
 702:../Generated_Code/UTIL1.c **** {
 1425              		.loc 1 702 0
 1426              		.cfi_startproc
 1427 0000 90B5     		push	{r4, r7, lr}
 1428              	.LCFI48:
 1429              		.cfi_def_cfa_offset 12
 1430              		.cfi_offset 4, -12
 1431              		.cfi_offset 7, -8
 1432              		.cfi_offset 14, -4
 1433 0002 89B0     		sub	sp, sp, #36
 1434              	.LCFI49:
 1435              		.cfi_def_cfa_offset 48
 1436 0004 02AF     		add	r7, sp, #8
 1437              	.LCFI50:
 1438              		.cfi_def_cfa 7, 40
 1439 0006 F860     		str	r0, [r7, #12]
 1440 0008 B960     		str	r1, [r7, #8]
 1441 000a 111C     		mov	r1, r2
 1442 000c 1A1C     		mov	r2, r3
 1443 000e BB1D     		add	r3, r7, #6
 1444 0010 1980     		strh	r1, [r3]
 1445 0012 7B1D     		add	r3, r7, #5
 1446 0014 1A70     		strb	r2, [r3]
 703:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 704:../Generated_Code/UTIL1.c **** 
 705:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1447              		.loc 1 705 0
 1448 0016 381C     		mov	r0, r7
 1449 0018 1030     		add	r0, r0, #16
 1450 001a B968     		ldr	r1, [r7, #8]
 1451 001c BB1D     		add	r3, r7, #6
 1452 001e 1A88     		ldrh	r2, [r3]
 1453 0020 7B1D     		add	r3, r7, #5
 1454 0022 1B78     		ldrb	r3, [r3]
 1455 0024 3C1C     		mov	r4, r7
 1456 0026 2834     		add	r4, r4, #40
 1457 0028 2478     		ldrb	r4, [r4]
 1458 002a 0094     		str	r4, [sp]
 1459 002c FFF7FEFF 		bl	UTIL1_Num16uToStrFormatted
 706:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1460              		.loc 1 706 0
 1461 0030 F968     		ldr	r1, [r7, #12]
 1462 0032 BA68     		ldr	r2, [r7, #8]
 1463 0034 3B1C     		mov	r3, r7
 1464 0036 1033     		add	r3, r3, #16
 1465 0038 081C     		mov	r0, r1
 1466 003a 111C     		mov	r1, r2
 1467 003c 1A1C     		mov	r2, r3
 1468 003e FFF7FEFF 		bl	UTIL1_strcat
 707:../Generated_Code/UTIL1.c **** }
 1469              		.loc 1 707 0
 1470 0042 BD46     		mov	sp, r7
 1471 0044 07B0     		add	sp, sp, #28
 1472              		@ sp needed for prologue
 1473 0046 90BD     		pop	{r4, r7, pc}
 1474              		.cfi_endproc
 1475              	.LFE16:
 1477              		.section	.text.UTIL1_strcatNum16sFormatted,"ax",%progbits
 1478              		.align	2
 1479              		.global	UTIL1_strcatNum16sFormatted
 1480              		.code	16
 1481              		.thumb_func
 1483              	UTIL1_strcatNum16sFormatted:
 1484              	.LFB17:
 708:../Generated_Code/UTIL1.c **** 
 709:../Generated_Code/UTIL1.c **** /*
 710:../Generated_Code/UTIL1.c **** ** ===================================================================
 711:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16sFormatted (component Utility)
 712:../Generated_Code/UTIL1.c **** **     Description :
 713:../Generated_Code/UTIL1.c **** **         Appends a 16bit signed value to a string buffer in a
 714:../Generated_Code/UTIL1.c **** **         formatted way.
 715:../Generated_Code/UTIL1.c **** **     Parameters  :
 716:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 717:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 718:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 719:../Generated_Code/UTIL1.c **** **                           bytes).
 720:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 721:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 722:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 723:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 724:../Generated_Code/UTIL1.c **** ** ===================================================================
 725:../Generated_Code/UTIL1.c **** */
 726:../Generated_Code/UTIL1.c **** /*!
 727:../Generated_Code/UTIL1.c ****   \brief appends a 16bit signed number to a string, in a formatted way (like printf with "%0d".
 728:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 729:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 730:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 731:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 732:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 733:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 734:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 735:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 736:../Generated_Code/UTIL1.c ****   */
 737:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16sFormatted(uint8_t *dst, size_t dstSize, int16_t val, char fill, uint8_t nofF
 738:../Generated_Code/UTIL1.c **** {
 1485              		.loc 1 738 0
 1486              		.cfi_startproc
 1487 0000 90B5     		push	{r4, r7, lr}
 1488              	.LCFI51:
 1489              		.cfi_def_cfa_offset 12
 1490              		.cfi_offset 4, -12
 1491              		.cfi_offset 7, -8
 1492              		.cfi_offset 14, -4
 1493 0002 89B0     		sub	sp, sp, #36
 1494              	.LCFI52:
 1495              		.cfi_def_cfa_offset 48
 1496 0004 02AF     		add	r7, sp, #8
 1497              	.LCFI53:
 1498              		.cfi_def_cfa 7, 40
 1499 0006 F860     		str	r0, [r7, #12]
 1500 0008 B960     		str	r1, [r7, #8]
 1501 000a 111C     		mov	r1, r2
 1502 000c 1A1C     		mov	r2, r3
 1503 000e BB1D     		add	r3, r7, #6
 1504 0010 1980     		strh	r1, [r3]
 1505 0012 7B1D     		add	r3, r7, #5
 1506 0014 1A70     		strb	r2, [r3]
 739:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 740:../Generated_Code/UTIL1.c **** 
 741:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1507              		.loc 1 741 0
 1508 0016 381C     		mov	r0, r7
 1509 0018 1030     		add	r0, r0, #16
 1510 001a B968     		ldr	r1, [r7, #8]
 1511 001c BB1D     		add	r3, r7, #6
 1512 001e 0024     		mov	r4, #0
 1513 0020 1A5F     		ldrsh	r2, [r3, r4]
 1514 0022 7B1D     		add	r3, r7, #5
 1515 0024 1B78     		ldrb	r3, [r3]
 1516 0026 3C1C     		mov	r4, r7
 1517 0028 2834     		add	r4, r4, #40
 1518 002a 2478     		ldrb	r4, [r4]
 1519 002c 0094     		str	r4, [sp]
 1520 002e FFF7FEFF 		bl	UTIL1_Num16sToStrFormatted
 742:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1521              		.loc 1 742 0
 1522 0032 F968     		ldr	r1, [r7, #12]
 1523 0034 BA68     		ldr	r2, [r7, #8]
 1524 0036 3B1C     		mov	r3, r7
 1525 0038 1033     		add	r3, r3, #16
 1526 003a 081C     		mov	r0, r1
 1527 003c 111C     		mov	r1, r2
 1528 003e 1A1C     		mov	r2, r3
 1529 0040 FFF7FEFF 		bl	UTIL1_strcat
 743:../Generated_Code/UTIL1.c **** }
 1530              		.loc 1 743 0
 1531 0044 BD46     		mov	sp, r7
 1532 0046 07B0     		add	sp, sp, #28
 1533              		@ sp needed for prologue
 1534 0048 90BD     		pop	{r4, r7, pc}
 1535              		.cfi_endproc
 1536              	.LFE17:
 1538 004a C046     		.section	.text.UTIL1_strcatNum32uFormatted,"ax",%progbits
 1539              		.align	2
 1540              		.global	UTIL1_strcatNum32uFormatted
 1541              		.code	16
 1542              		.thumb_func
 1544              	UTIL1_strcatNum32uFormatted:
 1545              	.LFB18:
 744:../Generated_Code/UTIL1.c **** 
 745:../Generated_Code/UTIL1.c **** /*
 746:../Generated_Code/UTIL1.c **** ** ===================================================================
 747:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32uFormatted (component Utility)
 748:../Generated_Code/UTIL1.c **** **     Description :
 749:../Generated_Code/UTIL1.c **** **         Appends a 32bit unsigned value to a string buffer in a
 750:../Generated_Code/UTIL1.c **** **         formatted way.
 751:../Generated_Code/UTIL1.c **** **     Parameters  :
 752:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 753:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 754:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 755:../Generated_Code/UTIL1.c **** **                           bytes).
 756:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 757:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 758:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 759:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 760:../Generated_Code/UTIL1.c **** ** ===================================================================
 761:../Generated_Code/UTIL1.c **** */
 762:../Generated_Code/UTIL1.c **** /*!
 763:../Generated_Code/UTIL1.c ****   \brief appends a 32bit unsigned number to a string, in a formatted way (like printf with "%0d".
 764:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 765:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 766:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 767:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 768:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 769:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 770:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 771:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 772:../Generated_Code/UTIL1.c ****   */
 773:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32uFormatted(uint8_t *dst, size_t dstSize, uint32_t val, char fill, uint8_t nof
 774:../Generated_Code/UTIL1.c **** {
 1546              		.loc 1 774 0
 1547              		.cfi_startproc
 1548 0000 90B5     		push	{r4, r7, lr}
 1549              	.LCFI54:
 1550              		.cfi_def_cfa_offset 12
 1551              		.cfi_offset 4, -12
 1552              		.cfi_offset 7, -8
 1553              		.cfi_offset 14, -4
 1554 0002 8BB0     		sub	sp, sp, #44
 1555              	.LCFI55:
 1556              		.cfi_def_cfa_offset 56
 1557 0004 02AF     		add	r7, sp, #8
 1558              	.LCFI56:
 1559              		.cfi_def_cfa 7, 48
 1560 0006 F860     		str	r0, [r7, #12]
 1561 0008 B960     		str	r1, [r7, #8]
 1562 000a 7A60     		str	r2, [r7, #4]
 1563 000c 1A1C     		mov	r2, r3
 1564 000e FB1C     		add	r3, r7, #3
 1565 0010 1A70     		strb	r2, [r3]
 775:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 776:../Generated_Code/UTIL1.c **** 
 777:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1566              		.loc 1 777 0
 1567 0012 381C     		mov	r0, r7
 1568 0014 1430     		add	r0, r0, #20
 1569 0016 B968     		ldr	r1, [r7, #8]
 1570 0018 7A68     		ldr	r2, [r7, #4]
 1571 001a FB1C     		add	r3, r7, #3
 1572 001c 1B78     		ldrb	r3, [r3]
 1573 001e 3C1C     		mov	r4, r7
 1574 0020 3034     		add	r4, r4, #48
 1575 0022 2478     		ldrb	r4, [r4]
 1576 0024 0094     		str	r4, [sp]
 1577 0026 FFF7FEFF 		bl	UTIL1_Num32uToStrFormatted
 778:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1578              		.loc 1 778 0
 1579 002a F968     		ldr	r1, [r7, #12]
 1580 002c BA68     		ldr	r2, [r7, #8]
 1581 002e 3B1C     		mov	r3, r7
 1582 0030 1433     		add	r3, r3, #20
 1583 0032 081C     		mov	r0, r1
 1584 0034 111C     		mov	r1, r2
 1585 0036 1A1C     		mov	r2, r3
 1586 0038 FFF7FEFF 		bl	UTIL1_strcat
 779:../Generated_Code/UTIL1.c **** }
 1587              		.loc 1 779 0
 1588 003c BD46     		mov	sp, r7
 1589 003e 09B0     		add	sp, sp, #36
 1590              		@ sp needed for prologue
 1591 0040 90BD     		pop	{r4, r7, pc}
 1592              		.cfi_endproc
 1593              	.LFE18:
 1595 0042 C046     		.section	.text.UTIL1_strcatNum32sFormatted,"ax",%progbits
 1596              		.align	2
 1597              		.global	UTIL1_strcatNum32sFormatted
 1598              		.code	16
 1599              		.thumb_func
 1601              	UTIL1_strcatNum32sFormatted:
 1602              	.LFB19:
 780:../Generated_Code/UTIL1.c **** 
 781:../Generated_Code/UTIL1.c **** /*
 782:../Generated_Code/UTIL1.c **** ** ===================================================================
 783:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32sFormatted (component Utility)
 784:../Generated_Code/UTIL1.c **** **     Description :
 785:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer in a
 786:../Generated_Code/UTIL1.c **** **         formatted way.
 787:../Generated_Code/UTIL1.c **** **     Parameters  :
 788:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 789:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 790:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 791:../Generated_Code/UTIL1.c **** **                           bytes).
 792:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 793:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 794:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 795:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 796:../Generated_Code/UTIL1.c **** ** ===================================================================
 797:../Generated_Code/UTIL1.c **** */
 798:../Generated_Code/UTIL1.c **** /*!
 799:../Generated_Code/UTIL1.c ****   \brief appends a 32bit signed number to a string, in a formatted way (like printf with "%0d".
 800:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 801:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 802:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 803:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 804:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 805:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit signed number to add
 806:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 807:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 808:../Generated_Code/UTIL1.c ****   */
 809:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32sFormatted(uint8_t *dst, size_t dstSize, int32_t val, char fill, uint8_t nofF
 810:../Generated_Code/UTIL1.c **** {
 1603              		.loc 1 810 0
 1604              		.cfi_startproc
 1605 0000 90B5     		push	{r4, r7, lr}
 1606              	.LCFI57:
 1607              		.cfi_def_cfa_offset 12
 1608              		.cfi_offset 4, -12
 1609              		.cfi_offset 7, -8
 1610              		.cfi_offset 14, -4
 1611 0002 8BB0     		sub	sp, sp, #44
 1612              	.LCFI58:
 1613              		.cfi_def_cfa_offset 56
 1614 0004 02AF     		add	r7, sp, #8
 1615              	.LCFI59:
 1616              		.cfi_def_cfa 7, 48
 1617 0006 F860     		str	r0, [r7, #12]
 1618 0008 B960     		str	r1, [r7, #8]
 1619 000a 7A60     		str	r2, [r7, #4]
 1620 000c 1A1C     		mov	r2, r3
 1621 000e FB1C     		add	r3, r7, #3
 1622 0010 1A70     		strb	r2, [r3]
 811:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 812:../Generated_Code/UTIL1.c **** 
 813:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1623              		.loc 1 813 0
 1624 0012 381C     		mov	r0, r7
 1625 0014 1430     		add	r0, r0, #20
 1626 0016 B968     		ldr	r1, [r7, #8]
 1627 0018 7A68     		ldr	r2, [r7, #4]
 1628 001a FB1C     		add	r3, r7, #3
 1629 001c 1B78     		ldrb	r3, [r3]
 1630 001e 3C1C     		mov	r4, r7
 1631 0020 3034     		add	r4, r4, #48
 1632 0022 2478     		ldrb	r4, [r4]
 1633 0024 0094     		str	r4, [sp]
 1634 0026 FFF7FEFF 		bl	UTIL1_Num32sToStrFormatted
 814:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1635              		.loc 1 814 0
 1636 002a F968     		ldr	r1, [r7, #12]
 1637 002c BA68     		ldr	r2, [r7, #8]
 1638 002e 3B1C     		mov	r3, r7
 1639 0030 1433     		add	r3, r3, #20
 1640 0032 081C     		mov	r0, r1
 1641 0034 111C     		mov	r1, r2
 1642 0036 1A1C     		mov	r2, r3
 1643 0038 FFF7FEFF 		bl	UTIL1_strcat
 815:../Generated_Code/UTIL1.c **** }
 1644              		.loc 1 815 0
 1645 003c BD46     		mov	sp, r7
 1646 003e 09B0     		add	sp, sp, #36
 1647              		@ sp needed for prologue
 1648 0040 90BD     		pop	{r4, r7, pc}
 1649              		.cfi_endproc
 1650              	.LFE19:
 1652 0042 C046     		.section	.text.UTIL1_strcatNum8Hex,"ax",%progbits
 1653              		.align	2
 1654              		.global	UTIL1_strcatNum8Hex
 1655              		.code	16
 1656              		.thumb_func
 1658              	UTIL1_strcatNum8Hex:
 1659              	.LFB20:
 816:../Generated_Code/UTIL1.c **** 
 817:../Generated_Code/UTIL1.c **** /*
 818:../Generated_Code/UTIL1.c **** ** ===================================================================
 819:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8Hex (component Utility)
 820:../Generated_Code/UTIL1.c **** **     Description :
 821:../Generated_Code/UTIL1.c **** **         Appends a 8bit unsigned value to a string buffer as hex
 822:../Generated_Code/UTIL1.c **** **         number (without a 0x prefix).
 823:../Generated_Code/UTIL1.c **** **     Parameters  :
 824:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 825:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 826:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 827:../Generated_Code/UTIL1.c **** **                           bytes).
 828:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 829:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 830:../Generated_Code/UTIL1.c **** ** ===================================================================
 831:../Generated_Code/UTIL1.c **** */
 832:../Generated_Code/UTIL1.c **** /*!
 833:../Generated_Code/UTIL1.c ****   \brief Adds a 8bit number as hex value to a string.
 834:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 835:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 836:../Generated_Code/UTIL1.c ****   \param[in] num The 8bit number to add
 837:../Generated_Code/UTIL1.c ****   */
 838:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8Hex(uint8_t *dst, size_t dstSize, uint8_t num)
 839:../Generated_Code/UTIL1.c **** {
 1660              		.loc 1 839 0
 1661              		.cfi_startproc
 1662 0000 80B5     		push	{r7, lr}
 1663              	.LCFI60:
 1664              		.cfi_def_cfa_offset 8
 1665              		.cfi_offset 7, -8
 1666              		.cfi_offset 14, -4
 1667 0002 86B0     		sub	sp, sp, #24
 1668              	.LCFI61:
 1669              		.cfi_def_cfa_offset 32
 1670 0004 00AF     		add	r7, sp, #0
 1671              	.LCFI62:
 1672              		.cfi_def_cfa_register 7
 1673 0006 F860     		str	r0, [r7, #12]
 1674 0008 B960     		str	r1, [r7, #8]
 1675 000a FB1D     		add	r3, r7, #7
 1676 000c 1A70     		strb	r2, [r3]
 840:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FF")]; /* maximum buffer size we need */
 841:../Generated_Code/UTIL1.c ****   unsigned char hex;
 842:../Generated_Code/UTIL1.c **** 
 843:../Generated_Code/UTIL1.c ****   buf[2] = '\0';
 1677              		.loc 1 843 0
 1678 000e 3B1C     		mov	r3, r7
 1679 0010 1433     		add	r3, r3, #20
 1680 0012 0022     		mov	r2, #0
 1681 0014 9A70     		strb	r2, [r3, #2]
 844:../Generated_Code/UTIL1.c ****   hex = (char)(num & 0x0F);
 1682              		.loc 1 844 0
 1683 0016 3B1C     		mov	r3, r7
 1684 0018 1733     		add	r3, r3, #23
 1685 001a FA1D     		add	r2, r7, #7
 1686 001c 1178     		ldrb	r1, [r2]
 1687 001e 0F22     		mov	r2, #15
 1688 0020 0A40     		and	r2, r1
 1689 0022 1A70     		strb	r2, [r3]
 845:../Generated_Code/UTIL1.c ****   buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1690              		.loc 1 845 0
 1691 0024 3B1C     		mov	r3, r7
 1692 0026 1733     		add	r3, r3, #23
 1693 0028 1B78     		ldrb	r3, [r3]
 1694 002a 092B     		cmp	r3, #9
 1695 002c 01D8     		bhi	.L60
 1696              		.loc 1 845 0 is_stmt 0
 1697 002e 3023     		mov	r3, #48
 1698 0030 00E0     		b	.L61
 1699              	.L60:
 1700              		.loc 1 845 0
 1701 0032 3723     		mov	r3, #55
 1702              	.L61:
 1703              		.loc 1 845 0
 1704 0034 3A1C     		mov	r2, r7
 1705 0036 1732     		add	r2, r2, #23
 1706 0038 1278     		ldrb	r2, [r2]
 1707 003a 9B18     		add	r3, r3, r2
 1708 003c DAB2     		uxtb	r2, r3
 1709 003e 3B1C     		mov	r3, r7
 1710 0040 1433     		add	r3, r3, #20
 1711 0042 5A70     		strb	r2, [r3, #1]
 846:../Generated_Code/UTIL1.c ****   hex = (char)((num>>4) & 0x0F);
 1712              		.loc 1 846 0 is_stmt 1
 1713 0044 3B1C     		mov	r3, r7
 1714 0046 1733     		add	r3, r3, #23
 1715 0048 FA1D     		add	r2, r7, #7
 1716 004a 1278     		ldrb	r2, [r2]
 1717 004c 1209     		lsr	r2, r2, #4
 1718 004e 1A70     		strb	r2, [r3]
 847:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1719              		.loc 1 847 0
 1720 0050 3B1C     		mov	r3, r7
 1721 0052 1733     		add	r3, r3, #23
 1722 0054 1B78     		ldrb	r3, [r3]
 1723 0056 092B     		cmp	r3, #9
 1724 0058 01D8     		bhi	.L62
 1725              		.loc 1 847 0 is_stmt 0
 1726 005a 3023     		mov	r3, #48
 1727 005c 00E0     		b	.L63
 1728              	.L62:
 1729              		.loc 1 847 0
 1730 005e 3723     		mov	r3, #55
 1731              	.L63:
 1732              		.loc 1 847 0
 1733 0060 3A1C     		mov	r2, r7
 1734 0062 1732     		add	r2, r2, #23
 1735 0064 1278     		ldrb	r2, [r2]
 1736 0066 9B18     		add	r3, r3, r2
 1737 0068 DAB2     		uxtb	r2, r3
 1738 006a 3B1C     		mov	r3, r7
 1739 006c 1433     		add	r3, r3, #20
 1740 006e 1A70     		strb	r2, [r3]
 848:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1741              		.loc 1 848 0 is_stmt 1
 1742 0070 F968     		ldr	r1, [r7, #12]
 1743 0072 BA68     		ldr	r2, [r7, #8]
 1744 0074 3B1C     		mov	r3, r7
 1745 0076 1433     		add	r3, r3, #20
 1746 0078 081C     		mov	r0, r1
 1747 007a 111C     		mov	r1, r2
 1748 007c 1A1C     		mov	r2, r3
 1749 007e FFF7FEFF 		bl	UTIL1_strcat
 849:../Generated_Code/UTIL1.c **** }
 1750              		.loc 1 849 0
 1751 0082 BD46     		mov	sp, r7
 1752 0084 06B0     		add	sp, sp, #24
 1753              		@ sp needed for prologue
 1754 0086 80BD     		pop	{r7, pc}
 1755              		.cfi_endproc
 1756              	.LFE20:
 1758              		.section	.text.UTIL1_strcatNum16Hex,"ax",%progbits
 1759              		.align	2
 1760              		.global	UTIL1_strcatNum16Hex
 1761              		.code	16
 1762              		.thumb_func
 1764              	UTIL1_strcatNum16Hex:
 1765              	.LFB21:
 850:../Generated_Code/UTIL1.c **** 
 851:../Generated_Code/UTIL1.c **** /*
 852:../Generated_Code/UTIL1.c **** ** ===================================================================
 853:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16Hex (component Utility)
 854:../Generated_Code/UTIL1.c **** **     Description :
 855:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer as hex
 856:../Generated_Code/UTIL1.c **** **         number (without a 0x prefix).
 857:../Generated_Code/UTIL1.c **** **     Parameters  :
 858:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 859:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 860:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 861:../Generated_Code/UTIL1.c **** **                           bytes).
 862:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 863:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 864:../Generated_Code/UTIL1.c **** ** ===================================================================
 865:../Generated_Code/UTIL1.c **** */
 866:../Generated_Code/UTIL1.c **** /*!
 867:../Generated_Code/UTIL1.c ****   \brief Adds a 16bit number as hex value to a string.
 868:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 869:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 870:../Generated_Code/UTIL1.c ****   \param[in] num The 16bit number to add
 871:../Generated_Code/UTIL1.c ****   */
 872:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16Hex(uint8_t *dst, size_t dstSize, uint16_t num)
 873:../Generated_Code/UTIL1.c **** {
 1766              		.loc 1 873 0
 1767              		.cfi_startproc
 1768 0000 80B5     		push	{r7, lr}
 1769              	.LCFI63:
 1770              		.cfi_def_cfa_offset 8
 1771              		.cfi_offset 7, -8
 1772              		.cfi_offset 14, -4
 1773 0002 86B0     		sub	sp, sp, #24
 1774              	.LCFI64:
 1775              		.cfi_def_cfa_offset 32
 1776 0004 00AF     		add	r7, sp, #0
 1777              	.LCFI65:
 1778              		.cfi_def_cfa_register 7
 1779 0006 F860     		str	r0, [r7, #12]
 1780 0008 B960     		str	r1, [r7, #8]
 1781 000a BB1D     		add	r3, r7, #6
 1782 000c 1A80     		strh	r2, [r3]
 874:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFF")]; /* maximum buffer size we need */
 875:../Generated_Code/UTIL1.c ****   unsigned char hex;
 876:../Generated_Code/UTIL1.c ****   int8_t i;
 877:../Generated_Code/UTIL1.c **** 
 878:../Generated_Code/UTIL1.c ****   buf[4] = '\0';
 1783              		.loc 1 878 0
 1784 000e 3B1C     		mov	r3, r7
 1785 0010 1033     		add	r3, r3, #16
 1786 0012 0022     		mov	r2, #0
 1787 0014 1A71     		strb	r2, [r3, #4]
 879:../Generated_Code/UTIL1.c ****   i = 3;
 1788              		.loc 1 879 0
 1789 0016 3B1C     		mov	r3, r7
 1790 0018 1733     		add	r3, r3, #23
 1791 001a 0322     		mov	r2, #3
 1792 001c 1A70     		strb	r2, [r3]
 1793              	.L67:
 880:../Generated_Code/UTIL1.c ****   do {
 881:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1794              		.loc 1 881 0
 1795 001e BB1D     		add	r3, r7, #6
 1796 0020 1B88     		ldrh	r3, [r3]
 1797 0022 D9B2     		uxtb	r1, r3
 1798 0024 3B1C     		mov	r3, r7
 1799 0026 1633     		add	r3, r3, #22
 1800 0028 0F22     		mov	r2, #15
 1801 002a 0A40     		and	r2, r1
 1802 002c 1A70     		strb	r2, [r3]
 882:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1803              		.loc 1 882 0
 1804 002e 3B1C     		mov	r3, r7
 1805 0030 1733     		add	r3, r3, #23
 1806 0032 0022     		mov	r2, #0
 1807 0034 9A56     		ldrsb	r2, [r3, r2]
 1808 0036 3B1C     		mov	r3, r7
 1809 0038 1633     		add	r3, r3, #22
 1810 003a 1B78     		ldrb	r3, [r3]
 1811 003c 092B     		cmp	r3, #9
 1812 003e 01D8     		bhi	.L65
 1813              		.loc 1 882 0 is_stmt 0
 1814 0040 3023     		mov	r3, #48
 1815 0042 00E0     		b	.L66
 1816              	.L65:
 1817              		.loc 1 882 0
 1818 0044 3723     		mov	r3, #55
 1819              	.L66:
 1820              		.loc 1 882 0
 1821 0046 391C     		mov	r1, r7
 1822 0048 1631     		add	r1, r1, #22
 1823 004a 0978     		ldrb	r1, [r1]
 1824 004c 5B18     		add	r3, r3, r1
 1825 004e D9B2     		uxtb	r1, r3
 1826 0050 3B1C     		mov	r3, r7
 1827 0052 1033     		add	r3, r3, #16
 1828 0054 9954     		strb	r1, [r3, r2]
 883:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1829              		.loc 1 883 0 is_stmt 1
 1830 0056 BB1D     		add	r3, r7, #6
 1831 0058 BA1D     		add	r2, r7, #6
 1832 005a 1288     		ldrh	r2, [r2]
 1833 005c 1209     		lsr	r2, r2, #4
 1834 005e 1A80     		strh	r2, [r3]
 884:../Generated_Code/UTIL1.c ****     i--;
 1835              		.loc 1 884 0
 1836 0060 3B1C     		mov	r3, r7
 1837 0062 1733     		add	r3, r3, #23
 1838 0064 3A1C     		mov	r2, r7
 1839 0066 1732     		add	r2, r2, #23
 1840 0068 1278     		ldrb	r2, [r2]
 1841 006a 013A     		sub	r2, r2, #1
 1842 006c 1A70     		strb	r2, [r3]
 885:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1843              		.loc 1 885 0
 1844 006e 3B1C     		mov	r3, r7
 1845 0070 1733     		add	r3, r3, #23
 1846 0072 1B78     		ldrb	r3, [r3]
 1847 0074 7F2B     		cmp	r3, #127
 1848 0076 D2D9     		bls	.L67
 886:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1849              		.loc 1 886 0
 1850 0078 F968     		ldr	r1, [r7, #12]
 1851 007a BA68     		ldr	r2, [r7, #8]
 1852 007c 3B1C     		mov	r3, r7
 1853 007e 1033     		add	r3, r3, #16
 1854 0080 081C     		mov	r0, r1
 1855 0082 111C     		mov	r1, r2
 1856 0084 1A1C     		mov	r2, r3
 1857 0086 FFF7FEFF 		bl	UTIL1_strcat
 887:../Generated_Code/UTIL1.c **** }
 1858              		.loc 1 887 0
 1859 008a BD46     		mov	sp, r7
 1860 008c 06B0     		add	sp, sp, #24
 1861              		@ sp needed for prologue
 1862 008e 80BD     		pop	{r7, pc}
 1863              		.cfi_endproc
 1864              	.LFE21:
 1866              		.section	.text.UTIL1_strcatNum24Hex,"ax",%progbits
 1867              		.align	2
 1868              		.global	UTIL1_strcatNum24Hex
 1869              		.code	16
 1870              		.thumb_func
 1872              	UTIL1_strcatNum24Hex:
 1873              	.LFB22:
 888:../Generated_Code/UTIL1.c **** 
 889:../Generated_Code/UTIL1.c **** /*
 890:../Generated_Code/UTIL1.c **** ** ===================================================================
 891:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum24Hex (component Utility)
 892:../Generated_Code/UTIL1.c **** **     Description :
 893:../Generated_Code/UTIL1.c **** **         Appends a 32bit unsigned value to a string buffer as hex
 894:../Generated_Code/UTIL1.c **** **         number (without a 0x prefix). Only 24bits are used.
 895:../Generated_Code/UTIL1.c **** **     Parameters  :
 896:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 897:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 898:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 899:../Generated_Code/UTIL1.c **** **                           bytes).
 900:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 901:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 902:../Generated_Code/UTIL1.c **** ** ===================================================================
 903:../Generated_Code/UTIL1.c **** */
 904:../Generated_Code/UTIL1.c **** /*!
 905:../Generated_Code/UTIL1.c ****   \brief Adds a 24bit number as hex value to a string.
 906:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 907:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 908:../Generated_Code/UTIL1.c ****   \param[in] num The 24bit number to add
 909:../Generated_Code/UTIL1.c ****   */
 910:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum24Hex(uint8_t *dst, size_t dstSize, uint32_t num)
 911:../Generated_Code/UTIL1.c **** {
 1874              		.loc 1 911 0
 1875              		.cfi_startproc
 1876 0000 80B5     		push	{r7, lr}
 1877              	.LCFI66:
 1878              		.cfi_def_cfa_offset 8
 1879              		.cfi_offset 7, -8
 1880              		.cfi_offset 14, -4
 1881 0002 88B0     		sub	sp, sp, #32
 1882              	.LCFI67:
 1883              		.cfi_def_cfa_offset 40
 1884 0004 00AF     		add	r7, sp, #0
 1885              	.LCFI68:
 1886              		.cfi_def_cfa_register 7
 1887 0006 F860     		str	r0, [r7, #12]
 1888 0008 B960     		str	r1, [r7, #8]
 1889 000a 7A60     		str	r2, [r7, #4]
 912:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFFFF")]; /* maximum buffer size we need */
 913:../Generated_Code/UTIL1.c ****   unsigned char hex;
 914:../Generated_Code/UTIL1.c ****   int8_t i;
 915:../Generated_Code/UTIL1.c **** 
 916:../Generated_Code/UTIL1.c ****   buf[6] = '\0';
 1890              		.loc 1 916 0
 1891 000c 3B1C     		mov	r3, r7
 1892 000e 1433     		add	r3, r3, #20
 1893 0010 0022     		mov	r2, #0
 1894 0012 9A71     		strb	r2, [r3, #6]
 917:../Generated_Code/UTIL1.c ****   i = 5;
 1895              		.loc 1 917 0
 1896 0014 3B1C     		mov	r3, r7
 1897 0016 1F33     		add	r3, r3, #31
 1898 0018 0522     		mov	r2, #5
 1899 001a 1A70     		strb	r2, [r3]
 1900              	.L71:
 918:../Generated_Code/UTIL1.c ****   do {
 919:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1901              		.loc 1 919 0
 1902 001c 7B68     		ldr	r3, [r7, #4]
 1903 001e D9B2     		uxtb	r1, r3
 1904 0020 3B1C     		mov	r3, r7
 1905 0022 1E33     		add	r3, r3, #30
 1906 0024 0F22     		mov	r2, #15
 1907 0026 0A40     		and	r2, r1
 1908 0028 1A70     		strb	r2, [r3]
 920:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1909              		.loc 1 920 0
 1910 002a 3B1C     		mov	r3, r7
 1911 002c 1F33     		add	r3, r3, #31
 1912 002e 0022     		mov	r2, #0
 1913 0030 9A56     		ldrsb	r2, [r3, r2]
 1914 0032 3B1C     		mov	r3, r7
 1915 0034 1E33     		add	r3, r3, #30
 1916 0036 1B78     		ldrb	r3, [r3]
 1917 0038 092B     		cmp	r3, #9
 1918 003a 01D8     		bhi	.L69
 1919              		.loc 1 920 0 is_stmt 0
 1920 003c 3023     		mov	r3, #48
 1921 003e 00E0     		b	.L70
 1922              	.L69:
 1923              		.loc 1 920 0
 1924 0040 3723     		mov	r3, #55
 1925              	.L70:
 1926              		.loc 1 920 0
 1927 0042 391C     		mov	r1, r7
 1928 0044 1E31     		add	r1, r1, #30
 1929 0046 0978     		ldrb	r1, [r1]
 1930 0048 5B18     		add	r3, r3, r1
 1931 004a D9B2     		uxtb	r1, r3
 1932 004c 3B1C     		mov	r3, r7
 1933 004e 1433     		add	r3, r3, #20
 1934 0050 9954     		strb	r1, [r3, r2]
 921:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1935              		.loc 1 921 0 is_stmt 1
 1936 0052 7B68     		ldr	r3, [r7, #4]
 1937 0054 1B09     		lsr	r3, r3, #4
 1938 0056 7B60     		str	r3, [r7, #4]
 922:../Generated_Code/UTIL1.c ****     i--;
 1939              		.loc 1 922 0
 1940 0058 3B1C     		mov	r3, r7
 1941 005a 1F33     		add	r3, r3, #31
 1942 005c 3A1C     		mov	r2, r7
 1943 005e 1F32     		add	r2, r2, #31
 1944 0060 1278     		ldrb	r2, [r2]
 1945 0062 013A     		sub	r2, r2, #1
 1946 0064 1A70     		strb	r2, [r3]
 923:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1947              		.loc 1 923 0
 1948 0066 3B1C     		mov	r3, r7
 1949 0068 1F33     		add	r3, r3, #31
 1950 006a 1B78     		ldrb	r3, [r3]
 1951 006c 7F2B     		cmp	r3, #127
 1952 006e D5D9     		bls	.L71
 924:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1953              		.loc 1 924 0
 1954 0070 F968     		ldr	r1, [r7, #12]
 1955 0072 BA68     		ldr	r2, [r7, #8]
 1956 0074 3B1C     		mov	r3, r7
 1957 0076 1433     		add	r3, r3, #20
 1958 0078 081C     		mov	r0, r1
 1959 007a 111C     		mov	r1, r2
 1960 007c 1A1C     		mov	r2, r3
 1961 007e FFF7FEFF 		bl	UTIL1_strcat
 925:../Generated_Code/UTIL1.c **** }
 1962              		.loc 1 925 0
 1963 0082 BD46     		mov	sp, r7
 1964 0084 08B0     		add	sp, sp, #32
 1965              		@ sp needed for prologue
 1966 0086 80BD     		pop	{r7, pc}
 1967              		.cfi_endproc
 1968              	.LFE22:
 1970              		.section	.text.UTIL1_strcatNum32Hex,"ax",%progbits
 1971              		.align	2
 1972              		.global	UTIL1_strcatNum32Hex
 1973              		.code	16
 1974              		.thumb_func
 1976              	UTIL1_strcatNum32Hex:
 1977              	.LFB23:
 926:../Generated_Code/UTIL1.c **** 
 927:../Generated_Code/UTIL1.c **** /*
 928:../Generated_Code/UTIL1.c **** ** ===================================================================
 929:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32Hex (component Utility)
 930:../Generated_Code/UTIL1.c **** **     Description :
 931:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer as hex
 932:../Generated_Code/UTIL1.c **** **         number (without a 0x prefix).
 933:../Generated_Code/UTIL1.c **** **     Parameters  :
 934:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 935:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 936:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 937:../Generated_Code/UTIL1.c **** **                           bytes).
 938:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 939:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 940:../Generated_Code/UTIL1.c **** ** ===================================================================
 941:../Generated_Code/UTIL1.c **** */
 942:../Generated_Code/UTIL1.c **** /*!
 943:../Generated_Code/UTIL1.c ****   \brief Adds a 32bit number as hex value to a string.
 944:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 945:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 946:../Generated_Code/UTIL1.c ****   \param[in] num The 32bit number to add
 947:../Generated_Code/UTIL1.c ****   */
 948:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32Hex(uint8_t *dst, size_t dstSize, uint32_t num)
 949:../Generated_Code/UTIL1.c **** {
 1978              		.loc 1 949 0
 1979              		.cfi_startproc
 1980 0000 80B5     		push	{r7, lr}
 1981              	.LCFI69:
 1982              		.cfi_def_cfa_offset 8
 1983              		.cfi_offset 7, -8
 1984              		.cfi_offset 14, -4
 1985 0002 88B0     		sub	sp, sp, #32
 1986              	.LCFI70:
 1987              		.cfi_def_cfa_offset 40
 1988 0004 00AF     		add	r7, sp, #0
 1989              	.LCFI71:
 1990              		.cfi_def_cfa_register 7
 1991 0006 F860     		str	r0, [r7, #12]
 1992 0008 B960     		str	r1, [r7, #8]
 1993 000a 7A60     		str	r2, [r7, #4]
 950:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFFFFFF")]; /* maximum buffer size we need */
 951:../Generated_Code/UTIL1.c ****   unsigned char hex;
 952:../Generated_Code/UTIL1.c ****   int8_t i;
 953:../Generated_Code/UTIL1.c **** 
 954:../Generated_Code/UTIL1.c ****   buf[8] = '\0';
 1994              		.loc 1 954 0
 1995 000c 3B1C     		mov	r3, r7
 1996 000e 1433     		add	r3, r3, #20
 1997 0010 0022     		mov	r2, #0
 1998 0012 1A72     		strb	r2, [r3, #8]
 955:../Generated_Code/UTIL1.c ****   i = 7;
 1999              		.loc 1 955 0
 2000 0014 3B1C     		mov	r3, r7
 2001 0016 1F33     		add	r3, r3, #31
 2002 0018 0722     		mov	r2, #7
 2003 001a 1A70     		strb	r2, [r3]
 2004              	.L75:
 956:../Generated_Code/UTIL1.c ****   do {
 957:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 2005              		.loc 1 957 0
 2006 001c 7B68     		ldr	r3, [r7, #4]
 2007 001e D9B2     		uxtb	r1, r3
 2008 0020 3B1C     		mov	r3, r7
 2009 0022 1E33     		add	r3, r3, #30
 2010 0024 0F22     		mov	r2, #15
 2011 0026 0A40     		and	r2, r1
 2012 0028 1A70     		strb	r2, [r3]
 958:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 2013              		.loc 1 958 0
 2014 002a 3B1C     		mov	r3, r7
 2015 002c 1F33     		add	r3, r3, #31
 2016 002e 0022     		mov	r2, #0
 2017 0030 9A56     		ldrsb	r2, [r3, r2]
 2018 0032 3B1C     		mov	r3, r7
 2019 0034 1E33     		add	r3, r3, #30
 2020 0036 1B78     		ldrb	r3, [r3]
 2021 0038 092B     		cmp	r3, #9
 2022 003a 01D8     		bhi	.L73
 2023              		.loc 1 958 0 is_stmt 0
 2024 003c 3023     		mov	r3, #48
 2025 003e 00E0     		b	.L74
 2026              	.L73:
 2027              		.loc 1 958 0
 2028 0040 3723     		mov	r3, #55
 2029              	.L74:
 2030              		.loc 1 958 0
 2031 0042 391C     		mov	r1, r7
 2032 0044 1E31     		add	r1, r1, #30
 2033 0046 0978     		ldrb	r1, [r1]
 2034 0048 5B18     		add	r3, r3, r1
 2035 004a D9B2     		uxtb	r1, r3
 2036 004c 3B1C     		mov	r3, r7
 2037 004e 1433     		add	r3, r3, #20
 2038 0050 9954     		strb	r1, [r3, r2]
 959:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 2039              		.loc 1 959 0 is_stmt 1
 2040 0052 7B68     		ldr	r3, [r7, #4]
 2041 0054 1B09     		lsr	r3, r3, #4
 2042 0056 7B60     		str	r3, [r7, #4]
 960:../Generated_Code/UTIL1.c ****     i--;
 2043              		.loc 1 960 0
 2044 0058 3B1C     		mov	r3, r7
 2045 005a 1F33     		add	r3, r3, #31
 2046 005c 3A1C     		mov	r2, r7
 2047 005e 1F32     		add	r2, r2, #31
 2048 0060 1278     		ldrb	r2, [r2]
 2049 0062 013A     		sub	r2, r2, #1
 2050 0064 1A70     		strb	r2, [r3]
 961:../Generated_Code/UTIL1.c ****   } while (i>=0);
 2051              		.loc 1 961 0
 2052 0066 3B1C     		mov	r3, r7
 2053 0068 1F33     		add	r3, r3, #31
 2054 006a 1B78     		ldrb	r3, [r3]
 2055 006c 7F2B     		cmp	r3, #127
 2056 006e D5D9     		bls	.L75
 962:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 2057              		.loc 1 962 0
 2058 0070 F968     		ldr	r1, [r7, #12]
 2059 0072 BA68     		ldr	r2, [r7, #8]
 2060 0074 3B1C     		mov	r3, r7
 2061 0076 1433     		add	r3, r3, #20
 2062 0078 081C     		mov	r0, r1
 2063 007a 111C     		mov	r1, r2
 2064 007c 1A1C     		mov	r2, r3
 2065 007e FFF7FEFF 		bl	UTIL1_strcat
 963:../Generated_Code/UTIL1.c **** }
 2066              		.loc 1 963 0
 2067 0082 BD46     		mov	sp, r7
 2068 0084 08B0     		add	sp, sp, #32
 2069              		@ sp needed for prologue
 2070 0086 80BD     		pop	{r7, pc}
 2071              		.cfi_endproc
 2072              	.LFE23:
 2074              		.section	.text.UTIL1_strcatNum32s,"ax",%progbits
 2075              		.align	2
 2076              		.global	UTIL1_strcatNum32s
 2077              		.code	16
 2078              		.thumb_func
 2080              	UTIL1_strcatNum32s:
 2081              	.LFB24:
 964:../Generated_Code/UTIL1.c **** 
 965:../Generated_Code/UTIL1.c **** /*
 966:../Generated_Code/UTIL1.c **** ** ===================================================================
 967:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32s (component Utility)
 968:../Generated_Code/UTIL1.c **** **     Description :
 969:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer.
 970:../Generated_Code/UTIL1.c **** **     Parameters  :
 971:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 972:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 973:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 974:../Generated_Code/UTIL1.c **** **                           bytes).
 975:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 976:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 977:../Generated_Code/UTIL1.c **** ** ===================================================================
 978:../Generated_Code/UTIL1.c **** */
 979:../Generated_Code/UTIL1.c **** /*!
 980:../Generated_Code/UTIL1.c ****   \brief appends a 32bit (long) number to a string. Always terminates the result string.
 981:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 982:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 983:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
 984:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 985:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit number to add
 986:../Generated_Code/UTIL1.c ****   */
 987:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32s(uint8_t *dst, size_t dstSize, int32_t val)
 988:../Generated_Code/UTIL1.c **** {
 2082              		.loc 1 988 0
 2083              		.cfi_startproc
 2084 0000 80B5     		push	{r7, lr}
 2085              	.LCFI72:
 2086              		.cfi_def_cfa_offset 8
 2087              		.cfi_offset 7, -8
 2088              		.cfi_offset 14, -4
 2089 0002 88B0     		sub	sp, sp, #32
 2090              	.LCFI73:
 2091              		.cfi_def_cfa_offset 40
 2092 0004 00AF     		add	r7, sp, #0
 2093              	.LCFI74:
 2094              		.cfi_def_cfa_register 7
 2095 0006 F860     		str	r0, [r7, #12]
 2096 0008 B960     		str	r1, [r7, #8]
 2097 000a 7A60     		str	r2, [r7, #4]
 989:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 990:../Generated_Code/UTIL1.c **** 
 991:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(buf, sizeof(buf), val);
 2098              		.loc 1 991 0
 2099 000c 3A1C     		mov	r2, r7
 2100 000e 1432     		add	r2, r2, #20
 2101 0010 7B68     		ldr	r3, [r7, #4]
 2102 0012 101C     		mov	r0, r2
 2103 0014 0C21     		mov	r1, #12
 2104 0016 1A1C     		mov	r2, r3
 2105 0018 FFF7FEFF 		bl	UTIL1_Num32sToStr
 992:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 2106              		.loc 1 992 0
 2107 001c F968     		ldr	r1, [r7, #12]
 2108 001e BA68     		ldr	r2, [r7, #8]
 2109 0020 3B1C     		mov	r3, r7
 2110 0022 1433     		add	r3, r3, #20
 2111 0024 081C     		mov	r0, r1
 2112 0026 111C     		mov	r1, r2
 2113 0028 1A1C     		mov	r2, r3
 2114 002a FFF7FEFF 		bl	UTIL1_strcat
 993:../Generated_Code/UTIL1.c **** }
 2115              		.loc 1 993 0
 2116 002e BD46     		mov	sp, r7
 2117 0030 08B0     		add	sp, sp, #32
 2118              		@ sp needed for prologue
 2119 0032 80BD     		pop	{r7, pc}
 2120              		.cfi_endproc
 2121              	.LFE24:
 2123              		.section	.text.UTIL1_strcatNum32u,"ax",%progbits
 2124              		.align	2
 2125              		.global	UTIL1_strcatNum32u
 2126              		.code	16
 2127              		.thumb_func
 2129              	UTIL1_strcatNum32u:
 2130              	.LFB25:
 994:../Generated_Code/UTIL1.c **** 
 995:../Generated_Code/UTIL1.c **** /*
 996:../Generated_Code/UTIL1.c **** ** ===================================================================
 997:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32u (component Utility)
 998:../Generated_Code/UTIL1.c **** **     Description :
 999:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer.
1000:../Generated_Code/UTIL1.c **** **     Parameters  :
1001:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1002:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
1003:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
1004:../Generated_Code/UTIL1.c **** **                           bytes).
1005:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
1006:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
1007:../Generated_Code/UTIL1.c **** ** ===================================================================
1008:../Generated_Code/UTIL1.c **** */
1009:../Generated_Code/UTIL1.c **** /*!
1010:../Generated_Code/UTIL1.c ****   \brief appends a 32bit (unsigned long) number to a string. Always terminates the result string.
1011:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
1012:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
1013:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of string buffer, where to append the number string
1014:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
1015:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
1016:../Generated_Code/UTIL1.c ****   */
1017:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32u(uint8_t *dst, size_t dstSize, uint32_t val)
1018:../Generated_Code/UTIL1.c **** {
 2131              		.loc 1 1018 0
 2132              		.cfi_startproc
 2133 0000 80B5     		push	{r7, lr}
 2134              	.LCFI75:
 2135              		.cfi_def_cfa_offset 8
 2136              		.cfi_offset 7, -8
 2137              		.cfi_offset 14, -4
 2138 0002 88B0     		sub	sp, sp, #32
 2139              	.LCFI76:
 2140              		.cfi_def_cfa_offset 40
 2141 0004 00AF     		add	r7, sp, #0
 2142              	.LCFI77:
 2143              		.cfi_def_cfa_register 7
 2144 0006 F860     		str	r0, [r7, #12]
 2145 0008 B960     		str	r1, [r7, #8]
 2146 000a 7A60     		str	r2, [r7, #4]
1019:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
1020:../Generated_Code/UTIL1.c **** 
1021:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(buf, sizeof(buf), val);
 2147              		.loc 1 1021 0
 2148 000c 3A1C     		mov	r2, r7
 2149 000e 1432     		add	r2, r2, #20
 2150 0010 7B68     		ldr	r3, [r7, #4]
 2151 0012 101C     		mov	r0, r2
 2152 0014 0B21     		mov	r1, #11
 2153 0016 1A1C     		mov	r2, r3
 2154 0018 FFF7FEFF 		bl	UTIL1_Num32uToStr
1022:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 2155              		.loc 1 1022 0
 2156 001c F968     		ldr	r1, [r7, #12]
 2157 001e BA68     		ldr	r2, [r7, #8]
 2158 0020 3B1C     		mov	r3, r7
 2159 0022 1433     		add	r3, r3, #20
 2160 0024 081C     		mov	r0, r1
 2161 0026 111C     		mov	r1, r2
 2162 0028 1A1C     		mov	r2, r3
 2163 002a FFF7FEFF 		bl	UTIL1_strcat
1023:../Generated_Code/UTIL1.c **** }
 2164              		.loc 1 1023 0
 2165 002e BD46     		mov	sp, r7
 2166 0030 08B0     		add	sp, sp, #32
 2167              		@ sp needed for prologue
 2168 0032 80BD     		pop	{r7, pc}
 2169              		.cfi_endproc
 2170              	.LFE25:
 2172              		.section	.rodata
 2173 0007 00       		.align	2
 2174              	.LC2:
 2175 0008 2D323134 		.ascii	"-2147483648\000"
 2175      37343833 
 2175      36343800 
 2176              		.section	.text.UTIL1_Num32sToStr,"ax",%progbits
 2177              		.align	2
 2178              		.global	UTIL1_Num32sToStr
 2179              		.code	16
 2180              		.thumb_func
 2182              	UTIL1_Num32sToStr:
 2183              	.LFB26:
1024:../Generated_Code/UTIL1.c **** 
1025:../Generated_Code/UTIL1.c **** /*
1026:../Generated_Code/UTIL1.c **** ** ===================================================================
1027:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32sToStr (component Utility)
1028:../Generated_Code/UTIL1.c **** **     Description :
1029:../Generated_Code/UTIL1.c **** **         Converts a signed 32bit value into a string.
1030:../Generated_Code/UTIL1.c **** **     Parameters  :
1031:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1032:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
1033:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
1034:../Generated_Code/UTIL1.c **** **                           bytes).
1035:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
1036:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
1037:../Generated_Code/UTIL1.c **** ** ===================================================================
1038:../Generated_Code/UTIL1.c **** */
1039:../Generated_Code/UTIL1.c **** /*!
1040:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit number to a string.
1041:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
1042:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in uint8_ts.
1043:../Generated_Code/UTIL1.c ****   \param[in] val 32bit signed number to convert.
1044:../Generated_Code/UTIL1.c ****  */
1045:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStr(uint8_t *dst, size_t dstSize, int32_t val)
1046:../Generated_Code/UTIL1.c **** {
 2184              		.loc 1 1046 0
 2185              		.cfi_startproc
 2186 0000 90B5     		push	{r4, r7, lr}
 2187              	.LCFI78:
 2188              		.cfi_def_cfa_offset 12
 2189              		.cfi_offset 4, -12
 2190              		.cfi_offset 7, -8
 2191              		.cfi_offset 14, -4
 2192 0002 89B0     		sub	sp, sp, #36
 2193              	.LCFI79:
 2194              		.cfi_def_cfa_offset 48
 2195 0004 00AF     		add	r7, sp, #0
 2196              	.LCFI80:
 2197              		.cfi_def_cfa_register 7
 2198 0006 F860     		str	r0, [r7, #12]
 2199 0008 B960     		str	r1, [r7, #8]
 2200 000a 7A60     		str	r2, [r7, #4]
1047:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
 2201              		.loc 1 1047 0
 2202 000c FB68     		ldr	r3, [r7, #12]
 2203 000e BB61     		str	r3, [r7, #24]
1048:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 2204              		.loc 1 1048 0
 2205 0010 3B1C     		mov	r3, r7
 2206 0012 1F33     		add	r3, r3, #31
 2207 0014 0022     		mov	r2, #0
 2208 0016 1A70     		strb	r2, [r3]
1049:../Generated_Code/UTIL1.c ****   unsigned char tmp;
1050:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 2209              		.loc 1 1050 0
 2210 0018 7B68     		ldr	r3, [r7, #4]
 2211 001a DB0F     		lsr	r3, r3, #31
 2212 001c DAB2     		uxtb	r2, r3
 2213 001e 3B1C     		mov	r3, r7
 2214 0020 1733     		add	r3, r3, #23
 2215 0022 1A70     		strb	r2, [r3]
1051:../Generated_Code/UTIL1.c **** 
1052:../Generated_Code/UTIL1.c ****   if (val==(int32_t)(0x80000000)) { /* special case 0x80000000/-2147483648: prevent overflow below.
 2216              		.loc 1 1052 0
 2217 0024 7A68     		ldr	r2, [r7, #4]
 2218 0026 8023     		mov	r3, #128
 2219 0028 1B06     		lsl	r3, r3, #24
 2220 002a 9A42     		cmp	r2, r3
 2221 002c 08D1     		bne	.L79
1053:../Generated_Code/UTIL1.c ****     UTIL1_strcpy(dst, dstSize, (unsigned char*)"-2147483648");
 2222              		.loc 1 1053 0
 2223 002e F968     		ldr	r1, [r7, #12]
 2224 0030 BA68     		ldr	r2, [r7, #8]
 2225 0032 574B     		ldr	r3, .L89
 2226 0034 081C     		mov	r0, r1
 2227 0036 111C     		mov	r1, r2
 2228 0038 1A1C     		mov	r2, r3
 2229 003a FFF7FEFF 		bl	UTIL1_strcpy
1054:../Generated_Code/UTIL1.c ****     return;
 2230              		.loc 1 1054 0
 2231 003e A3E0     		b	.L78
 2232              	.L79:
1055:../Generated_Code/UTIL1.c ****   }
1056:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 2233              		.loc 1 1056 0
 2234 0040 BB68     		ldr	r3, [r7, #8]
 2235 0042 013B     		sub	r3, r3, #1
 2236 0044 BB60     		str	r3, [r7, #8]
1057:../Generated_Code/UTIL1.c ****   if (sign) {
 2237              		.loc 1 1057 0
 2238 0046 3B1C     		mov	r3, r7
 2239 0048 1733     		add	r3, r3, #23
 2240 004a 1B78     		ldrb	r3, [r3]
 2241 004c 002B     		cmp	r3, #0
 2242 004e 02D0     		beq	.L81
1058:../Generated_Code/UTIL1.c ****     val = -val;
 2243              		.loc 1 1058 0
 2244 0050 7B68     		ldr	r3, [r7, #4]
 2245 0052 5B42     		neg	r3, r3
 2246 0054 7B60     		str	r3, [r7, #4]
 2247              	.L81:
1059:../Generated_Code/UTIL1.c ****   }
1060:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 2248              		.loc 1 1060 0
 2249 0056 7B68     		ldr	r3, [r7, #4]
 2250 0058 002B     		cmp	r3, #0
 2251 005a 34D1     		bne	.L83
 2252              		.loc 1 1060 0 is_stmt 0
 2253 005c BB68     		ldr	r3, [r7, #8]
 2254 005e 002B     		cmp	r3, #0
 2255 0060 31D0     		beq	.L83
1061:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 2256              		.loc 1 1061 0 is_stmt 1
 2257 0062 3B1C     		mov	r3, r7
 2258 0064 1F33     		add	r3, r3, #31
 2259 0066 1B78     		ldrb	r3, [r3]
 2260 0068 BA69     		ldr	r2, [r7, #24]
 2261 006a D318     		add	r3, r2, r3
 2262 006c 3022     		mov	r2, #48
 2263 006e 1A70     		strb	r2, [r3]
 2264 0070 3B1C     		mov	r3, r7
 2265 0072 1F33     		add	r3, r3, #31
 2266 0074 3A1C     		mov	r2, r7
 2267 0076 1F32     		add	r2, r2, #31
 2268 0078 1278     		ldrb	r2, [r2]
 2269 007a 0132     		add	r2, r2, #1
 2270 007c 1A70     		strb	r2, [r3]
1062:../Generated_Code/UTIL1.c ****     dstSize--;
 2271              		.loc 1 1062 0
 2272 007e BB68     		ldr	r3, [r7, #8]
 2273 0080 013B     		sub	r3, r3, #1
 2274 0082 BB60     		str	r3, [r7, #8]
1063:../Generated_Code/UTIL1.c ****   }
1064:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2275              		.loc 1 1064 0
 2276 0084 1FE0     		b	.L83
 2277              	.L85:
1065:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 2278              		.loc 1 1065 0
 2279 0086 3B1C     		mov	r3, r7
 2280 0088 1F33     		add	r3, r3, #31
 2281 008a 1B78     		ldrb	r3, [r3]
 2282 008c BA69     		ldr	r2, [r7, #24]
 2283 008e D418     		add	r4, r2, r3
 2284 0090 7B68     		ldr	r3, [r7, #4]
 2285 0092 181C     		mov	r0, r3
 2286 0094 0A21     		mov	r1, #10
 2287 0096 FFF7FEFF 		bl	__aeabi_idivmod
 2288 009a 0B1C     		mov	r3, r1
 2289 009c DBB2     		uxtb	r3, r3
 2290 009e 3033     		add	r3, r3, #48
 2291 00a0 DBB2     		uxtb	r3, r3
 2292 00a2 2370     		strb	r3, [r4]
 2293 00a4 3B1C     		mov	r3, r7
 2294 00a6 1F33     		add	r3, r3, #31
 2295 00a8 3A1C     		mov	r2, r7
 2296 00aa 1F32     		add	r2, r2, #31
 2297 00ac 1278     		ldrb	r2, [r2]
 2298 00ae 0132     		add	r2, r2, #1
 2299 00b0 1A70     		strb	r2, [r3]
1066:../Generated_Code/UTIL1.c ****     dstSize--;
 2300              		.loc 1 1066 0
 2301 00b2 BB68     		ldr	r3, [r7, #8]
 2302 00b4 013B     		sub	r3, r3, #1
 2303 00b6 BB60     		str	r3, [r7, #8]
1067:../Generated_Code/UTIL1.c ****     val /= 10;
 2304              		.loc 1 1067 0
 2305 00b8 7B68     		ldr	r3, [r7, #4]
 2306 00ba 181C     		mov	r0, r3
 2307 00bc 0A21     		mov	r1, #10
 2308 00be FFF7FEFF 		bl	__aeabi_idiv
 2309 00c2 031C     		mov	r3, r0
 2310 00c4 7B60     		str	r3, [r7, #4]
 2311              	.L83:
1064:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2312              		.loc 1 1064 0
 2313 00c6 7B68     		ldr	r3, [r7, #4]
 2314 00c8 002B     		cmp	r3, #0
 2315 00ca 02DD     		ble	.L84
1064:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2316              		.loc 1 1064 0 is_stmt 0
 2317 00cc BB68     		ldr	r3, [r7, #8]
 2318 00ce 002B     		cmp	r3, #0
 2319 00d0 D9D1     		bne	.L85
 2320              	.L84:
1068:../Generated_Code/UTIL1.c ****   }
1069:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 2321              		.loc 1 1069 0 is_stmt 1
 2322 00d2 3B1C     		mov	r3, r7
 2323 00d4 1733     		add	r3, r3, #23
 2324 00d6 1B78     		ldrb	r3, [r3]
 2325 00d8 002B     		cmp	r3, #0
 2326 00da 10D0     		beq	.L86
 2327              		.loc 1 1069 0 is_stmt 0
 2328 00dc BB68     		ldr	r3, [r7, #8]
 2329 00de 002B     		cmp	r3, #0
 2330 00e0 0DD0     		beq	.L86
1070:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 2331              		.loc 1 1070 0 is_stmt 1
 2332 00e2 3B1C     		mov	r3, r7
 2333 00e4 1F33     		add	r3, r3, #31
 2334 00e6 1B78     		ldrb	r3, [r3]
 2335 00e8 BA69     		ldr	r2, [r7, #24]
 2336 00ea D318     		add	r3, r2, r3
 2337 00ec 2D22     		mov	r2, #45
 2338 00ee 1A70     		strb	r2, [r3]
 2339 00f0 3B1C     		mov	r3, r7
 2340 00f2 1F33     		add	r3, r3, #31
 2341 00f4 3A1C     		mov	r2, r7
 2342 00f6 1F32     		add	r2, r2, #31
 2343 00f8 1278     		ldrb	r2, [r2]
 2344 00fa 0132     		add	r2, r2, #1
 2345 00fc 1A70     		strb	r2, [r3]
 2346              	.L86:
1071:../Generated_Code/UTIL1.c ****   }
1072:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2347              		.loc 1 1072 0
 2348 00fe 3B1C     		mov	r3, r7
 2349 0100 1E33     		add	r3, r3, #30
 2350 0102 0022     		mov	r2, #0
 2351 0104 1A70     		strb	r2, [r3]
 2352 0106 2EE0     		b	.L87
 2353              	.L88:
1073:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 2354              		.loc 1 1073 0
 2355 0108 3B1C     		mov	r3, r7
 2356 010a 1E33     		add	r3, r3, #30
 2357 010c 1B78     		ldrb	r3, [r3]
 2358 010e BA69     		ldr	r2, [r7, #24]
 2359 0110 D218     		add	r2, r2, r3
 2360 0112 3B1C     		mov	r3, r7
 2361 0114 1633     		add	r3, r3, #22
 2362 0116 1278     		ldrb	r2, [r2]
 2363 0118 1A70     		strb	r2, [r3]
1074:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 2364              		.loc 1 1074 0
 2365 011a 3B1C     		mov	r3, r7
 2366 011c 1E33     		add	r3, r3, #30
 2367 011e 1B78     		ldrb	r3, [r3]
 2368 0120 BA69     		ldr	r2, [r7, #24]
 2369 0122 D318     		add	r3, r2, r3
 2370 0124 3A1C     		mov	r2, r7
 2371 0126 1F32     		add	r2, r2, #31
 2372 0128 1178     		ldrb	r1, [r2]
 2373 012a 3A1C     		mov	r2, r7
 2374 012c 1E32     		add	r2, r2, #30
 2375 012e 1278     		ldrb	r2, [r2]
 2376 0130 8A1A     		sub	r2, r1, r2
 2377 0132 013A     		sub	r2, r2, #1
 2378 0134 B969     		ldr	r1, [r7, #24]
 2379 0136 8A18     		add	r2, r1, r2
 2380 0138 1278     		ldrb	r2, [r2]
 2381 013a 1A70     		strb	r2, [r3]
1075:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 2382              		.loc 1 1075 0
 2383 013c 3B1C     		mov	r3, r7
 2384 013e 1F33     		add	r3, r3, #31
 2385 0140 1A78     		ldrb	r2, [r3]
 2386 0142 3B1C     		mov	r3, r7
 2387 0144 1E33     		add	r3, r3, #30
 2388 0146 1B78     		ldrb	r3, [r3]
 2389 0148 D31A     		sub	r3, r2, r3
 2390 014a 013B     		sub	r3, r3, #1
 2391 014c BA69     		ldr	r2, [r7, #24]
 2392 014e D318     		add	r3, r2, r3
 2393 0150 3A1C     		mov	r2, r7
 2394 0152 1632     		add	r2, r2, #22
 2395 0154 1278     		ldrb	r2, [r2]
 2396 0156 1A70     		strb	r2, [r3]
1072:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2397              		.loc 1 1072 0
 2398 0158 3B1C     		mov	r3, r7
 2399 015a 1E33     		add	r3, r3, #30
 2400 015c 3A1C     		mov	r2, r7
 2401 015e 1E32     		add	r2, r2, #30
 2402 0160 1278     		ldrb	r2, [r2]
 2403 0162 0132     		add	r2, r2, #1
 2404 0164 1A70     		strb	r2, [r3]
 2405              	.L87:
1072:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2406              		.loc 1 1072 0 is_stmt 0
 2407 0166 3B1C     		mov	r3, r7
 2408 0168 1F33     		add	r3, r3, #31
 2409 016a 1B78     		ldrb	r3, [r3]
 2410 016c 5B08     		lsr	r3, r3, #1
 2411 016e DBB2     		uxtb	r3, r3
 2412 0170 3A1C     		mov	r2, r7
 2413 0172 1E32     		add	r2, r2, #30
 2414 0174 1278     		ldrb	r2, [r2]
 2415 0176 9A42     		cmp	r2, r3
 2416 0178 C6D3     		bcc	.L88
1076:../Generated_Code/UTIL1.c ****   }
1077:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 2417              		.loc 1 1077 0 is_stmt 1
 2418 017a 3B1C     		mov	r3, r7
 2419 017c 1F33     		add	r3, r3, #31
 2420 017e 1B78     		ldrb	r3, [r3]
 2421 0180 BA69     		ldr	r2, [r7, #24]
 2422 0182 D318     		add	r3, r2, r3
 2423 0184 0022     		mov	r2, #0
 2424 0186 1A70     		strb	r2, [r3]
 2425              	.L78:
1078:../Generated_Code/UTIL1.c **** }
 2426              		.loc 1 1078 0
 2427 0188 BD46     		mov	sp, r7
 2428 018a 09B0     		add	sp, sp, #36
 2429              		@ sp needed for prologue
 2430 018c 90BD     		pop	{r4, r7, pc}
 2431              	.L90:
 2432 018e C046     		.align	2
 2433              	.L89:
 2434 0190 08000000 		.word	.LC2
 2435              		.cfi_endproc
 2436              	.LFE26:
 2438              		.section	.text.UTIL1_Num32uToStr,"ax",%progbits
 2439              		.align	2
 2440              		.global	UTIL1_Num32uToStr
 2441              		.code	16
 2442              		.thumb_func
 2444              	UTIL1_Num32uToStr:
 2445              	.LFB27:
1079:../Generated_Code/UTIL1.c **** 
1080:../Generated_Code/UTIL1.c **** /*
1081:../Generated_Code/UTIL1.c **** ** ===================================================================
1082:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32uToStr (component Utility)
1083:../Generated_Code/UTIL1.c **** **     Description :
1084:../Generated_Code/UTIL1.c **** **         Converts an unsigned 32bit value into a string.
1085:../Generated_Code/UTIL1.c **** **     Parameters  :
1086:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1087:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
1088:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
1089:../Generated_Code/UTIL1.c **** **                           bytes).
1090:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
1091:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
1092:../Generated_Code/UTIL1.c **** ** ===================================================================
1093:../Generated_Code/UTIL1.c **** */
1094:../Generated_Code/UTIL1.c **** /*!
1095:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit signed number to a string.
1096:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
1097:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in uint8_ts.
1098:../Generated_Code/UTIL1.c ****   \param[in] val 32bit unsigned number to convert.
1099:../Generated_Code/UTIL1.c ****  */
1100:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStr(uint8_t *dst, size_t dstSize, uint32_t val)
1101:../Generated_Code/UTIL1.c **** {
 2446              		.loc 1 1101 0
 2447              		.cfi_startproc
 2448 0000 90B5     		push	{r4, r7, lr}
 2449              	.LCFI81:
 2450              		.cfi_def_cfa_offset 12
 2451              		.cfi_offset 4, -12
 2452              		.cfi_offset 7, -8
 2453              		.cfi_offset 14, -4
 2454 0002 89B0     		sub	sp, sp, #36
 2455              	.LCFI82:
 2456              		.cfi_def_cfa_offset 48
 2457 0004 00AF     		add	r7, sp, #0
 2458              	.LCFI83:
 2459              		.cfi_def_cfa_register 7
 2460 0006 F860     		str	r0, [r7, #12]
 2461 0008 B960     		str	r1, [r7, #8]
 2462 000a 7A60     		str	r2, [r7, #4]
1102:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
 2463              		.loc 1 1102 0
 2464 000c FB68     		ldr	r3, [r7, #12]
 2465 000e BB61     		str	r3, [r7, #24]
1103:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 2466              		.loc 1 1103 0
 2467 0010 3B1C     		mov	r3, r7
 2468 0012 1F33     		add	r3, r3, #31
 2469 0014 0022     		mov	r2, #0
 2470 0016 1A70     		strb	r2, [r3]
1104:../Generated_Code/UTIL1.c ****   unsigned char tmp;
1105:../Generated_Code/UTIL1.c **** 
1106:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 2471              		.loc 1 1106 0
 2472 0018 BB68     		ldr	r3, [r7, #8]
 2473 001a 013B     		sub	r3, r3, #1
 2474 001c BB60     		str	r3, [r7, #8]
1107:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 2475              		.loc 1 1107 0
 2476 001e 7B68     		ldr	r3, [r7, #4]
 2477 0020 002B     		cmp	r3, #0
 2478 0022 34D1     		bne	.L93
 2479              		.loc 1 1107 0 is_stmt 0
 2480 0024 BB68     		ldr	r3, [r7, #8]
 2481 0026 002B     		cmp	r3, #0
 2482 0028 31D0     		beq	.L93
1108:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 2483              		.loc 1 1108 0 is_stmt 1
 2484 002a 3B1C     		mov	r3, r7
 2485 002c 1F33     		add	r3, r3, #31
 2486 002e 1B78     		ldrb	r3, [r3]
 2487 0030 BA69     		ldr	r2, [r7, #24]
 2488 0032 D318     		add	r3, r2, r3
 2489 0034 3022     		mov	r2, #48
 2490 0036 1A70     		strb	r2, [r3]
 2491 0038 3B1C     		mov	r3, r7
 2492 003a 1F33     		add	r3, r3, #31
 2493 003c 3A1C     		mov	r2, r7
 2494 003e 1F32     		add	r2, r2, #31
 2495 0040 1278     		ldrb	r2, [r2]
 2496 0042 0132     		add	r2, r2, #1
 2497 0044 1A70     		strb	r2, [r3]
1109:../Generated_Code/UTIL1.c ****     dstSize--;
 2498              		.loc 1 1109 0
 2499 0046 BB68     		ldr	r3, [r7, #8]
 2500 0048 013B     		sub	r3, r3, #1
 2501 004a BB60     		str	r3, [r7, #8]
1110:../Generated_Code/UTIL1.c ****   }
1111:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2502              		.loc 1 1111 0
 2503 004c 1FE0     		b	.L93
 2504              	.L95:
1112:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 2505              		.loc 1 1112 0
 2506 004e 3B1C     		mov	r3, r7
 2507 0050 1F33     		add	r3, r3, #31
 2508 0052 1B78     		ldrb	r3, [r3]
 2509 0054 BA69     		ldr	r2, [r7, #24]
 2510 0056 D418     		add	r4, r2, r3
 2511 0058 7B68     		ldr	r3, [r7, #4]
 2512 005a 181C     		mov	r0, r3
 2513 005c 0A21     		mov	r1, #10
 2514 005e FFF7FEFF 		bl	__aeabi_uidivmod
 2515 0062 0B1C     		mov	r3, r1
 2516 0064 DBB2     		uxtb	r3, r3
 2517 0066 3033     		add	r3, r3, #48
 2518 0068 DBB2     		uxtb	r3, r3
 2519 006a 2370     		strb	r3, [r4]
 2520 006c 3B1C     		mov	r3, r7
 2521 006e 1F33     		add	r3, r3, #31
 2522 0070 3A1C     		mov	r2, r7
 2523 0072 1F32     		add	r2, r2, #31
 2524 0074 1278     		ldrb	r2, [r2]
 2525 0076 0132     		add	r2, r2, #1
 2526 0078 1A70     		strb	r2, [r3]
1113:../Generated_Code/UTIL1.c ****     dstSize--;
 2527              		.loc 1 1113 0
 2528 007a BB68     		ldr	r3, [r7, #8]
 2529 007c 013B     		sub	r3, r3, #1
 2530 007e BB60     		str	r3, [r7, #8]
1114:../Generated_Code/UTIL1.c ****     val /= 10;
 2531              		.loc 1 1114 0
 2532 0080 7B68     		ldr	r3, [r7, #4]
 2533 0082 181C     		mov	r0, r3
 2534 0084 0A21     		mov	r1, #10
 2535 0086 FFF7FEFF 		bl	__aeabi_uidiv
 2536 008a 031C     		mov	r3, r0
 2537 008c 7B60     		str	r3, [r7, #4]
 2538              	.L93:
1111:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2539              		.loc 1 1111 0
 2540 008e 7B68     		ldr	r3, [r7, #4]
 2541 0090 002B     		cmp	r3, #0
 2542 0092 02D0     		beq	.L94
1111:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 2543              		.loc 1 1111 0 is_stmt 0
 2544 0094 BB68     		ldr	r3, [r7, #8]
 2545 0096 002B     		cmp	r3, #0
 2546 0098 D9D1     		bne	.L95
 2547              	.L94:
1115:../Generated_Code/UTIL1.c ****   }
1116:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2548              		.loc 1 1116 0 is_stmt 1
 2549 009a 3B1C     		mov	r3, r7
 2550 009c 1E33     		add	r3, r3, #30
 2551 009e 0022     		mov	r2, #0
 2552 00a0 1A70     		strb	r2, [r3]
 2553 00a2 2EE0     		b	.L96
 2554              	.L97:
1117:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 2555              		.loc 1 1117 0
 2556 00a4 3B1C     		mov	r3, r7
 2557 00a6 1E33     		add	r3, r3, #30
 2558 00a8 1B78     		ldrb	r3, [r3]
 2559 00aa BA69     		ldr	r2, [r7, #24]
 2560 00ac D218     		add	r2, r2, r3
 2561 00ae 3B1C     		mov	r3, r7
 2562 00b0 1733     		add	r3, r3, #23
 2563 00b2 1278     		ldrb	r2, [r2]
 2564 00b4 1A70     		strb	r2, [r3]
1118:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 2565              		.loc 1 1118 0
 2566 00b6 3B1C     		mov	r3, r7
 2567 00b8 1E33     		add	r3, r3, #30
 2568 00ba 1B78     		ldrb	r3, [r3]
 2569 00bc BA69     		ldr	r2, [r7, #24]
 2570 00be D318     		add	r3, r2, r3
 2571 00c0 3A1C     		mov	r2, r7
 2572 00c2 1F32     		add	r2, r2, #31
 2573 00c4 1178     		ldrb	r1, [r2]
 2574 00c6 3A1C     		mov	r2, r7
 2575 00c8 1E32     		add	r2, r2, #30
 2576 00ca 1278     		ldrb	r2, [r2]
 2577 00cc 8A1A     		sub	r2, r1, r2
 2578 00ce 013A     		sub	r2, r2, #1
 2579 00d0 B969     		ldr	r1, [r7, #24]
 2580 00d2 8A18     		add	r2, r1, r2
 2581 00d4 1278     		ldrb	r2, [r2]
 2582 00d6 1A70     		strb	r2, [r3]
1119:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 2583              		.loc 1 1119 0
 2584 00d8 3B1C     		mov	r3, r7
 2585 00da 1F33     		add	r3, r3, #31
 2586 00dc 1A78     		ldrb	r2, [r3]
 2587 00de 3B1C     		mov	r3, r7
 2588 00e0 1E33     		add	r3, r3, #30
 2589 00e2 1B78     		ldrb	r3, [r3]
 2590 00e4 D31A     		sub	r3, r2, r3
 2591 00e6 013B     		sub	r3, r3, #1
 2592 00e8 BA69     		ldr	r2, [r7, #24]
 2593 00ea D318     		add	r3, r2, r3
 2594 00ec 3A1C     		mov	r2, r7
 2595 00ee 1732     		add	r2, r2, #23
 2596 00f0 1278     		ldrb	r2, [r2]
 2597 00f2 1A70     		strb	r2, [r3]
1116:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2598              		.loc 1 1116 0
 2599 00f4 3B1C     		mov	r3, r7
 2600 00f6 1E33     		add	r3, r3, #30
 2601 00f8 3A1C     		mov	r2, r7
 2602 00fa 1E32     		add	r2, r2, #30
 2603 00fc 1278     		ldrb	r2, [r2]
 2604 00fe 0132     		add	r2, r2, #1
 2605 0100 1A70     		strb	r2, [r3]
 2606              	.L96:
1116:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 2607              		.loc 1 1116 0 is_stmt 0
 2608 0102 3B1C     		mov	r3, r7
 2609 0104 1F33     		add	r3, r3, #31
 2610 0106 1B78     		ldrb	r3, [r3]
 2611 0108 5B08     		lsr	r3, r3, #1
 2612 010a DBB2     		uxtb	r3, r3
 2613 010c 3A1C     		mov	r2, r7
 2614 010e 1E32     		add	r2, r2, #30
 2615 0110 1278     		ldrb	r2, [r2]
 2616 0112 9A42     		cmp	r2, r3
 2617 0114 C6D3     		bcc	.L97
1120:../Generated_Code/UTIL1.c ****   }
1121:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 2618              		.loc 1 1121 0 is_stmt 1
 2619 0116 3B1C     		mov	r3, r7
 2620 0118 1F33     		add	r3, r3, #31
 2621 011a 1B78     		ldrb	r3, [r3]
 2622 011c BA69     		ldr	r2, [r7, #24]
 2623 011e D318     		add	r3, r2, r3
 2624 0120 0022     		mov	r2, #0
 2625 0122 1A70     		strb	r2, [r3]
1122:../Generated_Code/UTIL1.c **** }
 2626              		.loc 1 1122 0
 2627 0124 BD46     		mov	sp, r7
 2628 0126 09B0     		add	sp, sp, #36
 2629              		@ sp needed for prologue
 2630 0128 90BD     		pop	{r4, r7, pc}
 2631              		.cfi_endproc
 2632              	.LFE27:
 2634 012a C046     		.section	.text.UTIL1_IsLeapYear,"ax",%progbits
 2635              		.align	2
 2636              		.global	UTIL1_IsLeapYear
 2637              		.code	16
 2638              		.thumb_func
 2640              	UTIL1_IsLeapYear:
 2641              	.LFB28:
1123:../Generated_Code/UTIL1.c **** 
1124:../Generated_Code/UTIL1.c **** /*
1125:../Generated_Code/UTIL1.c **** ** ===================================================================
1126:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_IsLeapYear (component Utility)
1127:../Generated_Code/UTIL1.c **** **     Description :
1128:../Generated_Code/UTIL1.c **** **         Returns true if a given year is a leap year
1129:../Generated_Code/UTIL1.c **** **     Parameters  :
1130:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1131:../Generated_Code/UTIL1.c **** **         year            - Year, in the YYYY format.
1132:../Generated_Code/UTIL1.c **** **     Returns     :
1133:../Generated_Code/UTIL1.c **** **         ---             - If the year is a leap year or not.
1134:../Generated_Code/UTIL1.c **** ** ===================================================================
1135:../Generated_Code/UTIL1.c **** */
1136:../Generated_Code/UTIL1.c **** bool UTIL1_IsLeapYear(uint16_t year)
1137:../Generated_Code/UTIL1.c **** {
 2642              		.loc 1 1137 0
 2643              		.cfi_startproc
 2644 0000 80B5     		push	{r7, lr}
 2645              	.LCFI84:
 2646              		.cfi_def_cfa_offset 8
 2647              		.cfi_offset 7, -8
 2648              		.cfi_offset 14, -4
 2649 0002 82B0     		sub	sp, sp, #8
 2650              	.LCFI85:
 2651              		.cfi_def_cfa_offset 16
 2652 0004 00AF     		add	r7, sp, #0
 2653              	.LCFI86:
 2654              		.cfi_def_cfa_register 7
 2655 0006 021C     		mov	r2, r0
 2656 0008 BB1D     		add	r3, r7, #6
 2657 000a 1A80     		strh	r2, [r3]
1138:../Generated_Code/UTIL1.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
 2658              		.loc 1 1138 0
 2659 000c BB1D     		add	r3, r7, #6
 2660 000e 1A88     		ldrh	r2, [r3]
 2661 0010 0323     		mov	r3, #3
 2662 0012 1340     		and	r3, r2
 2663 0014 9BB2     		uxth	r3, r3
 2664 0016 002B     		cmp	r3, #0
 2665 0018 09D1     		bne	.L99
 2666              		.loc 1 1138 0 is_stmt 0
 2667 001a BB1D     		add	r3, r7, #6
 2668 001c 1B88     		ldrh	r3, [r3]
 2669 001e 181C     		mov	r0, r3
 2670 0020 6421     		mov	r1, #100
 2671 0022 FFF7FEFF 		bl	__aeabi_uidivmod
 2672 0026 0B1C     		mov	r3, r1
 2673 0028 9BB2     		uxth	r3, r3
 2674 002a 002B     		cmp	r3, #0
 2675 002c 0AD1     		bne	.L100
 2676              	.L99:
 2677              		.loc 1 1138 0
 2678 002e BB1D     		add	r3, r7, #6
 2679 0030 1B88     		ldrh	r3, [r3]
 2680 0032 181C     		mov	r0, r3
 2681 0034 C823     		mov	r3, #200
 2682 0036 5900     		lsl	r1, r3, #1
 2683 0038 FFF7FEFF 		bl	__aeabi_uidivmod
 2684 003c 0B1C     		mov	r3, r1
 2685 003e 9BB2     		uxth	r3, r3
 2686 0040 002B     		cmp	r3, #0
 2687 0042 01D1     		bne	.L101
 2688              	.L100:
 2689              		.loc 1 1138 0
 2690 0044 0123     		mov	r3, #1
 2691 0046 00E0     		b	.L102
 2692              	.L101:
 2693              		.loc 1 1138 0
 2694 0048 0023     		mov	r3, #0
 2695              	.L102:
 2696              		.loc 1 1138 0
 2697 004a DBB2     		uxtb	r3, r3
1139:../Generated_Code/UTIL1.c **** }
 2698              		.loc 1 1139 0 is_stmt 1
 2699 004c 181C     		mov	r0, r3
 2700 004e BD46     		mov	sp, r7
 2701 0050 02B0     		add	sp, sp, #8
 2702              		@ sp needed for prologue
 2703 0052 80BD     		pop	{r7, pc}
 2704              		.cfi_endproc
 2705              	.LFE28:
 2707              		.section	.text.UTIL1_WeekDay,"ax",%progbits
 2708              		.align	2
 2709              		.global	UTIL1_WeekDay
 2710              		.code	16
 2711              		.thumb_func
 2713              	UTIL1_WeekDay:
 2714              	.LFB29:
1140:../Generated_Code/UTIL1.c **** 
1141:../Generated_Code/UTIL1.c **** /*
1142:../Generated_Code/UTIL1.c **** ** ===================================================================
1143:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_WeekDay (component Utility)
1144:../Generated_Code/UTIL1.c **** **     Description :
1145:../Generated_Code/UTIL1.c **** **         Returns the weekday for a given date >= 1.Jan.1900
1146:../Generated_Code/UTIL1.c **** **     Parameters  :
1147:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1148:../Generated_Code/UTIL1.c **** **         year            - year in YYYY format
1149:../Generated_Code/UTIL1.c **** **         month           - month of the year (1: January, 2:
1150:../Generated_Code/UTIL1.c **** **                           February, etc)
1151:../Generated_Code/UTIL1.c **** **         day             - day of the moth (starting with 1)
1152:../Generated_Code/UTIL1.c **** **     Returns     :
1153:../Generated_Code/UTIL1.c **** **         ---             - Returns the weekday, 0 for Sunday, 1 for
1154:../Generated_Code/UTIL1.c **** **                           Monday, 2 for Tuesday, etc.
1155:../Generated_Code/UTIL1.c **** ** ===================================================================
1156:../Generated_Code/UTIL1.c **** */
1157:../Generated_Code/UTIL1.c **** uint8_t UTIL1_WeekDay(uint16_t year, uint8_t month, uint8_t day)
1158:../Generated_Code/UTIL1.c **** {
 2715              		.loc 1 1158 0
 2716              		.cfi_startproc
 2717 0000 90B5     		push	{r4, r7, lr}
 2718              	.LCFI87:
 2719              		.cfi_def_cfa_offset 12
 2720              		.cfi_offset 4, -12
 2721              		.cfi_offset 7, -8
 2722              		.cfi_offset 14, -4
 2723 0002 85B0     		sub	sp, sp, #20
 2724              	.LCFI88:
 2725              		.cfi_def_cfa_offset 32
 2726 0004 00AF     		add	r7, sp, #0
 2727              	.LCFI89:
 2728              		.cfi_def_cfa_register 7
 2729 0006 BB1D     		add	r3, r7, #6
 2730 0008 1880     		strh	r0, [r3]
 2731 000a 7B1D     		add	r3, r7, #5
 2732 000c 1970     		strb	r1, [r3]
 2733 000e 3B1D     		add	r3, r7, #4
 2734 0010 1A70     		strb	r2, [r3]
1159:../Generated_Code/UTIL1.c ****   /* see http://klausler.com/new-dayofweek.html */
1160:../Generated_Code/UTIL1.c ****   static const uint8_t skew[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
1161:../Generated_Code/UTIL1.c ****   uint16_t sum;
1162:../Generated_Code/UTIL1.c **** 
1163:../Generated_Code/UTIL1.c ****   sum = (uint16_t)(year-1900);
 2735              		.loc 1 1163 0
 2736 0012 3B1C     		mov	r3, r7
 2737 0014 0E33     		add	r3, r3, #14
 2738 0016 BA1D     		add	r2, r7, #6
 2739 0018 1288     		ldrh	r2, [r2]
 2740 001a 3349     		ldr	r1, .L108
 2741 001c 5218     		add	r2, r2, r1
 2742 001e 1A80     		strh	r2, [r3]
1164:../Generated_Code/UTIL1.c ****   sum += sum/4;
 2743              		.loc 1 1164 0
 2744 0020 3B1C     		mov	r3, r7
 2745 0022 0E33     		add	r3, r3, #14
 2746 0024 1B88     		ldrh	r3, [r3]
 2747 0026 9B08     		lsr	r3, r3, #2
 2748 0028 99B2     		uxth	r1, r3
 2749 002a 3B1C     		mov	r3, r7
 2750 002c 0E33     		add	r3, r3, #14
 2751 002e 3A1C     		mov	r2, r7
 2752 0030 0E32     		add	r2, r2, #14
 2753 0032 1288     		ldrh	r2, [r2]
 2754 0034 8A18     		add	r2, r1, r2
 2755 0036 1A80     		strh	r2, [r3]
1165:../Generated_Code/UTIL1.c ****   sum %= 7;
 2756              		.loc 1 1165 0
 2757 0038 3C1C     		mov	r4, r7
 2758 003a 0E34     		add	r4, r4, #14
 2759 003c 3B1C     		mov	r3, r7
 2760 003e 0E33     		add	r3, r3, #14
 2761 0040 1B88     		ldrh	r3, [r3]
 2762 0042 181C     		mov	r0, r3
 2763 0044 0721     		mov	r1, #7
 2764 0046 FFF7FEFF 		bl	__aeabi_uidivmod
 2765 004a 0B1C     		mov	r3, r1
 2766 004c 2380     		strh	r3, [r4]
1166:../Generated_Code/UTIL1.c ****   if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
 2767              		.loc 1 1166 0
 2768 004e BB1D     		add	r3, r7, #6
 2769 0050 1B88     		ldrh	r3, [r3]
 2770 0052 181C     		mov	r0, r3
 2771 0054 FFF7FEFF 		bl	UTIL1_IsLeapYear
 2772 0058 031C     		mov	r3, r0
 2773 005a 002B     		cmp	r3, #0
 2774 005c 0ED0     		beq	.L105
 2775              		.loc 1 1166 0 is_stmt 0
 2776 005e 7B1D     		add	r3, r7, #5
 2777 0060 1B78     		ldrb	r3, [r3]
 2778 0062 012B     		cmp	r3, #1
 2779 0064 03D0     		beq	.L106
 2780 0066 7B1D     		add	r3, r7, #5
 2781 0068 1B78     		ldrb	r3, [r3]
 2782 006a 022B     		cmp	r3, #2
 2783 006c 06D1     		bne	.L105
 2784              	.L106:
1167:../Generated_Code/UTIL1.c ****     sum--;
 2785              		.loc 1 1167 0 is_stmt 1
 2786 006e 3B1C     		mov	r3, r7
 2787 0070 0E33     		add	r3, r3, #14
 2788 0072 3A1C     		mov	r2, r7
 2789 0074 0E32     		add	r2, r2, #14
 2790 0076 1288     		ldrh	r2, [r2]
 2791 0078 013A     		sub	r2, r2, #1
 2792 007a 1A80     		strh	r2, [r3]
 2793              	.L105:
1168:../Generated_Code/UTIL1.c ****   }
1169:../Generated_Code/UTIL1.c ****   sum += day;
 2794              		.loc 1 1169 0
 2795 007c 3B1D     		add	r3, r7, #4
 2796 007e 1B78     		ldrb	r3, [r3]
 2797 0080 99B2     		uxth	r1, r3
 2798 0082 3B1C     		mov	r3, r7
 2799 0084 0E33     		add	r3, r3, #14
 2800 0086 3A1C     		mov	r2, r7
 2801 0088 0E32     		add	r2, r2, #14
 2802 008a 1288     		ldrh	r2, [r2]
 2803 008c 8A18     		add	r2, r1, r2
 2804 008e 1A80     		strh	r2, [r3]
1170:../Generated_Code/UTIL1.c ****   sum %= 7;
 2805              		.loc 1 1170 0
 2806 0090 3C1C     		mov	r4, r7
 2807 0092 0E34     		add	r4, r4, #14
 2808 0094 3B1C     		mov	r3, r7
 2809 0096 0E33     		add	r3, r3, #14
 2810 0098 1B88     		ldrh	r3, [r3]
 2811 009a 181C     		mov	r0, r3
 2812 009c 0721     		mov	r1, #7
 2813 009e FFF7FEFF 		bl	__aeabi_uidivmod
 2814 00a2 0B1C     		mov	r3, r1
 2815 00a4 2380     		strh	r3, [r4]
1171:../Generated_Code/UTIL1.c ****   sum += skew[month-1];
 2816              		.loc 1 1171 0
 2817 00a6 7B1D     		add	r3, r7, #5
 2818 00a8 1B78     		ldrb	r3, [r3]
 2819 00aa 013B     		sub	r3, r3, #1
 2820 00ac 0F4A     		ldr	r2, .L108+4
 2821 00ae D35C     		ldrb	r3, [r2, r3]
 2822 00b0 191C     		mov	r1, r3
 2823 00b2 3B1C     		mov	r3, r7
 2824 00b4 0E33     		add	r3, r3, #14
 2825 00b6 3A1C     		mov	r2, r7
 2826 00b8 0E32     		add	r2, r2, #14
 2827 00ba 1288     		ldrh	r2, [r2]
 2828 00bc 8A18     		add	r2, r1, r2
 2829 00be 1A80     		strh	r2, [r3]
1172:../Generated_Code/UTIL1.c ****   sum %= 7;
 2830              		.loc 1 1172 0
 2831 00c0 3C1C     		mov	r4, r7
 2832 00c2 0E34     		add	r4, r4, #14
 2833 00c4 3B1C     		mov	r3, r7
 2834 00c6 0E33     		add	r3, r3, #14
 2835 00c8 1B88     		ldrh	r3, [r3]
 2836 00ca 181C     		mov	r0, r3
 2837 00cc 0721     		mov	r1, #7
 2838 00ce FFF7FEFF 		bl	__aeabi_uidivmod
 2839 00d2 0B1C     		mov	r3, r1
 2840 00d4 2380     		strh	r3, [r4]
1173:../Generated_Code/UTIL1.c ****   return (uint8_t)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
 2841              		.loc 1 1173 0
 2842 00d6 3B1C     		mov	r3, r7
 2843 00d8 0E33     		add	r3, r3, #14
 2844 00da 1B88     		ldrh	r3, [r3]
 2845 00dc DBB2     		uxtb	r3, r3
1174:../Generated_Code/UTIL1.c **** }
 2846              		.loc 1 1174 0
 2847 00de 181C     		mov	r0, r3
 2848 00e0 BD46     		mov	sp, r7
 2849 00e2 05B0     		add	sp, sp, #20
 2850              		@ sp needed for prologue
 2851 00e4 90BD     		pop	{r4, r7, pc}
 2852              	.L109:
 2853 00e6 C046     		.align	2
 2854              	.L108:
 2855 00e8 94F8FFFF 		.word	-1900
 2856 00ec 00000000 		.word	skew.6402
 2857              		.cfi_endproc
 2858              	.LFE29:
 2860              		.section	.rodata
 2861              		.align	2
 2862              	.LC5:
 2863 0014 00       		.ascii	"\000"
 2864              		.section	.text.UTIL1_ReadEscapedName,"ax",%progbits
 2865              		.align	2
 2866              		.global	UTIL1_ReadEscapedName
 2867              		.code	16
 2868              		.thumb_func
 2870              	UTIL1_ReadEscapedName:
 2871              	.LFB30:
1175:../Generated_Code/UTIL1.c **** 
1176:../Generated_Code/UTIL1.c **** /*
1177:../Generated_Code/UTIL1.c **** ** ===================================================================
1178:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ReadEscapedName (component Utility)
1179:../Generated_Code/UTIL1.c **** **     Description :
1180:../Generated_Code/UTIL1.c **** **         Scans an escaped name from a string. This is useful e.g. for
1181:../Generated_Code/UTIL1.c **** **         double quoted file names.
1182:../Generated_Code/UTIL1.c **** **     Parameters  :
1183:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1184:../Generated_Code/UTIL1.c **** **       * filename        - the name to be copied. Names may
1185:../Generated_Code/UTIL1.c **** **                           be in quoted format
1186:../Generated_Code/UTIL1.c **** **       * destname        - the destination of the copy.
1187:../Generated_Code/UTIL1.c **** **                           Names are not in quoted format. destname
1188:../Generated_Code/UTIL1.c **** **                           may be NULL to get the other return values
1189:../Generated_Code/UTIL1.c **** **                           only
1190:../Generated_Code/UTIL1.c **** **         maxlen          - length allocated for destname
1191:../Generated_Code/UTIL1.c **** **       * lenRead         - length read in filename to copy
1192:../Generated_Code/UTIL1.c **** **                           the whole name. Note that filenames maybe
1193:../Generated_Code/UTIL1.c **** **                           space terminated, so *lenRead <
1194:../Generated_Code/UTIL1.c **** **                           strlen(filename)
1195:../Generated_Code/UTIL1.c **** **         lenWritten      - the size written in destname.
1196:../Generated_Code/UTIL1.c **** **                           In case of overflows in destname,
1197:../Generated_Code/UTIL1.c **** **                           lenWritten is still increased but destname
1198:../Generated_Code/UTIL1.c **** **                           no longer written. The have the string
1199:../Generated_Code/UTIL1.c **** **                           length in these cases use strlen(destname)
1200:../Generated_Code/UTIL1.c **** **         terminators     - additional characters
1201:../Generated_Code/UTIL1.c **** **                           where a name should terminate. May be NULL
1202:../Generated_Code/UTIL1.c **** **     Returns     :
1203:../Generated_Code/UTIL1.c **** **         ---             - Error code
1204:../Generated_Code/UTIL1.c **** ** ===================================================================
1205:../Generated_Code/UTIL1.c **** */
1206:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ReadEscapedName(const unsigned char *filename, uint8_t *destname, size_t maxlen, size
1207:../Generated_Code/UTIL1.c **** {
 2872              		.loc 1 1207 0
 2873              		.cfi_startproc
 2874 0000 80B5     		push	{r7, lr}
 2875              	.LCFI90:
 2876              		.cfi_def_cfa_offset 8
 2877              		.cfi_offset 7, -8
 2878              		.cfi_offset 14, -4
 2879 0002 88B0     		sub	sp, sp, #32
 2880              	.LCFI91:
 2881              		.cfi_def_cfa_offset 40
 2882 0004 00AF     		add	r7, sp, #0
 2883              	.LCFI92:
 2884              		.cfi_def_cfa_register 7
 2885 0006 F860     		str	r0, [r7, #12]
 2886 0008 B960     		str	r1, [r7, #8]
 2887 000a 7A60     		str	r2, [r7, #4]
 2888 000c 3B60     		str	r3, [r7]
1208:../Generated_Code/UTIL1.c ****   size_t lenCopied = 0, lenOverread = 0;
 2889              		.loc 1 1208 0
 2890 000e 0023     		mov	r3, #0
 2891 0010 FB61     		str	r3, [r7, #28]
 2892 0012 0023     		mov	r3, #0
 2893 0014 BB61     		str	r3, [r7, #24]
1209:../Generated_Code/UTIL1.c ****   bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a sec
 2894              		.loc 1 1209 0
 2895 0016 3B1C     		mov	r3, r7
 2896 0018 1733     		add	r3, r3, #23
 2897 001a 0022     		mov	r2, #0
 2898 001c 1A70     		strb	r2, [r3]
1210:../Generated_Code/UTIL1.c ****                               terminates the string. In !quoteMode a space or a '\0' may also termi
1211:../Generated_Code/UTIL1.c ****   bool res = ERR_OK;
 2899              		.loc 1 1211 0
 2900 001e 3B1C     		mov	r3, r7
 2901 0020 1633     		add	r3, r3, #22
 2902 0022 0022     		mov	r2, #0
 2903 0024 1A70     		strb	r2, [r3]
1212:../Generated_Code/UTIL1.c ****   #define IS_SPACE(ch) ((ch)==' '||(ch)=='\t'||(ch)=='\n'||(ch)=='\v'||(ch)=='\f'||(ch)=='\r')
1213:../Generated_Code/UTIL1.c **** 
1214:../Generated_Code/UTIL1.c ****   if (filename==NULL || (destname!=NULL && maxlen==0)) {
 2904              		.loc 1 1214 0
 2905 0026 FB68     		ldr	r3, [r7, #12]
 2906 0028 002B     		cmp	r3, #0
 2907 002a 05D0     		beq	.L111
 2908              		.loc 1 1214 0 is_stmt 0
 2909 002c BB68     		ldr	r3, [r7, #8]
 2910 002e 002B     		cmp	r3, #0
 2911 0030 04D0     		beq	.L112
 2912 0032 7B68     		ldr	r3, [r7, #4]
 2913 0034 002B     		cmp	r3, #0
 2914 0036 01D1     		bne	.L112
 2915              	.L111:
1215:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 2916              		.loc 1 1215 0 is_stmt 1
 2917 0038 1B23     		mov	r3, #27
 2918 003a 89E0     		b	.L113
 2919              	.L112:
1216:../Generated_Code/UTIL1.c ****   }
1217:../Generated_Code/UTIL1.c ****   if (filename[0] == '"') { /* translated mode */
 2920              		.loc 1 1217 0
 2921 003c FB68     		ldr	r3, [r7, #12]
 2922 003e 1B78     		ldrb	r3, [r3]
 2923 0040 222B     		cmp	r3, #34
 2924 0042 09D1     		bne	.L114
1218:../Generated_Code/UTIL1.c ****     filename++; /* overread '"' */
 2925              		.loc 1 1218 0
 2926 0044 FB68     		ldr	r3, [r7, #12]
 2927 0046 0133     		add	r3, r3, #1
 2928 0048 FB60     		str	r3, [r7, #12]
1219:../Generated_Code/UTIL1.c ****     lenOverread++;
 2929              		.loc 1 1219 0
 2930 004a BB69     		ldr	r3, [r7, #24]
 2931 004c 0133     		add	r3, r3, #1
 2932 004e BB61     		str	r3, [r7, #24]
1220:../Generated_Code/UTIL1.c ****     quoteMode=TRUE;
 2933              		.loc 1 1220 0
 2934 0050 3B1C     		mov	r3, r7
 2935 0052 1733     		add	r3, r3, #23
 2936 0054 0122     		mov	r2, #1
 2937 0056 1A70     		strb	r2, [r3]
 2938              	.L114:
1221:../Generated_Code/UTIL1.c ****   }
1222:../Generated_Code/UTIL1.c ****   if (terminators == NULL) {
 2939              		.loc 1 1222 0
 2940 0058 FB6A     		ldr	r3, [r7, #44]
 2941 005a 002B     		cmp	r3, #0
 2942 005c 01D1     		bne	.L115
1223:../Generated_Code/UTIL1.c ****     terminators = "";
 2943              		.loc 1 1223 0
 2944 005e 3E4B     		ldr	r3, .L126
 2945 0060 FB62     		str	r3, [r7, #44]
 2946              	.L115:
1224:../Generated_Code/UTIL1.c ****   }
1225:../Generated_Code/UTIL1.c ****   for (;;) {
1226:../Generated_Code/UTIL1.c ****     if (quoteMode) {
 2947              		.loc 1 1226 0
 2948 0062 3B1C     		mov	r3, r7
 2949 0064 1733     		add	r3, r3, #23
 2950 0066 1B78     		ldrb	r3, [r3]
 2951 0068 002B     		cmp	r3, #0
 2952 006a 16D0     		beq	.L116
1227:../Generated_Code/UTIL1.c ****       if (filename[0] == '"') {
 2953              		.loc 1 1227 0
 2954 006c FB68     		ldr	r3, [r7, #12]
 2955 006e 1B78     		ldrb	r3, [r3]
 2956 0070 222B     		cmp	r3, #34
 2957 0072 09D1     		bne	.L117
1228:../Generated_Code/UTIL1.c ****         filename++; /* overread '"' */
 2958              		.loc 1 1228 0
 2959 0074 FB68     		ldr	r3, [r7, #12]
 2960 0076 0133     		add	r3, r3, #1
 2961 0078 FB60     		str	r3, [r7, #12]
1229:../Generated_Code/UTIL1.c ****         lenOverread++;
 2962              		.loc 1 1229 0
 2963 007a BB69     		ldr	r3, [r7, #24]
 2964 007c 0133     		add	r3, r3, #1
 2965 007e BB61     		str	r3, [r7, #24]
1230:../Generated_Code/UTIL1.c ****         if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is t
 2966              		.loc 1 1230 0
 2967 0080 FB68     		ldr	r3, [r7, #12]
 2968 0082 1B78     		ldrb	r3, [r3]
 2969 0084 222B     		cmp	r3, #34
 2970 0086 4AD1     		bne	.L125
 2971              	.L117:
1231:../Generated_Code/UTIL1.c ****           break; /* successfully finished with this name */
1232:../Generated_Code/UTIL1.c ****         } /* else we copy the second quote " */
1233:../Generated_Code/UTIL1.c ****       }
1234:../Generated_Code/UTIL1.c ****       if (filename[0] == '\0') { /* unexpected 0. stop */
 2972              		.loc 1 1234 0
 2973 0088 FB68     		ldr	r3, [r7, #12]
 2974 008a 1B78     		ldrb	r3, [r3]
 2975 008c 002B     		cmp	r3, #0
 2976 008e 2AD1     		bne	.L119
1235:../Generated_Code/UTIL1.c ****         res = ERR_FAILED;
 2977              		.loc 1 1235 0
 2978 0090 3B1C     		mov	r3, r7
 2979 0092 1633     		add	r3, r3, #22
 2980 0094 1B22     		mov	r2, #27
 2981 0096 1A70     		strb	r2, [r3]
1236:../Generated_Code/UTIL1.c ****         break; /* error case: no terminating double quote (") was found */
 2982              		.loc 1 1236 0
 2983 0098 42E0     		b	.L118
 2984              	.L116:
1237:../Generated_Code/UTIL1.c ****       }
1238:../Generated_Code/UTIL1.c ****     } else { /* copy mode */
1239:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2985              		.loc 1 1239 0
 2986 009a FB68     		ldr	r3, [r7, #12]
 2987 009c 1B78     		ldrb	r3, [r3]
 2988 009e 202B     		cmp	r3, #32
 2989 00a0 3ED0     		beq	.L118
 2990              		.loc 1 1239 0 is_stmt 0
 2991 00a2 FB68     		ldr	r3, [r7, #12]
 2992 00a4 1B78     		ldrb	r3, [r3]
 2993 00a6 092B     		cmp	r3, #9
 2994 00a8 3AD0     		beq	.L118
 2995 00aa FB68     		ldr	r3, [r7, #12]
 2996 00ac 1B78     		ldrb	r3, [r3]
 2997 00ae 0A2B     		cmp	r3, #10
 2998 00b0 36D0     		beq	.L118
 2999              		.loc 1 1239 0
 3000 00b2 FB68     		ldr	r3, [r7, #12]
 3001 00b4 1B78     		ldrb	r3, [r3]
 3002 00b6 0B2B     		cmp	r3, #11
 3003 00b8 32D0     		beq	.L118
 3004              		.loc 1 1239 0
 3005 00ba FB68     		ldr	r3, [r7, #12]
 3006 00bc 1B78     		ldrb	r3, [r3]
 3007 00be 0C2B     		cmp	r3, #12
 3008 00c0 2ED0     		beq	.L118
 3009              		.loc 1 1239 0
 3010 00c2 FB68     		ldr	r3, [r7, #12]
 3011 00c4 1B78     		ldrb	r3, [r3]
 3012 00c6 0D2B     		cmp	r3, #13
 3013 00c8 2AD0     		beq	.L118
 3014              		.loc 1 1239 0
 3015 00ca FB68     		ldr	r3, [r7, #12]
 3016 00cc 1B78     		ldrb	r3, [r3]
 3017 00ce 002B     		cmp	r3, #0
 3018 00d0 26D0     		beq	.L118
 3019              		.loc 1 1239 0
 3020 00d2 FB68     		ldr	r3, [r7, #12]
 3021 00d4 1B78     		ldrb	r3, [r3]
 3022 00d6 FA6A     		ldr	r2, [r7, #44]
 3023 00d8 101C     		mov	r0, r2
 3024 00da 191C     		mov	r1, r3
 3025 00dc FFF7FEFF 		bl	strchr
 3026 00e0 031C     		mov	r3, r0
 3027 00e2 002B     		cmp	r3, #0
 3028 00e4 1CD1     		bne	.L118
 3029              	.L119:
1240:../Generated_Code/UTIL1.c ****         break;
1241:../Generated_Code/UTIL1.c ****       }
1242:../Generated_Code/UTIL1.c ****     }
1243:../Generated_Code/UTIL1.c ****     if (destname != NULL) {
 3030              		.loc 1 1243 0 is_stmt 1
 3031 00e6 BB68     		ldr	r3, [r7, #8]
 3032 00e8 002B     		cmp	r3, #0
 3033 00ea 11D0     		beq	.L120
1244:../Generated_Code/UTIL1.c ****       if (lenCopied + 1 < maxlen) {
 3034              		.loc 1 1244 0
 3035 00ec FB69     		ldr	r3, [r7, #28]
 3036 00ee 5A1C     		add	r2, r3, #1
 3037 00f0 7B68     		ldr	r3, [r7, #4]
 3038 00f2 9A42     		cmp	r2, r3
 3039 00f4 07D2     		bcs	.L121
1245:../Generated_Code/UTIL1.c ****         destname[0] = filename[0];
 3040              		.loc 1 1245 0
 3041 00f6 FB68     		ldr	r3, [r7, #12]
 3042 00f8 1A78     		ldrb	r2, [r3]
 3043 00fa BB68     		ldr	r3, [r7, #8]
 3044 00fc 1A70     		strb	r2, [r3]
1246:../Generated_Code/UTIL1.c ****         destname++;
 3045              		.loc 1 1246 0
 3046 00fe BB68     		ldr	r3, [r7, #8]
 3047 0100 0133     		add	r3, r3, #1
 3048 0102 BB60     		str	r3, [r7, #8]
 3049 0104 04E0     		b	.L120
 3050              	.L121:
1247:../Generated_Code/UTIL1.c ****       } else {
1248:../Generated_Code/UTIL1.c ****         destname[0] = '\0'; /* terminate string */
 3051              		.loc 1 1248 0
 3052 0106 BB68     		ldr	r3, [r7, #8]
 3053 0108 0022     		mov	r2, #0
 3054 010a 1A70     		strb	r2, [r3]
1249:../Generated_Code/UTIL1.c ****         destname = NULL; /* avoid it to overwrite not allocated space */
 3055              		.loc 1 1249 0
 3056 010c 0023     		mov	r3, #0
 3057 010e BB60     		str	r3, [r7, #8]
 3058              	.L120:
1250:../Generated_Code/UTIL1.c ****       }
1251:../Generated_Code/UTIL1.c ****     }
1252:../Generated_Code/UTIL1.c ****     lenCopied++;
 3059              		.loc 1 1252 0
 3060 0110 FB69     		ldr	r3, [r7, #28]
 3061 0112 0133     		add	r3, r3, #1
 3062 0114 FB61     		str	r3, [r7, #28]
1253:../Generated_Code/UTIL1.c ****     filename++;
 3063              		.loc 1 1253 0
 3064 0116 FB68     		ldr	r3, [r7, #12]
 3065 0118 0133     		add	r3, r3, #1
 3066 011a FB60     		str	r3, [r7, #12]
1254:../Generated_Code/UTIL1.c ****   }
 3067              		.loc 1 1254 0
 3068 011c A1E7     		b	.L115
 3069              	.L125:
1231:../Generated_Code/UTIL1.c ****           break; /* successfully finished with this name */
 3070              		.loc 1 1231 0
 3071 011e C046     		mov	r8, r8
 3072              	.L118:
1255:../Generated_Code/UTIL1.c ****   if (destname != NULL) {
 3073              		.loc 1 1255 0
 3074 0120 BB68     		ldr	r3, [r7, #8]
 3075 0122 002B     		cmp	r3, #0
 3076 0124 02D0     		beq	.L122
1256:../Generated_Code/UTIL1.c ****     destname[0] = '\0';
 3077              		.loc 1 1256 0
 3078 0126 BB68     		ldr	r3, [r7, #8]
 3079 0128 0022     		mov	r2, #0
 3080 012a 1A70     		strb	r2, [r3]
 3081              	.L122:
1257:../Generated_Code/UTIL1.c ****   }
1258:../Generated_Code/UTIL1.c ****   if (lenRead != NULL) {
 3082              		.loc 1 1258 0
 3083 012c 3B68     		ldr	r3, [r7]
 3084 012e 002B     		cmp	r3, #0
 3085 0130 04D0     		beq	.L123
1259:../Generated_Code/UTIL1.c ****     *lenRead = lenCopied+lenOverread;
 3086              		.loc 1 1259 0
 3087 0132 FA69     		ldr	r2, [r7, #28]
 3088 0134 BB69     		ldr	r3, [r7, #24]
 3089 0136 D218     		add	r2, r2, r3
 3090 0138 3B68     		ldr	r3, [r7]
 3091 013a 1A60     		str	r2, [r3]
 3092              	.L123:
1260:../Generated_Code/UTIL1.c ****   }
1261:../Generated_Code/UTIL1.c ****   if (lenWritten != NULL) {
 3093              		.loc 1 1261 0
 3094 013c BB6A     		ldr	r3, [r7, #40]
 3095 013e 002B     		cmp	r3, #0
 3096 0140 03D0     		beq	.L124
1262:../Generated_Code/UTIL1.c ****     *lenWritten = lenCopied + 1; /* additionally a zero byte written */
 3097              		.loc 1 1262 0
 3098 0142 FB69     		ldr	r3, [r7, #28]
 3099 0144 5A1C     		add	r2, r3, #1
 3100 0146 BB6A     		ldr	r3, [r7, #40]
 3101 0148 1A60     		str	r2, [r3]
 3102              	.L124:
1263:../Generated_Code/UTIL1.c ****   }
1264:../Generated_Code/UTIL1.c ****   return res;
 3103              		.loc 1 1264 0
 3104 014a 3B1C     		mov	r3, r7
 3105 014c 1633     		add	r3, r3, #22
 3106 014e 1B78     		ldrb	r3, [r3]
 3107              	.L113:
1265:../Generated_Code/UTIL1.c **** }
 3108              		.loc 1 1265 0
 3109 0150 181C     		mov	r0, r3
 3110 0152 BD46     		mov	sp, r7
 3111 0154 08B0     		add	sp, sp, #32
 3112              		@ sp needed for prologue
 3113 0156 80BD     		pop	{r7, pc}
 3114              	.L127:
 3115              		.align	2
 3116              	.L126:
 3117 0158 14000000 		.word	.LC5
 3118              		.cfi_endproc
 3119              	.LFE30:
 3121              		.section	.text.UTIL1_xatoi,"ax",%progbits
 3122              		.align	2
 3123              		.global	UTIL1_xatoi
 3124              		.code	16
 3125              		.thumb_func
 3127              	UTIL1_xatoi:
 3128              	.LFB31:
1266:../Generated_Code/UTIL1.c **** 
1267:../Generated_Code/UTIL1.c **** /*
1268:../Generated_Code/UTIL1.c **** ** ===================================================================
1269:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_xatoi (component Utility)
1270:../Generated_Code/UTIL1.c **** **     Description :
1271:../Generated_Code/UTIL1.c **** **         Custom atoi() (ascii to int) implementation by Elm Chan
1272:../Generated_Code/UTIL1.c **** **     Parameters  :
1273:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1274:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string to scan. Returns until
1275:../Generated_Code/UTIL1.c **** **                           where it has scanned.
1276:../Generated_Code/UTIL1.c **** **       * res             - Pointer to where to store the result
1277:../Generated_Code/UTIL1.c **** **     Returns     :
1278:../Generated_Code/UTIL1.c **** **         ---             - Error code
1279:../Generated_Code/UTIL1.c **** ** ===================================================================
1280:../Generated_Code/UTIL1.c **** */
1281:../Generated_Code/UTIL1.c **** /*------------------------------------------------------------------------/
1282:../Generated_Code/UTIL1.c **** /  Universal string handler for user console interface
1283:../Generated_Code/UTIL1.c **** /-------------------------------------------------------------------------/
1284:../Generated_Code/UTIL1.c **** /
1285:../Generated_Code/UTIL1.c **** /  Copyright (C) 2010, ChaN, all right reserved.
1286:../Generated_Code/UTIL1.c **** /
1287:../Generated_Code/UTIL1.c **** / * This software is a free software and there is NO WARRANTY.
1288:../Generated_Code/UTIL1.c **** / * No restriction on use. You can use, modify and redistribute it for
1289:../Generated_Code/UTIL1.c **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
1290:../Generated_Code/UTIL1.c **** / * Redistributions of source code must retain the above copyright notice.
1291:../Generated_Code/UTIL1.c **** /
1292:../Generated_Code/UTIL1.c **** /-------------------------------------------------------------------------*/
1293:../Generated_Code/UTIL1.c **** #ifdef __HC12__
1294:../Generated_Code/UTIL1.c ****   #pragma MESSAGE DISABLE C12056  /* message about SP debug info */
1295:../Generated_Code/UTIL1.c **** #endif
1296:../Generated_Code/UTIL1.c **** uint8_t UTIL1_xatoi(const unsigned char **str, int32_t *res)
1297:../Generated_Code/UTIL1.c **** {
 3129              		.loc 1 1297 0
 3130              		.cfi_startproc
 3131 0000 80B5     		push	{r7, lr}
 3132              	.LCFI93:
 3133              		.cfi_def_cfa_offset 8
 3134              		.cfi_offset 7, -8
 3135              		.cfi_offset 14, -4
 3136 0002 84B0     		sub	sp, sp, #16
 3137              	.LCFI94:
 3138              		.cfi_def_cfa_offset 24
 3139 0004 00AF     		add	r7, sp, #0
 3140              	.LCFI95:
 3141              		.cfi_def_cfa_register 7
 3142 0006 7860     		str	r0, [r7, #4]
 3143 0008 3960     		str	r1, [r7]
1298:../Generated_Code/UTIL1.c **** /* 123 -5   0x3ff 0b1111 0377 3.25  w "
1299:../Generated_Code/UTIL1.c ****       ^                               1st call returns 123 and next ptr
1300:../Generated_Code/UTIL1.c ****          ^                            2nd call returns -5 and next ptr
1301:../Generated_Code/UTIL1.c ****                  ^                    3rd call returns 1023 and next ptr
1302:../Generated_Code/UTIL1.c ****                         ^             4th call returns 15 and next ptr
1303:../Generated_Code/UTIL1.c ****                              ^        5th call returns 255 and next ptr
1304:../Generated_Code/UTIL1.c ****                                ^      6th call returns 3 and next ptr, caller needs to read '.'
1305:../Generated_Code/UTIL1.c ****                                  ^    7th call returns 25 and next ptr
1306:../Generated_Code/UTIL1.c ****                                     ^ 8th call fails and returns ERR_FAILED
1307:../Generated_Code/UTIL1.c **** */
1308:../Generated_Code/UTIL1.c ****   uint32_t val;
1309:../Generated_Code/UTIL1.c ****   uint8_t c, r, s = 0;
 3144              		.loc 1 1309 0
 3145 000a 3B1C     		mov	r3, r7
 3146 000c 0933     		add	r3, r3, #9
 3147 000e 0022     		mov	r2, #0
 3148 0010 1A70     		strb	r2, [r3]
1310:../Generated_Code/UTIL1.c **** 
1311:../Generated_Code/UTIL1.c ****   *res = 0;
 3149              		.loc 1 1311 0
 3150 0012 3B68     		ldr	r3, [r7]
 3151 0014 0022     		mov	r2, #0
 3152 0016 1A60     		str	r2, [r3]
1312:../Generated_Code/UTIL1.c ****   while (**str==' ') {
 3153              		.loc 1 1312 0
 3154 0018 04E0     		b	.L129
 3155              	.L130:
1313:../Generated_Code/UTIL1.c ****     (*str)++;                          /* Skip leading spaces */
 3156              		.loc 1 1313 0
 3157 001a 7B68     		ldr	r3, [r7, #4]
 3158 001c 1B68     		ldr	r3, [r3]
 3159 001e 5A1C     		add	r2, r3, #1
 3160 0020 7B68     		ldr	r3, [r7, #4]
 3161 0022 1A60     		str	r2, [r3]
 3162              	.L129:
1312:../Generated_Code/UTIL1.c ****   while (**str==' ') {
 3163              		.loc 1 1312 0
 3164 0024 7B68     		ldr	r3, [r7, #4]
 3165 0026 1B68     		ldr	r3, [r3]
 3166 0028 1B78     		ldrb	r3, [r3]
 3167 002a 202B     		cmp	r3, #32
 3168 002c F5D0     		beq	.L130
1314:../Generated_Code/UTIL1.c ****   }
1315:../Generated_Code/UTIL1.c ****   c = **str;
 3169              		.loc 1 1315 0
 3170 002e 7B68     		ldr	r3, [r7, #4]
 3171 0030 1A68     		ldr	r2, [r3]
 3172 0032 3B1C     		mov	r3, r7
 3173 0034 0B33     		add	r3, r3, #11
 3174 0036 1278     		ldrb	r2, [r2]
 3175 0038 1A70     		strb	r2, [r3]
1316:../Generated_Code/UTIL1.c ****   if (c == '-') {                      /* negative? */
 3176              		.loc 1 1316 0
 3177 003a 3B1C     		mov	r3, r7
 3178 003c 0B33     		add	r3, r3, #11
 3179 003e 1B78     		ldrb	r3, [r3]
 3180 0040 2D2B     		cmp	r3, #45
 3181 0042 0ED1     		bne	.L131
1317:../Generated_Code/UTIL1.c ****     s = 1;
 3182              		.loc 1 1317 0
 3183 0044 3B1C     		mov	r3, r7
 3184 0046 0933     		add	r3, r3, #9
 3185 0048 0122     		mov	r2, #1
 3186 004a 1A70     		strb	r2, [r3]
1318:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 3187              		.loc 1 1318 0
 3188 004c 7B68     		ldr	r3, [r7, #4]
 3189 004e 1B68     		ldr	r3, [r3]
 3190 0050 5A1C     		add	r2, r3, #1
 3191 0052 7B68     		ldr	r3, [r7, #4]
 3192 0054 1A60     		str	r2, [r3]
 3193 0056 7B68     		ldr	r3, [r7, #4]
 3194 0058 1A68     		ldr	r2, [r3]
 3195 005a 3B1C     		mov	r3, r7
 3196 005c 0B33     		add	r3, r3, #11
 3197 005e 1278     		ldrb	r2, [r2]
 3198 0060 1A70     		strb	r2, [r3]
 3199              	.L131:
1319:../Generated_Code/UTIL1.c ****   }
1320:../Generated_Code/UTIL1.c ****   if (c == '0') {
 3200              		.loc 1 1320 0
 3201 0062 3B1C     		mov	r3, r7
 3202 0064 0B33     		add	r3, r3, #11
 3203 0066 1B78     		ldrb	r3, [r3]
 3204 0068 302B     		cmp	r3, #48
 3205 006a 4FD1     		bne	.L132
1321:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 3206              		.loc 1 1321 0
 3207 006c 7B68     		ldr	r3, [r7, #4]
 3208 006e 1B68     		ldr	r3, [r3]
 3209 0070 5A1C     		add	r2, r3, #1
 3210 0072 7B68     		ldr	r3, [r7, #4]
 3211 0074 1A60     		str	r2, [r3]
 3212 0076 7B68     		ldr	r3, [r7, #4]
 3213 0078 1A68     		ldr	r2, [r3]
 3214 007a 3B1C     		mov	r3, r7
 3215 007c 0B33     		add	r3, r3, #11
 3216 007e 1278     		ldrb	r2, [r2]
 3217 0080 1A70     		strb	r2, [r3]
1322:../Generated_Code/UTIL1.c ****     switch (c) {
 3218              		.loc 1 1322 0
 3219 0082 3B1C     		mov	r3, r7
 3220 0084 0B33     		add	r3, r3, #11
 3221 0086 1B78     		ldrb	r3, [r3]
 3222 0088 622B     		cmp	r3, #98
 3223 008a 11D0     		beq	.L134
 3224 008c 782B     		cmp	r3, #120
 3225 008e 20D1     		bne	.L152
 3226              	.L135:
1323:../Generated_Code/UTIL1.c ****       case 'x':                        /* hexadecimal */
1324:../Generated_Code/UTIL1.c ****         r = 16; c = *(++(*str));
 3227              		.loc 1 1324 0
 3228 0090 3B1C     		mov	r3, r7
 3229 0092 0A33     		add	r3, r3, #10
 3230 0094 1022     		mov	r2, #16
 3231 0096 1A70     		strb	r2, [r3]
 3232 0098 7B68     		ldr	r3, [r7, #4]
 3233 009a 1B68     		ldr	r3, [r3]
 3234 009c 5A1C     		add	r2, r3, #1
 3235 009e 7B68     		ldr	r3, [r7, #4]
 3236 00a0 1A60     		str	r2, [r3]
 3237 00a2 7B68     		ldr	r3, [r7, #4]
 3238 00a4 1A68     		ldr	r2, [r3]
 3239 00a6 3B1C     		mov	r3, r7
 3240 00a8 0B33     		add	r3, r3, #11
 3241 00aa 1278     		ldrb	r2, [r2]
 3242 00ac 1A70     		strb	r2, [r3]
1325:../Generated_Code/UTIL1.c ****         break;
 3243              		.loc 1 1325 0
 3244 00ae 3DE0     		b	.L142
 3245              	.L134:
1326:../Generated_Code/UTIL1.c ****       case 'b':                        /* binary */
1327:../Generated_Code/UTIL1.c ****         r = 2; c = *(++(*str));
 3246              		.loc 1 1327 0
 3247 00b0 3B1C     		mov	r3, r7
 3248 00b2 0A33     		add	r3, r3, #10
 3249 00b4 0222     		mov	r2, #2
 3250 00b6 1A70     		strb	r2, [r3]
 3251 00b8 7B68     		ldr	r3, [r7, #4]
 3252 00ba 1B68     		ldr	r3, [r3]
 3253 00bc 5A1C     		add	r2, r3, #1
 3254 00be 7B68     		ldr	r3, [r7, #4]
 3255 00c0 1A60     		str	r2, [r3]
 3256 00c2 7B68     		ldr	r3, [r7, #4]
 3257 00c4 1A68     		ldr	r2, [r3]
 3258 00c6 3B1C     		mov	r3, r7
 3259 00c8 0B33     		add	r3, r3, #11
 3260 00ca 1278     		ldrb	r2, [r2]
 3261 00cc 1A70     		strb	r2, [r3]
1328:../Generated_Code/UTIL1.c ****         break;
 3262              		.loc 1 1328 0
 3263 00ce C046     		mov	r8, r8
 3264 00d0 2CE0     		b	.L142
 3265              	.L152:
1329:../Generated_Code/UTIL1.c ****       default:
1330:../Generated_Code/UTIL1.c ****         if (c <= ' ' || c == '.') {
 3266              		.loc 1 1330 0
 3267 00d2 3B1C     		mov	r3, r7
 3268 00d4 0B33     		add	r3, r3, #11
 3269 00d6 1B78     		ldrb	r3, [r3]
 3270 00d8 202B     		cmp	r3, #32
 3271 00da 04D9     		bls	.L137
 3272              		.loc 1 1330 0 is_stmt 0
 3273 00dc 3B1C     		mov	r3, r7
 3274 00de 0B33     		add	r3, r3, #11
 3275 00e0 1B78     		ldrb	r3, [r3]
 3276 00e2 2E2B     		cmp	r3, #46
 3277 00e4 01D1     		bne	.L138
 3278              	.L137:
1331:../Generated_Code/UTIL1.c ****           return ERR_OK;               /* single zero */
 3279              		.loc 1 1331 0 is_stmt 1
 3280 00e6 0023     		mov	r3, #0
 3281 00e8 7EE0     		b	.L139
 3282              	.L138:
1332:../Generated_Code/UTIL1.c ****         }
1333:../Generated_Code/UTIL1.c ****         if (c < '0' || c > '9') {
 3283              		.loc 1 1333 0
 3284 00ea 3B1C     		mov	r3, r7
 3285 00ec 0B33     		add	r3, r3, #11
 3286 00ee 1B78     		ldrb	r3, [r3]
 3287 00f0 2F2B     		cmp	r3, #47
 3288 00f2 04D9     		bls	.L140
 3289              		.loc 1 1333 0 is_stmt 0
 3290 00f4 3B1C     		mov	r3, r7
 3291 00f6 0B33     		add	r3, r3, #11
 3292 00f8 1B78     		ldrb	r3, [r3]
 3293 00fa 392B     		cmp	r3, #57
 3294 00fc 01D9     		bls	.L141
 3295              	.L140:
1334:../Generated_Code/UTIL1.c ****           return ERR_FAILED;           /* invalid char */
 3296              		.loc 1 1334 0 is_stmt 1
 3297 00fe 1B23     		mov	r3, #27
 3298 0100 72E0     		b	.L139
 3299              	.L141:
1335:../Generated_Code/UTIL1.c ****         }
1336:../Generated_Code/UTIL1.c ****         r = 8;                         /* octal */
 3300              		.loc 1 1336 0
 3301 0102 3B1C     		mov	r3, r7
 3302 0104 0A33     		add	r3, r3, #10
 3303 0106 0822     		mov	r2, #8
 3304 0108 1A70     		strb	r2, [r3]
1337:../Generated_Code/UTIL1.c ****         break;
 3305              		.loc 1 1337 0
 3306 010a 0FE0     		b	.L142
 3307              	.L132:
1338:../Generated_Code/UTIL1.c ****     } /* switch */
1339:../Generated_Code/UTIL1.c ****   } else {
1340:../Generated_Code/UTIL1.c ****     if (c < '0' || c > '9') {
 3308              		.loc 1 1340 0
 3309 010c 3B1C     		mov	r3, r7
 3310 010e 0B33     		add	r3, r3, #11
 3311 0110 1B78     		ldrb	r3, [r3]
 3312 0112 2F2B     		cmp	r3, #47
 3313 0114 04D9     		bls	.L143
 3314              		.loc 1 1340 0 is_stmt 0
 3315 0116 3B1C     		mov	r3, r7
 3316 0118 0B33     		add	r3, r3, #11
 3317 011a 1B78     		ldrb	r3, [r3]
 3318 011c 392B     		cmp	r3, #57
 3319 011e 01D9     		bls	.L144
 3320              	.L143:
1341:../Generated_Code/UTIL1.c ****       return ERR_FAILED;               /* EOL or invalid char */
 3321              		.loc 1 1341 0 is_stmt 1
 3322 0120 1B23     		mov	r3, #27
 3323 0122 61E0     		b	.L139
 3324              	.L144:
1342:../Generated_Code/UTIL1.c ****     }
1343:../Generated_Code/UTIL1.c ****     r = 10;                            /* decimal */
 3325              		.loc 1 1343 0
 3326 0124 3B1C     		mov	r3, r7
 3327 0126 0A33     		add	r3, r3, #10
 3328 0128 0A22     		mov	r2, #10
 3329 012a 1A70     		strb	r2, [r3]
 3330              	.L142:
1344:../Generated_Code/UTIL1.c ****   }
1345:../Generated_Code/UTIL1.c ****   val = 0;
 3331              		.loc 1 1345 0
 3332 012c 0023     		mov	r3, #0
 3333 012e FB60     		str	r3, [r7, #12]
1346:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 3334              		.loc 1 1346 0
 3335 0130 44E0     		b	.L145
 3336              	.L150:
1347:../Generated_Code/UTIL1.c ****     if (c >= 'a') c -= 0x20;
 3337              		.loc 1 1347 0
 3338 0132 3B1C     		mov	r3, r7
 3339 0134 0B33     		add	r3, r3, #11
 3340 0136 1B78     		ldrb	r3, [r3]
 3341 0138 602B     		cmp	r3, #96
 3342 013a 06D9     		bls	.L146
 3343              		.loc 1 1347 0 is_stmt 0
 3344 013c 3B1C     		mov	r3, r7
 3345 013e 0B33     		add	r3, r3, #11
 3346 0140 3A1C     		mov	r2, r7
 3347 0142 0B32     		add	r2, r2, #11
 3348 0144 1278     		ldrb	r2, [r2]
 3349 0146 203A     		sub	r2, r2, #32
 3350 0148 1A70     		strb	r2, [r3]
 3351              	.L146:
1348:../Generated_Code/UTIL1.c ****     c -= '0';
 3352              		.loc 1 1348 0 is_stmt 1
 3353 014a 3B1C     		mov	r3, r7
 3354 014c 0B33     		add	r3, r3, #11
 3355 014e 3A1C     		mov	r2, r7
 3356 0150 0B32     		add	r2, r2, #11
 3357 0152 1278     		ldrb	r2, [r2]
 3358 0154 303A     		sub	r2, r2, #48
 3359 0156 1A70     		strb	r2, [r3]
1349:../Generated_Code/UTIL1.c ****     if (c >= 17) {
 3360              		.loc 1 1349 0
 3361 0158 3B1C     		mov	r3, r7
 3362 015a 0B33     		add	r3, r3, #11
 3363 015c 1B78     		ldrb	r3, [r3]
 3364 015e 102B     		cmp	r3, #16
 3365 0160 0DD9     		bls	.L147
1350:../Generated_Code/UTIL1.c ****       c -= 7;
 3366              		.loc 1 1350 0
 3367 0162 3B1C     		mov	r3, r7
 3368 0164 0B33     		add	r3, r3, #11
 3369 0166 3A1C     		mov	r2, r7
 3370 0168 0B32     		add	r2, r2, #11
 3371 016a 1278     		ldrb	r2, [r2]
 3372 016c 073A     		sub	r2, r2, #7
 3373 016e 1A70     		strb	r2, [r3]
1351:../Generated_Code/UTIL1.c ****       if (c <= 9) return ERR_FAILED;   /* invalid char */
 3374              		.loc 1 1351 0
 3375 0170 3B1C     		mov	r3, r7
 3376 0172 0B33     		add	r3, r3, #11
 3377 0174 1B78     		ldrb	r3, [r3]
 3378 0176 092B     		cmp	r3, #9
 3379 0178 01D8     		bhi	.L147
 3380              		.loc 1 1351 0 is_stmt 0
 3381 017a 1B23     		mov	r3, #27
 3382 017c 34E0     		b	.L139
 3383              	.L147:
1352:../Generated_Code/UTIL1.c ****     }
1353:../Generated_Code/UTIL1.c ****     if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
 3384              		.loc 1 1353 0 is_stmt 1
 3385 017e 3A1C     		mov	r2, r7
 3386 0180 0B32     		add	r2, r2, #11
 3387 0182 3B1C     		mov	r3, r7
 3388 0184 0A33     		add	r3, r3, #10
 3389 0186 1278     		ldrb	r2, [r2]
 3390 0188 1B78     		ldrb	r3, [r3]
 3391 018a 9A42     		cmp	r2, r3
 3392 018c 01D3     		bcc	.L148
 3393              		.loc 1 1353 0 is_stmt 0
 3394 018e 1B23     		mov	r3, #27
 3395 0190 2AE0     		b	.L139
 3396              	.L148:
1354:../Generated_Code/UTIL1.c ****     val = val * r + c;
 3397              		.loc 1 1354 0 is_stmt 1
 3398 0192 3B1C     		mov	r3, r7
 3399 0194 0A33     		add	r3, r3, #10
 3400 0196 1B78     		ldrb	r3, [r3]
 3401 0198 FA68     		ldr	r2, [r7, #12]
 3402 019a 5A43     		mul	r2, r3
 3403 019c 3B1C     		mov	r3, r7
 3404 019e 0B33     		add	r3, r3, #11
 3405 01a0 1B78     		ldrb	r3, [r3]
 3406 01a2 D318     		add	r3, r2, r3
 3407 01a4 FB60     		str	r3, [r7, #12]
1355:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 3408              		.loc 1 1355 0
 3409 01a6 7B68     		ldr	r3, [r7, #4]
 3410 01a8 1B68     		ldr	r3, [r3]
 3411 01aa 5A1C     		add	r2, r3, #1
 3412 01ac 7B68     		ldr	r3, [r7, #4]
 3413 01ae 1A60     		str	r2, [r3]
 3414 01b0 7B68     		ldr	r3, [r7, #4]
 3415 01b2 1A68     		ldr	r2, [r3]
 3416 01b4 3B1C     		mov	r3, r7
 3417 01b6 0B33     		add	r3, r3, #11
 3418 01b8 1278     		ldrb	r2, [r2]
 3419 01ba 1A70     		strb	r2, [r3]
 3420              	.L145:
1346:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 3421              		.loc 1 1346 0
 3422 01bc 3B1C     		mov	r3, r7
 3423 01be 0B33     		add	r3, r3, #11
 3424 01c0 1B78     		ldrb	r3, [r3]
 3425 01c2 202B     		cmp	r3, #32
 3426 01c4 04D9     		bls	.L149
1346:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 3427              		.loc 1 1346 0 is_stmt 0
 3428 01c6 3B1C     		mov	r3, r7
 3429 01c8 0B33     		add	r3, r3, #11
 3430 01ca 1B78     		ldrb	r3, [r3]
 3431 01cc 2E2B     		cmp	r3, #46
 3432 01ce B0D1     		bne	.L150
 3433              	.L149:
1356:../Generated_Code/UTIL1.c ****   } /* while */
1357:../Generated_Code/UTIL1.c ****   if (s) val = 0 - val;                /* apply sign if needed */
 3434              		.loc 1 1357 0 is_stmt 1
 3435 01d0 3B1C     		mov	r3, r7
 3436 01d2 0933     		add	r3, r3, #9
 3437 01d4 1B78     		ldrb	r3, [r3]
 3438 01d6 002B     		cmp	r3, #0
 3439 01d8 02D0     		beq	.L151
 3440              		.loc 1 1357 0 is_stmt 0
 3441 01da FB68     		ldr	r3, [r7, #12]
 3442 01dc 5B42     		neg	r3, r3
 3443 01de FB60     		str	r3, [r7, #12]
 3444              	.L151:
1358:../Generated_Code/UTIL1.c ****   *res = (long)val;
 3445              		.loc 1 1358 0 is_stmt 1
 3446 01e0 FA68     		ldr	r2, [r7, #12]
 3447 01e2 3B68     		ldr	r3, [r7]
 3448 01e4 1A60     		str	r2, [r3]
1359:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3449              		.loc 1 1359 0
 3450 01e6 0023     		mov	r3, #0
 3451              	.L139:
1360:../Generated_Code/UTIL1.c **** }
 3452              		.loc 1 1360 0
 3453 01e8 181C     		mov	r0, r3
 3454 01ea BD46     		mov	sp, r7
 3455 01ec 04B0     		add	sp, sp, #16
 3456              		@ sp needed for prologue
 3457 01ee 80BD     		pop	{r7, pc}
 3458              		.cfi_endproc
 3459              	.LFE31:
 3461              		.section	.text.UTIL1_ScanDate,"ax",%progbits
 3462              		.align	2
 3463              		.global	UTIL1_ScanDate
 3464              		.code	16
 3465              		.thumb_func
 3467              	UTIL1_ScanDate:
 3468              	.LFB32:
1361:../Generated_Code/UTIL1.c **** #ifdef __HC12__
1362:../Generated_Code/UTIL1.c ****   #pragma MESSAGE DEFAULT C12056  /* message about SP debug info */
1363:../Generated_Code/UTIL1.c **** #endif
1364:../Generated_Code/UTIL1.c **** 
1365:../Generated_Code/UTIL1.c **** /*
1366:../Generated_Code/UTIL1.c **** ** ===================================================================
1367:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDate (component Utility)
1368:../Generated_Code/UTIL1.c **** **     Description :
1369:../Generated_Code/UTIL1.c **** **         Scans a date in the format "dd.mm.yyyy" or "dd-mm-yyyy". For
1370:../Generated_Code/UTIL1.c **** **         yy it will expand it to 20yy.
1371:../Generated_Code/UTIL1.c **** **     Parameters  :
1372:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1373:../Generated_Code/UTIL1.c **** **       * str             - Pointer to the string to be scanned. The
1374:../Generated_Code/UTIL1.c **** **                           function advances the pointer.
1375:../Generated_Code/UTIL1.c **** **       * day             - Pointer to where to store the day value
1376:../Generated_Code/UTIL1.c **** **       * month           - Pointer to where to store the month
1377:../Generated_Code/UTIL1.c **** **                           value
1378:../Generated_Code/UTIL1.c **** **       * year            - Pointer to where to store the year value
1379:../Generated_Code/UTIL1.c **** **     Returns     :
1380:../Generated_Code/UTIL1.c **** **         ---             - Error code
1381:../Generated_Code/UTIL1.c **** ** ===================================================================
1382:../Generated_Code/UTIL1.c **** */
1383:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDate(const unsigned char **str, uint8_t *day, uint8_t *month, uint16_t *year)
1384:../Generated_Code/UTIL1.c **** {
 3469              		.loc 1 1384 0
 3470              		.cfi_startproc
 3471 0000 80B5     		push	{r7, lr}
 3472              	.LCFI96:
 3473              		.cfi_def_cfa_offset 8
 3474              		.cfi_offset 7, -8
 3475              		.cfi_offset 14, -4
 3476 0002 86B0     		sub	sp, sp, #24
 3477              	.LCFI97:
 3478              		.cfi_def_cfa_offset 32
 3479 0004 00AF     		add	r7, sp, #0
 3480              	.LCFI98:
 3481              		.cfi_def_cfa_register 7
 3482 0006 F860     		str	r0, [r7, #12]
 3483 0008 B960     		str	r1, [r7, #8]
 3484 000a 7A60     		str	r2, [r7, #4]
 3485 000c 3B60     		str	r3, [r7]
1385:../Generated_Code/UTIL1.c ****   /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is i
1386:../Generated_Code/UTIL1.c ****   const unsigned char *p;
1387:../Generated_Code/UTIL1.c **** 
1388:../Generated_Code/UTIL1.c ****   p = *str;
 3486              		.loc 1 1388 0
 3487 000e FB68     		ldr	r3, [r7, #12]
 3488 0010 1B68     		ldr	r3, [r3]
 3489 0012 7B61     		str	r3, [r7, #20]
1389:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3490              		.loc 1 1389 0
 3491 0014 02E0     		b	.L154
 3492              	.L155:
1390:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
 3493              		.loc 1 1390 0
 3494 0016 7B69     		ldr	r3, [r7, #20]
 3495 0018 0133     		add	r3, r3, #1
 3496 001a 7B61     		str	r3, [r7, #20]
 3497              	.L154:
1389:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3498              		.loc 1 1389 0
 3499 001c 7B69     		ldr	r3, [r7, #20]
 3500 001e 1B78     		ldrb	r3, [r3]
 3501 0020 202B     		cmp	r3, #32
 3502 0022 F8D0     		beq	.L155
1391:../Generated_Code/UTIL1.c ****   }
1392:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, day)==ERR_OK
 3503              		.loc 1 1392 0
 3504 0024 3A1C     		mov	r2, r7
 3505 0026 1432     		add	r2, r2, #20
 3506 0028 BB68     		ldr	r3, [r7, #8]
 3507 002a 101C     		mov	r0, r2
 3508 002c 191C     		mov	r1, r3
 3509 002e FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3510 0032 031C     		mov	r3, r0
 3511 0034 002B     		cmp	r3, #0
 3512 0036 53D1     		bne	.L156
1393:../Generated_Code/UTIL1.c ****       && *day > 0 && *day <= 31
 3513              		.loc 1 1393 0
 3514 0038 BB68     		ldr	r3, [r7, #8]
 3515 003a 1B78     		ldrb	r3, [r3]
 3516 003c 002B     		cmp	r3, #0
 3517 003e 4FD0     		beq	.L156
 3518              		.loc 1 1393 0 is_stmt 0
 3519 0040 BB68     		ldr	r3, [r7, #8]
 3520 0042 1B78     		ldrb	r3, [r3]
 3521 0044 1F2B     		cmp	r3, #31
 3522 0046 4BD8     		bhi	.L156
1394:../Generated_Code/UTIL1.c ****       && (*p=='.' || *p=='-')
 3523              		.loc 1 1394 0 is_stmt 1
 3524 0048 7B69     		ldr	r3, [r7, #20]
 3525 004a 1B78     		ldrb	r3, [r3]
 3526 004c 2E2B     		cmp	r3, #46
 3527 004e 03D0     		beq	.L157
 3528              		.loc 1 1394 0 is_stmt 0
 3529 0050 7B69     		ldr	r3, [r7, #20]
 3530 0052 1B78     		ldrb	r3, [r3]
 3531 0054 2D2B     		cmp	r3, #45
 3532 0056 43D1     		bne	.L156
 3533              	.L157:
1395:../Generated_Code/UTIL1.c ****      )
1396:../Generated_Code/UTIL1.c ****   {
1397:../Generated_Code/UTIL1.c ****     p++;
 3534              		.loc 1 1397 0 is_stmt 1
 3535 0058 7B69     		ldr	r3, [r7, #20]
 3536 005a 0133     		add	r3, r3, #1
 3537 005c 7B61     		str	r3, [r7, #20]
1398:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, month)==ERR_OK
 3538              		.loc 1 1398 0
 3539 005e 3A1C     		mov	r2, r7
 3540 0060 1432     		add	r2, r2, #20
 3541 0062 7B68     		ldr	r3, [r7, #4]
 3542 0064 101C     		mov	r0, r2
 3543 0066 191C     		mov	r1, r3
 3544 0068 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3545 006c 031C     		mov	r3, r0
 3546 006e 002B     		cmp	r3, #0
 3547 0070 36D1     		bne	.L156
1399:../Generated_Code/UTIL1.c ****         && *month > 0 && *month <= 12
 3548              		.loc 1 1399 0
 3549 0072 7B68     		ldr	r3, [r7, #4]
 3550 0074 1B78     		ldrb	r3, [r3]
 3551 0076 002B     		cmp	r3, #0
 3552 0078 32D0     		beq	.L156
 3553              		.loc 1 1399 0 is_stmt 0
 3554 007a 7B68     		ldr	r3, [r7, #4]
 3555 007c 1B78     		ldrb	r3, [r3]
 3556 007e 0C2B     		cmp	r3, #12
 3557 0080 2ED8     		bhi	.L156
1400:../Generated_Code/UTIL1.c ****         && (*p=='.' || *p=='-')
 3558              		.loc 1 1400 0 is_stmt 1
 3559 0082 7B69     		ldr	r3, [r7, #20]
 3560 0084 1B78     		ldrb	r3, [r3]
 3561 0086 2E2B     		cmp	r3, #46
 3562 0088 03D0     		beq	.L158
 3563              		.loc 1 1400 0 is_stmt 0
 3564 008a 7B69     		ldr	r3, [r7, #20]
 3565 008c 1B78     		ldrb	r3, [r3]
 3566 008e 2D2B     		cmp	r3, #45
 3567 0090 26D1     		bne	.L156
 3568              	.L158:
1401:../Generated_Code/UTIL1.c ****        )
1402:../Generated_Code/UTIL1.c ****     {
1403:../Generated_Code/UTIL1.c ****       p++;
 3569              		.loc 1 1403 0 is_stmt 1
 3570 0092 7B69     		ldr	r3, [r7, #20]
 3571 0094 0133     		add	r3, r3, #1
 3572 0096 7B61     		str	r3, [r7, #20]
1404:../Generated_Code/UTIL1.c ****       if (   UTIL1_ScanDecimal16uNumber(&p, year)==ERR_OK
 3573              		.loc 1 1404 0
 3574 0098 3A1C     		mov	r2, r7
 3575 009a 1432     		add	r2, r2, #20
 3576 009c 3B68     		ldr	r3, [r7]
 3577 009e 101C     		mov	r0, r2
 3578 00a0 191C     		mov	r1, r3
 3579 00a2 FFF7FEFF 		bl	UTIL1_ScanDecimal16uNumber
 3580 00a6 031C     		mov	r3, r0
 3581 00a8 002B     		cmp	r3, #0
 3582 00aa 19D1     		bne	.L156
1405:../Generated_Code/UTIL1.c ****           && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
 3583              		.loc 1 1405 0
 3584 00ac 3B68     		ldr	r3, [r7]
 3585 00ae 1B88     		ldrh	r3, [r3]
 3586 00b0 002B     		cmp	r3, #0
 3587 00b2 15D0     		beq	.L156
 3588              		.loc 1 1405 0 is_stmt 0
 3589 00b4 3B68     		ldr	r3, [r7]
 3590 00b6 1A88     		ldrh	r2, [r3]
 3591 00b8 104B     		ldr	r3, .L162
 3592 00ba 9A42     		cmp	r2, r3
 3593 00bc 10D8     		bhi	.L156
1406:../Generated_Code/UTIL1.c ****          )
1407:../Generated_Code/UTIL1.c ****       {
1408:../Generated_Code/UTIL1.c ****         if (*year < 100) {
 3594              		.loc 1 1408 0 is_stmt 1
 3595 00be 3B68     		ldr	r3, [r7]
 3596 00c0 1B88     		ldrh	r3, [r3]
 3597 00c2 632B     		cmp	r3, #99
 3598 00c4 07D8     		bhi	.L159
1409:../Generated_Code/UTIL1.c ****           *year += 2000; /* transform '10' into '2010' */
 3599              		.loc 1 1409 0
 3600 00c6 3B68     		ldr	r3, [r7]
 3601 00c8 1B88     		ldrh	r3, [r3]
 3602 00ca FA22     		mov	r2, #250
 3603 00cc D200     		lsl	r2, r2, #3
 3604 00ce 9B18     		add	r3, r3, r2
 3605 00d0 9AB2     		uxth	r2, r3
 3606 00d2 3B68     		ldr	r3, [r7]
 3607 00d4 1A80     		strh	r2, [r3]
 3608              	.L159:
1410:../Generated_Code/UTIL1.c ****         }
1411:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
 3609              		.loc 1 1411 0
 3610 00d6 7A69     		ldr	r2, [r7, #20]
 3611 00d8 FB68     		ldr	r3, [r7, #12]
 3612 00da 1A60     		str	r2, [r3]
1412:../Generated_Code/UTIL1.c ****         return ERR_OK;
 3613              		.loc 1 1412 0
 3614 00dc 0023     		mov	r3, #0
 3615 00de 09E0     		b	.L161
 3616              	.L156:
1413:../Generated_Code/UTIL1.c ****       }
1414:../Generated_Code/UTIL1.c ****     }
1415:../Generated_Code/UTIL1.c ****   }
1416:../Generated_Code/UTIL1.c ****   *day = 0;
 3617              		.loc 1 1416 0
 3618 00e0 BB68     		ldr	r3, [r7, #8]
 3619 00e2 0022     		mov	r2, #0
 3620 00e4 1A70     		strb	r2, [r3]
1417:../Generated_Code/UTIL1.c ****   *month = 0;
 3621              		.loc 1 1417 0
 3622 00e6 7B68     		ldr	r3, [r7, #4]
 3623 00e8 0022     		mov	r2, #0
 3624 00ea 1A70     		strb	r2, [r3]
1418:../Generated_Code/UTIL1.c ****   *year = 0;
 3625              		.loc 1 1418 0
 3626 00ec 3B68     		ldr	r3, [r7]
 3627 00ee 0022     		mov	r2, #0
 3628 00f0 1A80     		strh	r2, [r3]
1419:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
 3629              		.loc 1 1419 0
 3630 00f2 1B23     		mov	r3, #27
 3631              	.L161:
1420:../Generated_Code/UTIL1.c **** }
 3632              		.loc 1 1420 0
 3633 00f4 181C     		mov	r0, r3
 3634 00f6 BD46     		mov	sp, r7
 3635 00f8 06B0     		add	sp, sp, #24
 3636              		@ sp needed for prologue
 3637 00fa 80BD     		pop	{r7, pc}
 3638              	.L163:
 3639              		.align	2
 3640              	.L162:
 3641 00fc B80B0000 		.word	3000
 3642              		.cfi_endproc
 3643              	.LFE32:
 3645              		.section	.text.UTIL1_ScanTime,"ax",%progbits
 3646              		.align	2
 3647              		.global	UTIL1_ScanTime
 3648              		.code	16
 3649              		.thumb_func
 3651              	UTIL1_ScanTime:
 3652              	.LFB33:
1421:../Generated_Code/UTIL1.c **** 
1422:../Generated_Code/UTIL1.c **** /*
1423:../Generated_Code/UTIL1.c **** ** ===================================================================
1424:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanTime (component Utility)
1425:../Generated_Code/UTIL1.c **** **     Description :
1426:../Generated_Code/UTIL1.c **** **         Scans a time string in the format "hh:mm:ss,hh" with the
1427:../Generated_Code/UTIL1.c **** **         part for the ",hh" is optional.
1428:../Generated_Code/UTIL1.c **** **     Parameters  :
1429:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1430:../Generated_Code/UTIL1.c **** **         str             - Pointer to the string to be scanned. The
1431:../Generated_Code/UTIL1.c **** **                           function advances the pointer.
1432:../Generated_Code/UTIL1.c **** **       * hour            - Pointer to where to store the hour value
1433:../Generated_Code/UTIL1.c **** **       * minute          - Pointer to where to store the minute
1434:../Generated_Code/UTIL1.c **** **                           value
1435:../Generated_Code/UTIL1.c **** **       * second          - Pointer to where to store the second
1436:../Generated_Code/UTIL1.c **** **                           value
1437:../Generated_Code/UTIL1.c **** **       * hSecond         - Pointer to scans the hundreds of
1438:../Generated_Code/UTIL1.c **** **                           second part. If not present in string, zero
1439:../Generated_Code/UTIL1.c **** **                           is stored
1440:../Generated_Code/UTIL1.c **** **     Returns     :
1441:../Generated_Code/UTIL1.c **** **         ---             - Error code
1442:../Generated_Code/UTIL1.c **** ** ===================================================================
1443:../Generated_Code/UTIL1.c **** */
1444:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanTime(const unsigned char **str, uint8_t *hour, uint8_t *minute, uint8_t *second, 
1445:../Generated_Code/UTIL1.c **** {
 3653              		.loc 1 1445 0
 3654              		.cfi_startproc
 3655 0000 80B5     		push	{r7, lr}
 3656              	.LCFI99:
 3657              		.cfi_def_cfa_offset 8
 3658              		.cfi_offset 7, -8
 3659              		.cfi_offset 14, -4
 3660 0002 86B0     		sub	sp, sp, #24
 3661              	.LCFI100:
 3662              		.cfi_def_cfa_offset 32
 3663 0004 00AF     		add	r7, sp, #0
 3664              	.LCFI101:
 3665              		.cfi_def_cfa_register 7
 3666 0006 F860     		str	r0, [r7, #12]
 3667 0008 B960     		str	r1, [r7, #8]
 3668 000a 7A60     		str	r2, [r7, #4]
 3669 000c 3B60     		str	r3, [r7]
1446:../Generated_Code/UTIL1.c ****   /* precondition: string points to starting of time string, e.g. "03:15:05" or "03:15:05,3" or "03
1447:../Generated_Code/UTIL1.c ****   const unsigned char *p;
1448:../Generated_Code/UTIL1.c ****   #define SCAN_IS_DIGIT(ch) ((ch)>='0'&&(ch)<='9')
1449:../Generated_Code/UTIL1.c **** 
1450:../Generated_Code/UTIL1.c ****   *hour = 0;
 3670              		.loc 1 1450 0
 3671 000e BB68     		ldr	r3, [r7, #8]
 3672 0010 0022     		mov	r2, #0
 3673 0012 1A70     		strb	r2, [r3]
1451:../Generated_Code/UTIL1.c ****   *minute = 0;
 3674              		.loc 1 1451 0
 3675 0014 7B68     		ldr	r3, [r7, #4]
 3676 0016 0022     		mov	r2, #0
 3677 0018 1A70     		strb	r2, [r3]
1452:../Generated_Code/UTIL1.c ****   *second = 0;
 3678              		.loc 1 1452 0
 3679 001a 3B68     		ldr	r3, [r7]
 3680 001c 0022     		mov	r2, #0
 3681 001e 1A70     		strb	r2, [r3]
1453:../Generated_Code/UTIL1.c ****   *hSecond = 0;
 3682              		.loc 1 1453 0
 3683 0020 3B6A     		ldr	r3, [r7, #32]
 3684 0022 0022     		mov	r2, #0
 3685 0024 1A70     		strb	r2, [r3]
1454:../Generated_Code/UTIL1.c ****   p = *str;
 3686              		.loc 1 1454 0
 3687 0026 FB68     		ldr	r3, [r7, #12]
 3688 0028 1B68     		ldr	r3, [r3]
 3689 002a 7B61     		str	r3, [r7, #20]
1455:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3690              		.loc 1 1455 0
 3691 002c 02E0     		b	.L165
 3692              	.L166:
1456:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
 3693              		.loc 1 1456 0
 3694 002e 7B69     		ldr	r3, [r7, #20]
 3695 0030 0133     		add	r3, r3, #1
 3696 0032 7B61     		str	r3, [r7, #20]
 3697              	.L165:
1455:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 3698              		.loc 1 1455 0
 3699 0034 7B69     		ldr	r3, [r7, #20]
 3700 0036 1B78     		ldrb	r3, [r3]
 3701 0038 202B     		cmp	r3, #32
 3702 003a F8D0     		beq	.L166
1457:../Generated_Code/UTIL1.c ****   }
1458:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, hour)==ERR_OK
 3703              		.loc 1 1458 0
 3704 003c 3A1C     		mov	r2, r7
 3705 003e 1432     		add	r2, r2, #20
 3706 0040 BB68     		ldr	r3, [r7, #8]
 3707 0042 101C     		mov	r0, r2
 3708 0044 191C     		mov	r1, r3
 3709 0046 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3710 004a 031C     		mov	r3, r0
 3711 004c 002B     		cmp	r3, #0
 3712 004e 00D0     		beq	.LCB3300
 3713 0050 85E0     		b	.L167	@long jump
 3714              	.LCB3300:
1459:../Generated_Code/UTIL1.c ****       && *hour <= 24
 3715              		.loc 1 1459 0
 3716 0052 BB68     		ldr	r3, [r7, #8]
 3717 0054 1B78     		ldrb	r3, [r3]
 3718 0056 182B     		cmp	r3, #24
 3719 0058 00D9     		bls	.LCB3304
 3720 005a 80E0     		b	.L167	@long jump
 3721              	.LCB3304:
1460:../Generated_Code/UTIL1.c ****       && *p==':'
 3722              		.loc 1 1460 0
 3723 005c 7B69     		ldr	r3, [r7, #20]
 3724 005e 1B78     		ldrb	r3, [r3]
 3725 0060 3A2B     		cmp	r3, #58
 3726 0062 00D0     		beq	.LCB3308
 3727 0064 7BE0     		b	.L167	@long jump
 3728              	.LCB3308:
1461:../Generated_Code/UTIL1.c ****      )
1462:../Generated_Code/UTIL1.c ****   {
1463:../Generated_Code/UTIL1.c ****     p++; /* skip ':' */
 3729              		.loc 1 1463 0
 3730 0066 7B69     		ldr	r3, [r7, #20]
 3731 0068 0133     		add	r3, r3, #1
 3732 006a 7B61     		str	r3, [r7, #20]
1464:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, minute)==ERR_OK
 3733              		.loc 1 1464 0
 3734 006c 3A1C     		mov	r2, r7
 3735 006e 1432     		add	r2, r2, #20
 3736 0070 7B68     		ldr	r3, [r7, #4]
 3737 0072 101C     		mov	r0, r2
 3738 0074 191C     		mov	r1, r3
 3739 0076 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3740 007a 031C     		mov	r3, r0
 3741 007c 002B     		cmp	r3, #0
 3742 007e 00D0     		beq	.LCB3320
 3743 0080 6DE0     		b	.L167	@long jump
 3744              	.LCB3320:
1465:../Generated_Code/UTIL1.c ****         && *minute <= 60
 3745              		.loc 1 1465 0
 3746 0082 7B68     		ldr	r3, [r7, #4]
 3747 0084 1B78     		ldrb	r3, [r3]
 3748 0086 3C2B     		cmp	r3, #60
 3749 0088 00D9     		bls	.LCB3324
 3750 008a 68E0     		b	.L167	@long jump
 3751              	.LCB3324:
1466:../Generated_Code/UTIL1.c ****        )
1467:../Generated_Code/UTIL1.c ****     {
1468:../Generated_Code/UTIL1.c ****       if (*p==':') { /* there is more after the minute */
 3752              		.loc 1 1468 0
 3753 008c 7B69     		ldr	r3, [r7, #20]
 3754 008e 1B78     		ldrb	r3, [r3]
 3755 0090 3A2B     		cmp	r3, #58
 3756 0092 57D1     		bne	.L168
1469:../Generated_Code/UTIL1.c ****         p++; /* skip ':' */
 3757              		.loc 1 1469 0
 3758 0094 7B69     		ldr	r3, [r7, #20]
 3759 0096 0133     		add	r3, r3, #1
 3760 0098 7B61     		str	r3, [r7, #20]
1470:../Generated_Code/UTIL1.c ****         if (   UTIL1_ScanDecimal8uNumber(&p, second)==ERR_OK
 3761              		.loc 1 1470 0
 3762 009a 3A1C     		mov	r2, r7
 3763 009c 1432     		add	r2, r2, #20
 3764 009e 3B68     		ldr	r3, [r7]
 3765 00a0 101C     		mov	r0, r2
 3766 00a2 191C     		mov	r1, r3
 3767 00a4 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 3768 00a8 031C     		mov	r3, r0
 3769 00aa 002B     		cmp	r3, #0
 3770 00ac 57D1     		bne	.L167
1471:../Generated_Code/UTIL1.c ****             && *second <= 60
 3771              		.loc 1 1471 0
 3772 00ae 3B68     		ldr	r3, [r7]
 3773 00b0 1B78     		ldrb	r3, [r3]
 3774 00b2 3C2B     		cmp	r3, #60
 3775 00b4 53D8     		bhi	.L167
1472:../Generated_Code/UTIL1.c ****            )
1473:../Generated_Code/UTIL1.c ****         {
1474:../Generated_Code/UTIL1.c ****           if (*p==',') { /* we do have either ",z" or ",hh" */
 3776              		.loc 1 1474 0
 3777 00b6 7B69     		ldr	r3, [r7, #20]
 3778 00b8 1B78     		ldrb	r3, [r3]
 3779 00ba 2C2B     		cmp	r3, #44
 3780 00bc 3DD1     		bne	.L169
1475:../Generated_Code/UTIL1.c ****             p++; /* skip ',' */
 3781              		.loc 1 1475 0
 3782 00be 7B69     		ldr	r3, [r7, #20]
 3783 00c0 0133     		add	r3, r3, #1
 3784 00c2 7B61     		str	r3, [r7, #20]
1476:../Generated_Code/UTIL1.c ****             if (SCAN_IS_DIGIT(*p)) {
 3785              		.loc 1 1476 0
 3786 00c4 7B69     		ldr	r3, [r7, #20]
 3787 00c6 1B78     		ldrb	r3, [r3]
 3788 00c8 2F2B     		cmp	r3, #47
 3789 00ca 34D9     		bls	.L170
 3790              		.loc 1 1476 0 is_stmt 0
 3791 00cc 7B69     		ldr	r3, [r7, #20]
 3792 00ce 1B78     		ldrb	r3, [r3]
 3793 00d0 392B     		cmp	r3, #57
 3794 00d2 30D8     		bhi	.L170
1477:../Generated_Code/UTIL1.c ****               if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
 3795              		.loc 1 1477 0 is_stmt 1
 3796 00d4 7B69     		ldr	r3, [r7, #20]
 3797 00d6 0133     		add	r3, r3, #1
 3798 00d8 1B78     		ldrb	r3, [r3]
 3799 00da 2F2B     		cmp	r3, #47
 3800 00dc 18D9     		bls	.L171
 3801              		.loc 1 1477 0 is_stmt 0
 3802 00de 7B69     		ldr	r3, [r7, #20]
 3803 00e0 0133     		add	r3, r3, #1
 3804 00e2 1B78     		ldrb	r3, [r3]
 3805 00e4 392B     		cmp	r3, #57
 3806 00e6 13D8     		bhi	.L171
1478:../Generated_Code/UTIL1.c ****                 *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
 3807              		.loc 1 1478 0 is_stmt 1
 3808 00e8 7B69     		ldr	r3, [r7, #20]
 3809 00ea 1B78     		ldrb	r3, [r3]
 3810 00ec 303B     		sub	r3, r3, #48
 3811 00ee DBB2     		uxtb	r3, r3
 3812 00f0 1A1C     		add	r2, r3, #0
 3813 00f2 9200     		lsl	r2, r2, #2
 3814 00f4 D318     		add	r3, r2, r3
 3815 00f6 5B00     		lsl	r3, r3, #1
 3816 00f8 DAB2     		uxtb	r2, r3
 3817 00fa 7B69     		ldr	r3, [r7, #20]
 3818 00fc 0133     		add	r3, r3, #1
 3819 00fe 1B78     		ldrb	r3, [r3]
 3820 0100 D318     		add	r3, r2, r3
 3821 0102 DBB2     		uxtb	r3, r3
 3822 0104 303B     		sub	r3, r3, #48
 3823 0106 DAB2     		uxtb	r2, r3
 3824 0108 3B6A     		ldr	r3, [r7, #32]
 3825 010a 1A70     		strb	r2, [r3]
1479:../Generated_Code/UTIL1.c ****                 return ERR_OK;
 3826              		.loc 1 1479 0
 3827 010c 0023     		mov	r3, #0
 3828 010e 27E0     		b	.L174
 3829              	.L171:
1480:../Generated_Code/UTIL1.c ****               } else { /* ,z format */
1481:../Generated_Code/UTIL1.c ****                 *hSecond = (uint8_t)((*p-'0')*10);
 3830              		.loc 1 1481 0
 3831 0110 7B69     		ldr	r3, [r7, #20]
 3832 0112 1B78     		ldrb	r3, [r3]
 3833 0114 303B     		sub	r3, r3, #48
 3834 0116 DBB2     		uxtb	r3, r3
 3835 0118 1A1C     		add	r2, r3, #0
 3836 011a 9200     		lsl	r2, r2, #2
 3837 011c D318     		add	r3, r2, r3
 3838 011e 5B00     		lsl	r3, r3, #1
 3839 0120 DAB2     		uxtb	r2, r3
 3840 0122 3B6A     		ldr	r3, [r7, #32]
 3841 0124 1A70     		strb	r2, [r3]
1482:../Generated_Code/UTIL1.c ****                 p++;
 3842              		.loc 1 1482 0
 3843 0126 7B69     		ldr	r3, [r7, #20]
 3844 0128 0133     		add	r3, r3, #1
 3845 012a 7B61     		str	r3, [r7, #20]
1483:../Generated_Code/UTIL1.c ****                 *str = p; /* advance pointer for caller */
 3846              		.loc 1 1483 0
 3847 012c 7A69     		ldr	r2, [r7, #20]
 3848 012e FB68     		ldr	r3, [r7, #12]
 3849 0130 1A60     		str	r2, [r3]
1484:../Generated_Code/UTIL1.c ****                 return ERR_OK;
 3850              		.loc 1 1484 0
 3851 0132 0023     		mov	r3, #0
 3852 0134 14E0     		b	.L174
 3853              	.L170:
1485:../Generated_Code/UTIL1.c ****               }
1486:../Generated_Code/UTIL1.c ****             } else {
1487:../Generated_Code/UTIL1.c ****               return ERR_FAILED; /* illegal format, not a number, e.g. ",x" */
 3854              		.loc 1 1487 0
 3855 0136 1B23     		mov	r3, #27
 3856 0138 12E0     		b	.L174
 3857              	.L169:
1488:../Generated_Code/UTIL1.c ****             }
1489:../Generated_Code/UTIL1.c ****           }
1490:../Generated_Code/UTIL1.c ****           *str = p; /* advance pointer for caller */
 3858              		.loc 1 1490 0
 3859 013a 7A69     		ldr	r2, [r7, #20]
 3860 013c FB68     		ldr	r3, [r7, #12]
 3861 013e 1A60     		str	r2, [r3]
1491:../Generated_Code/UTIL1.c ****           return ERR_OK;
 3862              		.loc 1 1491 0
 3863 0140 0023     		mov	r3, #0
 3864 0142 0DE0     		b	.L174
 3865              	.L168:
1492:../Generated_Code/UTIL1.c ****         }
1493:../Generated_Code/UTIL1.c ****       } else if (*p==' ' || *p=='\0') { /* nothing more after the minute? Assume zero seconds */
 3866              		.loc 1 1493 0
 3867 0144 7B69     		ldr	r3, [r7, #20]
 3868 0146 1B78     		ldrb	r3, [r3]
 3869 0148 202B     		cmp	r3, #32
 3870 014a 03D0     		beq	.L173
 3871              		.loc 1 1493 0 is_stmt 0
 3872 014c 7B69     		ldr	r3, [r7, #20]
 3873 014e 1B78     		ldrb	r3, [r3]
 3874 0150 002B     		cmp	r3, #0
 3875 0152 04D1     		bne	.L167
 3876              	.L173:
1494:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
 3877              		.loc 1 1494 0 is_stmt 1
 3878 0154 7A69     		ldr	r2, [r7, #20]
 3879 0156 FB68     		ldr	r3, [r7, #12]
 3880 0158 1A60     		str	r2, [r3]
1495:../Generated_Code/UTIL1.c ****         return ERR_OK;
 3881              		.loc 1 1495 0
 3882 015a 0023     		mov	r3, #0
 3883 015c 00E0     		b	.L174
 3884              	.L167:
1496:../Generated_Code/UTIL1.c ****       }
1497:../Generated_Code/UTIL1.c ****     }
1498:../Generated_Code/UTIL1.c ****   }
1499:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
 3885              		.loc 1 1499 0
 3886 015e 1B23     		mov	r3, #27
 3887              	.L174:
1500:../Generated_Code/UTIL1.c **** }
 3888              		.loc 1 1500 0
 3889 0160 181C     		mov	r0, r3
 3890 0162 BD46     		mov	sp, r7
 3891 0164 06B0     		add	sp, sp, #24
 3892              		@ sp needed for prologue
 3893 0166 80BD     		pop	{r7, pc}
 3894              		.cfi_endproc
 3895              	.LFE33:
 3897              		.section	.text.UTIL1_ScanDecimal8uNumber,"ax",%progbits
 3898              		.align	2
 3899              		.global	UTIL1_ScanDecimal8uNumber
 3900              		.code	16
 3901              		.thumb_func
 3903              	UTIL1_ScanDecimal8uNumber:
 3904              	.LFB34:
1501:../Generated_Code/UTIL1.c **** 
1502:../Generated_Code/UTIL1.c **** /*
1503:../Generated_Code/UTIL1.c **** ** ===================================================================
1504:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal8uNumber (component Utility)
1505:../Generated_Code/UTIL1.c **** **     Description :
1506:../Generated_Code/UTIL1.c **** **         Scans a decimal 8bit unsigned number
1507:../Generated_Code/UTIL1.c **** **     Parameters  :
1508:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1509:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
1510:../Generated_Code/UTIL1.c **** **                           where it has scanned
1511:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1512:../Generated_Code/UTIL1.c **** **     Returns     :
1513:../Generated_Code/UTIL1.c **** **         ---             - Error code
1514:../Generated_Code/UTIL1.c **** ** ===================================================================
1515:../Generated_Code/UTIL1.c **** */
1516:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal8uNumber(const unsigned char **str, uint8_t *val)
1517:../Generated_Code/UTIL1.c **** {
 3905              		.loc 1 1517 0
 3906              		.cfi_startproc
 3907 0000 80B5     		push	{r7, lr}
 3908              	.LCFI102:
 3909              		.cfi_def_cfa_offset 8
 3910              		.cfi_offset 7, -8
 3911              		.cfi_offset 14, -4
 3912 0002 84B0     		sub	sp, sp, #16
 3913              	.LCFI103:
 3914              		.cfi_def_cfa_offset 24
 3915 0004 00AF     		add	r7, sp, #0
 3916              	.LCFI104:
 3917              		.cfi_def_cfa_register 7
 3918 0006 7860     		str	r0, [r7, #4]
 3919 0008 3960     		str	r1, [r7]
1518:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1519:../Generated_Code/UTIL1.c ****   #define _8_NOF_DIGITS  (3+1)
1520:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = _8_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 3920              		.loc 1 1520 0
 3921 000a 3B1C     		mov	r3, r7
 3922 000c 0F33     		add	r3, r3, #15
 3923 000e 0422     		mov	r2, #4
 3924 0010 1A70     		strb	r2, [r3]
1521:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3925              		.loc 1 1521 0
 3926 0012 7B68     		ldr	r3, [r7, #4]
 3927 0014 1B68     		ldr	r3, [r3]
 3928 0016 BB60     		str	r3, [r7, #8]
1522:../Generated_Code/UTIL1.c **** 
1523:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 3929              		.loc 1 1523 0
 3930 0018 02E0     		b	.L176
 3931              	.L177:
1524:../Generated_Code/UTIL1.c ****     p++;
 3932              		.loc 1 1524 0
 3933 001a BB68     		ldr	r3, [r7, #8]
 3934 001c 0133     		add	r3, r3, #1
 3935 001e BB60     		str	r3, [r7, #8]
 3936              	.L176:
1523:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 3937              		.loc 1 1523 0
 3938 0020 BB68     		ldr	r3, [r7, #8]
 3939 0022 1B78     		ldrb	r3, [r3]
 3940 0024 202B     		cmp	r3, #32
 3941 0026 F8D0     		beq	.L177
1525:../Generated_Code/UTIL1.c ****   }
1526:../Generated_Code/UTIL1.c ****   *val = 0;
 3942              		.loc 1 1526 0
 3943 0028 3B68     		ldr	r3, [r7]
 3944 002a 0022     		mov	r2, #0
 3945 002c 1A70     		strb	r2, [r3]
1527:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3946              		.loc 1 1527 0
 3947 002e 18E0     		b	.L178
 3948              	.L180:
1528:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*10 + *p-'0');
 3949              		.loc 1 1528 0
 3950 0030 3B68     		ldr	r3, [r7]
 3951 0032 1B78     		ldrb	r3, [r3]
 3952 0034 1A1C     		add	r2, r3, #0
 3953 0036 9200     		lsl	r2, r2, #2
 3954 0038 D318     		add	r3, r2, r3
 3955 003a 5B00     		lsl	r3, r3, #1
 3956 003c DAB2     		uxtb	r2, r3
 3957 003e BB68     		ldr	r3, [r7, #8]
 3958 0040 1B78     		ldrb	r3, [r3]
 3959 0042 D318     		add	r3, r2, r3
 3960 0044 DBB2     		uxtb	r3, r3
 3961 0046 303B     		sub	r3, r3, #48
 3962 0048 DAB2     		uxtb	r2, r3
 3963 004a 3B68     		ldr	r3, [r7]
 3964 004c 1A70     		strb	r2, [r3]
1529:../Generated_Code/UTIL1.c ****     nofDigits--;
 3965              		.loc 1 1529 0
 3966 004e 3B1C     		mov	r3, r7
 3967 0050 0F33     		add	r3, r3, #15
 3968 0052 3A1C     		mov	r2, r7
 3969 0054 0F32     		add	r2, r2, #15
 3970 0056 1278     		ldrb	r2, [r2]
 3971 0058 013A     		sub	r2, r2, #1
 3972 005a 1A70     		strb	r2, [r3]
1530:../Generated_Code/UTIL1.c ****     p++;
 3973              		.loc 1 1530 0
 3974 005c BB68     		ldr	r3, [r7, #8]
 3975 005e 0133     		add	r3, r3, #1
 3976 0060 BB60     		str	r3, [r7, #8]
 3977              	.L178:
1527:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3978              		.loc 1 1527 0
 3979 0062 BB68     		ldr	r3, [r7, #8]
 3980 0064 1B78     		ldrb	r3, [r3]
 3981 0066 2F2B     		cmp	r3, #47
 3982 0068 08D9     		bls	.L179
1527:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3983              		.loc 1 1527 0 is_stmt 0
 3984 006a BB68     		ldr	r3, [r7, #8]
 3985 006c 1B78     		ldrb	r3, [r3]
 3986 006e 392B     		cmp	r3, #57
 3987 0070 04D8     		bhi	.L179
1527:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3988              		.loc 1 1527 0
 3989 0072 3B1C     		mov	r3, r7
 3990 0074 0F33     		add	r3, r3, #15
 3991 0076 1B78     		ldrb	r3, [r3]
 3992 0078 002B     		cmp	r3, #0
 3993 007a D9D1     		bne	.L180
 3994              	.L179:
1531:../Generated_Code/UTIL1.c ****   } /* while */
1532:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 3995              		.loc 1 1532 0 is_stmt 1
 3996 007c 3B1C     		mov	r3, r7
 3997 007e 0F33     		add	r3, r3, #15
 3998 0080 1B78     		ldrb	r3, [r3]
 3999 0082 002B     		cmp	r3, #0
 4000 0084 01D1     		bne	.L181
1533:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4001              		.loc 1 1533 0
 4002 0086 0423     		mov	r3, #4
 4003 0088 0AE0     		b	.L182
 4004              	.L181:
1534:../Generated_Code/UTIL1.c ****   }
1535:../Generated_Code/UTIL1.c ****   if (nofDigits==_8_NOF_DIGITS) { /* no digits at all? */
 4005              		.loc 1 1535 0
 4006 008a 3B1C     		mov	r3, r7
 4007 008c 0F33     		add	r3, r3, #15
 4008 008e 1B78     		ldrb	r3, [r3]
 4009 0090 042B     		cmp	r3, #4
 4010 0092 01D1     		bne	.L183
1536:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4011              		.loc 1 1536 0
 4012 0094 1B23     		mov	r3, #27
 4013 0096 03E0     		b	.L182
 4014              	.L183:
1537:../Generated_Code/UTIL1.c ****   }
1538:../Generated_Code/UTIL1.c ****   *str = p;
 4015              		.loc 1 1538 0
 4016 0098 7B68     		ldr	r3, [r7, #4]
 4017 009a BA68     		ldr	r2, [r7, #8]
 4018 009c 1A60     		str	r2, [r3]
1539:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4019              		.loc 1 1539 0
 4020 009e 0023     		mov	r3, #0
 4021              	.L182:
1540:../Generated_Code/UTIL1.c **** }
 4022              		.loc 1 1540 0
 4023 00a0 181C     		mov	r0, r3
 4024 00a2 BD46     		mov	sp, r7
 4025 00a4 04B0     		add	sp, sp, #16
 4026              		@ sp needed for prologue
 4027 00a6 80BD     		pop	{r7, pc}
 4028              		.cfi_endproc
 4029              	.LFE34:
 4031              		.section	.text.UTIL1_ScanDecimal8sNumber,"ax",%progbits
 4032              		.align	2
 4033              		.global	UTIL1_ScanDecimal8sNumber
 4034              		.code	16
 4035              		.thumb_func
 4037              	UTIL1_ScanDecimal8sNumber:
 4038              	.LFB35:
1541:../Generated_Code/UTIL1.c **** 
1542:../Generated_Code/UTIL1.c **** /*
1543:../Generated_Code/UTIL1.c **** ** ===================================================================
1544:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal8sNumber (component Utility)
1545:../Generated_Code/UTIL1.c **** **     Description :
1546:../Generated_Code/UTIL1.c **** **         Scans a decimal 8bit signed number
1547:../Generated_Code/UTIL1.c **** **     Parameters  :
1548:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1549:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
1550:../Generated_Code/UTIL1.c **** **                           where it has scanned
1551:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1552:../Generated_Code/UTIL1.c **** **     Returns     :
1553:../Generated_Code/UTIL1.c **** **         ---             - Error code
1554:../Generated_Code/UTIL1.c **** ** ===================================================================
1555:../Generated_Code/UTIL1.c **** */
1556:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal8sNumber(const unsigned char **str, signed char *val)
1557:../Generated_Code/UTIL1.c **** {
 4039              		.loc 1 1557 0
 4040              		.cfi_startproc
 4041 0000 90B5     		push	{r4, r7, lr}
 4042              	.LCFI105:
 4043              		.cfi_def_cfa_offset 12
 4044              		.cfi_offset 4, -12
 4045              		.cfi_offset 7, -8
 4046              		.cfi_offset 14, -4
 4047 0002 87B0     		sub	sp, sp, #28
 4048              	.LCFI106:
 4049              		.cfi_def_cfa_offset 40
 4050 0004 00AF     		add	r7, sp, #0
 4051              	.LCFI107:
 4052              		.cfi_def_cfa_register 7
 4053 0006 7860     		str	r0, [r7, #4]
 4054 0008 3960     		str	r1, [r7]
1558:../Generated_Code/UTIL1.c ****   /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
1559:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4055              		.loc 1 1559 0
 4056 000a 7B68     		ldr	r3, [r7, #4]
 4057 000c 1B68     		ldr	r3, [r3]
 4058 000e 3B61     		str	r3, [r7, #16]
1560:../Generated_Code/UTIL1.c ****   bool isNeg;
1561:../Generated_Code/UTIL1.c ****   uint8_t val8u;
1562:../Generated_Code/UTIL1.c ****   uint8_t res;
1563:../Generated_Code/UTIL1.c **** 
1564:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4059              		.loc 1 1564 0
 4060 0010 02E0     		b	.L185
 4061              	.L186:
1565:../Generated_Code/UTIL1.c ****     p++;
 4062              		.loc 1 1565 0
 4063 0012 3B69     		ldr	r3, [r7, #16]
 4064 0014 0133     		add	r3, r3, #1
 4065 0016 3B61     		str	r3, [r7, #16]
 4066              	.L185:
1564:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4067              		.loc 1 1564 0
 4068 0018 3B69     		ldr	r3, [r7, #16]
 4069 001a 1B78     		ldrb	r3, [r3]
 4070 001c 202B     		cmp	r3, #32
 4071 001e F8D0     		beq	.L186
1566:../Generated_Code/UTIL1.c ****   }
1567:../Generated_Code/UTIL1.c ****   *val = 0;
 4072              		.loc 1 1567 0
 4073 0020 3B68     		ldr	r3, [r7]
 4074 0022 0022     		mov	r2, #0
 4075 0024 1A70     		strb	r2, [r3]
1568:../Generated_Code/UTIL1.c ****   if (*p=='-') {
 4076              		.loc 1 1568 0
 4077 0026 3B69     		ldr	r3, [r7, #16]
 4078 0028 1B78     		ldrb	r3, [r3]
 4079 002a 2D2B     		cmp	r3, #45
 4080 002c 07D1     		bne	.L187
1569:../Generated_Code/UTIL1.c ****     isNeg = TRUE;
 4081              		.loc 1 1569 0
 4082 002e 3B1C     		mov	r3, r7
 4083 0030 1733     		add	r3, r3, #23
 4084 0032 0122     		mov	r2, #1
 4085 0034 1A70     		strb	r2, [r3]
1570:../Generated_Code/UTIL1.c ****     p++; /* skip minus */
 4086              		.loc 1 1570 0
 4087 0036 3B69     		ldr	r3, [r7, #16]
 4088 0038 0133     		add	r3, r3, #1
 4089 003a 3B61     		str	r3, [r7, #16]
 4090 003c 03E0     		b	.L188
 4091              	.L187:
1571:../Generated_Code/UTIL1.c ****   } else {
1572:../Generated_Code/UTIL1.c ****     isNeg = FALSE;
 4092              		.loc 1 1572 0
 4093 003e 3B1C     		mov	r3, r7
 4094 0040 1733     		add	r3, r3, #23
 4095 0042 0022     		mov	r2, #0
 4096 0044 1A70     		strb	r2, [r3]
 4097              	.L188:
1573:../Generated_Code/UTIL1.c ****   }
1574:../Generated_Code/UTIL1.c ****   res = UTIL1_ScanDecimal8uNumber(&p, &val8u);
 4098              		.loc 1 1574 0
 4099 0046 3C1C     		mov	r4, r7
 4100 0048 1634     		add	r4, r4, #22
 4101 004a 3A1C     		mov	r2, r7
 4102 004c 1032     		add	r2, r2, #16
 4103 004e 3B1C     		mov	r3, r7
 4104 0050 0F33     		add	r3, r3, #15
 4105 0052 101C     		mov	r0, r2
 4106 0054 191C     		mov	r1, r3
 4107 0056 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 4108 005a 031C     		mov	r3, r0
 4109 005c 2370     		strb	r3, [r4]
1575:../Generated_Code/UTIL1.c ****   if (res != ERR_OK) {
 4110              		.loc 1 1575 0
 4111 005e 3B1C     		mov	r3, r7
 4112 0060 1633     		add	r3, r3, #22
 4113 0062 1B78     		ldrb	r3, [r3]
 4114 0064 002B     		cmp	r3, #0
 4115 0066 03D0     		beq	.L189
1576:../Generated_Code/UTIL1.c ****     return res;
 4116              		.loc 1 1576 0
 4117 0068 3B1C     		mov	r3, r7
 4118 006a 1633     		add	r3, r3, #22
 4119 006c 1B78     		ldrb	r3, [r3]
 4120 006e 17E0     		b	.L193
 4121              	.L189:
1577:../Generated_Code/UTIL1.c ****   }
1578:../Generated_Code/UTIL1.c ****   if (isNeg) {
 4122              		.loc 1 1578 0
 4123 0070 3B1C     		mov	r3, r7
 4124 0072 1733     		add	r3, r3, #23
 4125 0074 1B78     		ldrb	r3, [r3]
 4126 0076 002B     		cmp	r3, #0
 4127 0078 08D0     		beq	.L191
1579:../Generated_Code/UTIL1.c ****     *val = (int8_t)(-(int8_t)val8u);
 4128              		.loc 1 1579 0
 4129 007a 3B1C     		mov	r3, r7
 4130 007c 0F33     		add	r3, r3, #15
 4131 007e 1B78     		ldrb	r3, [r3]
 4132 0080 5B42     		neg	r3, r3
 4133 0082 DBB2     		uxtb	r3, r3
 4134 0084 DAB2     		uxtb	r2, r3
 4135 0086 3B68     		ldr	r3, [r7]
 4136 0088 1A70     		strb	r2, [r3]
 4137 008a 05E0     		b	.L192
 4138              	.L191:
1580:../Generated_Code/UTIL1.c ****   } else {
1581:../Generated_Code/UTIL1.c ****     *val = (int8_t)val8u;
 4139              		.loc 1 1581 0
 4140 008c 3B1C     		mov	r3, r7
 4141 008e 0F33     		add	r3, r3, #15
 4142 0090 1B78     		ldrb	r3, [r3]
 4143 0092 DAB2     		uxtb	r2, r3
 4144 0094 3B68     		ldr	r3, [r7]
 4145 0096 1A70     		strb	r2, [r3]
 4146              	.L192:
1582:../Generated_Code/UTIL1.c ****   }
1583:../Generated_Code/UTIL1.c ****   *str = p;
 4147              		.loc 1 1583 0
 4148 0098 3A69     		ldr	r2, [r7, #16]
 4149 009a 7B68     		ldr	r3, [r7, #4]
 4150 009c 1A60     		str	r2, [r3]
1584:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4151              		.loc 1 1584 0
 4152 009e 0023     		mov	r3, #0
 4153              	.L193:
1585:../Generated_Code/UTIL1.c **** }
 4154              		.loc 1 1585 0
 4155 00a0 181C     		mov	r0, r3
 4156 00a2 BD46     		mov	sp, r7
 4157 00a4 07B0     		add	sp, sp, #28
 4158              		@ sp needed for prologue
 4159 00a6 90BD     		pop	{r4, r7, pc}
 4160              		.cfi_endproc
 4161              	.LFE35:
 4163              		.section	.text.UTIL1_ScanDecimal16uNumber,"ax",%progbits
 4164              		.align	2
 4165              		.global	UTIL1_ScanDecimal16uNumber
 4166              		.code	16
 4167              		.thumb_func
 4169              	UTIL1_ScanDecimal16uNumber:
 4170              	.LFB36:
1586:../Generated_Code/UTIL1.c **** 
1587:../Generated_Code/UTIL1.c **** /*
1588:../Generated_Code/UTIL1.c **** ** ===================================================================
1589:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal16uNumber (component Utility)
1590:../Generated_Code/UTIL1.c **** **     Description :
1591:../Generated_Code/UTIL1.c **** **         Scans a decimal 16bit unsigned number
1592:../Generated_Code/UTIL1.c **** **     Parameters  :
1593:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1594:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
1595:../Generated_Code/UTIL1.c **** **                           where it has scanned
1596:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1597:../Generated_Code/UTIL1.c **** **     Returns     :
1598:../Generated_Code/UTIL1.c **** **         ---             - Error code
1599:../Generated_Code/UTIL1.c **** ** ===================================================================
1600:../Generated_Code/UTIL1.c **** */
1601:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal16uNumber(const unsigned char **str, uint16_t *val)
1602:../Generated_Code/UTIL1.c **** {
 4171              		.loc 1 1602 0
 4172              		.cfi_startproc
 4173 0000 80B5     		push	{r7, lr}
 4174              	.LCFI108:
 4175              		.cfi_def_cfa_offset 8
 4176              		.cfi_offset 7, -8
 4177              		.cfi_offset 14, -4
 4178 0002 84B0     		sub	sp, sp, #16
 4179              	.LCFI109:
 4180              		.cfi_def_cfa_offset 24
 4181 0004 00AF     		add	r7, sp, #0
 4182              	.LCFI110:
 4183              		.cfi_def_cfa_register 7
 4184 0006 7860     		str	r0, [r7, #4]
 4185 0008 3960     		str	r1, [r7]
1603:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1604:../Generated_Code/UTIL1.c ****   #define _16_NOF_DIGITS  (5+1)
1605:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = _16_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4186              		.loc 1 1605 0
 4187 000a 3B1C     		mov	r3, r7
 4188 000c 0F33     		add	r3, r3, #15
 4189 000e 0622     		mov	r2, #6
 4190 0010 1A70     		strb	r2, [r3]
1606:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4191              		.loc 1 1606 0
 4192 0012 7B68     		ldr	r3, [r7, #4]
 4193 0014 1B68     		ldr	r3, [r3]
 4194 0016 BB60     		str	r3, [r7, #8]
1607:../Generated_Code/UTIL1.c **** 
1608:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4195              		.loc 1 1608 0
 4196 0018 02E0     		b	.L195
 4197              	.L196:
1609:../Generated_Code/UTIL1.c ****     p++;
 4198              		.loc 1 1609 0
 4199 001a BB68     		ldr	r3, [r7, #8]
 4200 001c 0133     		add	r3, r3, #1
 4201 001e BB60     		str	r3, [r7, #8]
 4202              	.L195:
1608:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4203              		.loc 1 1608 0
 4204 0020 BB68     		ldr	r3, [r7, #8]
 4205 0022 1B78     		ldrb	r3, [r3]
 4206 0024 202B     		cmp	r3, #32
 4207 0026 F8D0     		beq	.L196
1610:../Generated_Code/UTIL1.c ****   }
1611:../Generated_Code/UTIL1.c ****   *val = 0;
 4208              		.loc 1 1611 0
 4209 0028 3B68     		ldr	r3, [r7]
 4210 002a 0022     		mov	r2, #0
 4211 002c 1A80     		strh	r2, [r3]
1612:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4212              		.loc 1 1612 0
 4213 002e 18E0     		b	.L197
 4214              	.L199:
1613:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*10 + *p-'0');
 4215              		.loc 1 1613 0
 4216 0030 3B68     		ldr	r3, [r7]
 4217 0032 1B88     		ldrh	r3, [r3]
 4218 0034 1A1C     		add	r2, r3, #0
 4219 0036 9200     		lsl	r2, r2, #2
 4220 0038 D318     		add	r3, r2, r3
 4221 003a 5B00     		lsl	r3, r3, #1
 4222 003c 9AB2     		uxth	r2, r3
 4223 003e BB68     		ldr	r3, [r7, #8]
 4224 0040 1B78     		ldrb	r3, [r3]
 4225 0042 D318     		add	r3, r2, r3
 4226 0044 9BB2     		uxth	r3, r3
 4227 0046 303B     		sub	r3, r3, #48
 4228 0048 9AB2     		uxth	r2, r3
 4229 004a 3B68     		ldr	r3, [r7]
 4230 004c 1A80     		strh	r2, [r3]
1614:../Generated_Code/UTIL1.c ****     nofDigits--;
 4231              		.loc 1 1614 0
 4232 004e 3B1C     		mov	r3, r7
 4233 0050 0F33     		add	r3, r3, #15
 4234 0052 3A1C     		mov	r2, r7
 4235 0054 0F32     		add	r2, r2, #15
 4236 0056 1278     		ldrb	r2, [r2]
 4237 0058 013A     		sub	r2, r2, #1
 4238 005a 1A70     		strb	r2, [r3]
1615:../Generated_Code/UTIL1.c ****     p++;
 4239              		.loc 1 1615 0
 4240 005c BB68     		ldr	r3, [r7, #8]
 4241 005e 0133     		add	r3, r3, #1
 4242 0060 BB60     		str	r3, [r7, #8]
 4243              	.L197:
1612:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4244              		.loc 1 1612 0
 4245 0062 BB68     		ldr	r3, [r7, #8]
 4246 0064 1B78     		ldrb	r3, [r3]
 4247 0066 2F2B     		cmp	r3, #47
 4248 0068 08D9     		bls	.L198
1612:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4249              		.loc 1 1612 0 is_stmt 0
 4250 006a BB68     		ldr	r3, [r7, #8]
 4251 006c 1B78     		ldrb	r3, [r3]
 4252 006e 392B     		cmp	r3, #57
 4253 0070 04D8     		bhi	.L198
1612:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4254              		.loc 1 1612 0
 4255 0072 3B1C     		mov	r3, r7
 4256 0074 0F33     		add	r3, r3, #15
 4257 0076 1B78     		ldrb	r3, [r3]
 4258 0078 002B     		cmp	r3, #0
 4259 007a D9D1     		bne	.L199
 4260              	.L198:
1616:../Generated_Code/UTIL1.c ****   } /* while */
1617:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4261              		.loc 1 1617 0 is_stmt 1
 4262 007c 3B1C     		mov	r3, r7
 4263 007e 0F33     		add	r3, r3, #15
 4264 0080 1B78     		ldrb	r3, [r3]
 4265 0082 002B     		cmp	r3, #0
 4266 0084 01D1     		bne	.L200
1618:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4267              		.loc 1 1618 0
 4268 0086 0423     		mov	r3, #4
 4269 0088 0AE0     		b	.L201
 4270              	.L200:
1619:../Generated_Code/UTIL1.c ****   }
1620:../Generated_Code/UTIL1.c ****   if (nofDigits==_16_NOF_DIGITS) { /* no digits at all? */
 4271              		.loc 1 1620 0
 4272 008a 3B1C     		mov	r3, r7
 4273 008c 0F33     		add	r3, r3, #15
 4274 008e 1B78     		ldrb	r3, [r3]
 4275 0090 062B     		cmp	r3, #6
 4276 0092 01D1     		bne	.L202
1621:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4277              		.loc 1 1621 0
 4278 0094 1B23     		mov	r3, #27
 4279 0096 03E0     		b	.L201
 4280              	.L202:
1622:../Generated_Code/UTIL1.c ****   }
1623:../Generated_Code/UTIL1.c ****   *str = p;
 4281              		.loc 1 1623 0
 4282 0098 7B68     		ldr	r3, [r7, #4]
 4283 009a BA68     		ldr	r2, [r7, #8]
 4284 009c 1A60     		str	r2, [r3]
1624:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4285              		.loc 1 1624 0
 4286 009e 0023     		mov	r3, #0
 4287              	.L201:
1625:../Generated_Code/UTIL1.c **** }
 4288              		.loc 1 1625 0
 4289 00a0 181C     		mov	r0, r3
 4290 00a2 BD46     		mov	sp, r7
 4291 00a4 04B0     		add	sp, sp, #16
 4292              		@ sp needed for prologue
 4293 00a6 80BD     		pop	{r7, pc}
 4294              		.cfi_endproc
 4295              	.LFE36:
 4297              		.section	.text.UTIL1_ScanDecimal16sNumber,"ax",%progbits
 4298              		.align	2
 4299              		.global	UTIL1_ScanDecimal16sNumber
 4300              		.code	16
 4301              		.thumb_func
 4303              	UTIL1_ScanDecimal16sNumber:
 4304              	.LFB37:
1626:../Generated_Code/UTIL1.c **** 
1627:../Generated_Code/UTIL1.c **** /*
1628:../Generated_Code/UTIL1.c **** ** ===================================================================
1629:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal16sNumber (component Utility)
1630:../Generated_Code/UTIL1.c **** **     Description :
1631:../Generated_Code/UTIL1.c **** **         Scans a decimal 16bit signed number
1632:../Generated_Code/UTIL1.c **** **     Parameters  :
1633:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1634:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
1635:../Generated_Code/UTIL1.c **** **                           where it has scanned
1636:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1637:../Generated_Code/UTIL1.c **** **     Returns     :
1638:../Generated_Code/UTIL1.c **** **         ---             - Error code
1639:../Generated_Code/UTIL1.c **** ** ===================================================================
1640:../Generated_Code/UTIL1.c **** */
1641:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal16sNumber(const unsigned char **str, int16_t *val)
1642:../Generated_Code/UTIL1.c **** {
 4305              		.loc 1 1642 0
 4306              		.cfi_startproc
 4307 0000 90B5     		push	{r4, r7, lr}
 4308              	.LCFI111:
 4309              		.cfi_def_cfa_offset 12
 4310              		.cfi_offset 4, -12
 4311              		.cfi_offset 7, -8
 4312              		.cfi_offset 14, -4
 4313 0002 87B0     		sub	sp, sp, #28
 4314              	.LCFI112:
 4315              		.cfi_def_cfa_offset 40
 4316 0004 00AF     		add	r7, sp, #0
 4317              	.LCFI113:
 4318              		.cfi_def_cfa_register 7
 4319 0006 7860     		str	r0, [r7, #4]
 4320 0008 3960     		str	r1, [r7]
1643:../Generated_Code/UTIL1.c ****   /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
1644:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4321              		.loc 1 1644 0
 4322 000a 7B68     		ldr	r3, [r7, #4]
 4323 000c 1B68     		ldr	r3, [r3]
 4324 000e 3B61     		str	r3, [r7, #16]
1645:../Generated_Code/UTIL1.c ****   bool isNeg;
1646:../Generated_Code/UTIL1.c ****   uint16_t val16u;
1647:../Generated_Code/UTIL1.c ****   uint8_t res;
1648:../Generated_Code/UTIL1.c **** 
1649:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4325              		.loc 1 1649 0
 4326 0010 02E0     		b	.L204
 4327              	.L205:
1650:../Generated_Code/UTIL1.c ****     p++;
 4328              		.loc 1 1650 0
 4329 0012 3B69     		ldr	r3, [r7, #16]
 4330 0014 0133     		add	r3, r3, #1
 4331 0016 3B61     		str	r3, [r7, #16]
 4332              	.L204:
1649:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4333              		.loc 1 1649 0
 4334 0018 3B69     		ldr	r3, [r7, #16]
 4335 001a 1B78     		ldrb	r3, [r3]
 4336 001c 202B     		cmp	r3, #32
 4337 001e F8D0     		beq	.L205
1651:../Generated_Code/UTIL1.c ****   }
1652:../Generated_Code/UTIL1.c ****   *val = 0;
 4338              		.loc 1 1652 0
 4339 0020 3B68     		ldr	r3, [r7]
 4340 0022 0022     		mov	r2, #0
 4341 0024 1A80     		strh	r2, [r3]
1653:../Generated_Code/UTIL1.c ****   if (*p=='-') {
 4342              		.loc 1 1653 0
 4343 0026 3B69     		ldr	r3, [r7, #16]
 4344 0028 1B78     		ldrb	r3, [r3]
 4345 002a 2D2B     		cmp	r3, #45
 4346 002c 07D1     		bne	.L206
1654:../Generated_Code/UTIL1.c ****     isNeg = TRUE;
 4347              		.loc 1 1654 0
 4348 002e 3B1C     		mov	r3, r7
 4349 0030 1733     		add	r3, r3, #23
 4350 0032 0122     		mov	r2, #1
 4351 0034 1A70     		strb	r2, [r3]
1655:../Generated_Code/UTIL1.c ****     p++; /* skip minus */
 4352              		.loc 1 1655 0
 4353 0036 3B69     		ldr	r3, [r7, #16]
 4354 0038 0133     		add	r3, r3, #1
 4355 003a 3B61     		str	r3, [r7, #16]
 4356 003c 03E0     		b	.L207
 4357              	.L206:
1656:../Generated_Code/UTIL1.c ****   } else {
1657:../Generated_Code/UTIL1.c ****     isNeg = FALSE;
 4358              		.loc 1 1657 0
 4359 003e 3B1C     		mov	r3, r7
 4360 0040 1733     		add	r3, r3, #23
 4361 0042 0022     		mov	r2, #0
 4362 0044 1A70     		strb	r2, [r3]
 4363              	.L207:
1658:../Generated_Code/UTIL1.c ****   }
1659:../Generated_Code/UTIL1.c ****   res = UTIL1_ScanDecimal16uNumber(&p, (uint16_t*)&val16u);
 4364              		.loc 1 1659 0
 4365 0046 3C1C     		mov	r4, r7
 4366 0048 1634     		add	r4, r4, #22
 4367 004a 3A1C     		mov	r2, r7
 4368 004c 1032     		add	r2, r2, #16
 4369 004e 3B1C     		mov	r3, r7
 4370 0050 0E33     		add	r3, r3, #14
 4371 0052 101C     		mov	r0, r2
 4372 0054 191C     		mov	r1, r3
 4373 0056 FFF7FEFF 		bl	UTIL1_ScanDecimal16uNumber
 4374 005a 031C     		mov	r3, r0
 4375 005c 2370     		strb	r3, [r4]
1660:../Generated_Code/UTIL1.c ****   if (res != ERR_OK) {
 4376              		.loc 1 1660 0
 4377 005e 3B1C     		mov	r3, r7
 4378 0060 1633     		add	r3, r3, #22
 4379 0062 1B78     		ldrb	r3, [r3]
 4380 0064 002B     		cmp	r3, #0
 4381 0066 03D0     		beq	.L208
1661:../Generated_Code/UTIL1.c ****     return res;
 4382              		.loc 1 1661 0
 4383 0068 3B1C     		mov	r3, r7
 4384 006a 1633     		add	r3, r3, #22
 4385 006c 1B78     		ldrb	r3, [r3]
 4386 006e 17E0     		b	.L212
 4387              	.L208:
1662:../Generated_Code/UTIL1.c ****   }
1663:../Generated_Code/UTIL1.c ****   if (isNeg) {
 4388              		.loc 1 1663 0
 4389 0070 3B1C     		mov	r3, r7
 4390 0072 1733     		add	r3, r3, #23
 4391 0074 1B78     		ldrb	r3, [r3]
 4392 0076 002B     		cmp	r3, #0
 4393 0078 08D0     		beq	.L210
1664:../Generated_Code/UTIL1.c ****     *val = (int16_t)(-(int16_t)val16u);
 4394              		.loc 1 1664 0
 4395 007a 3B1C     		mov	r3, r7
 4396 007c 0E33     		add	r3, r3, #14
 4397 007e 1B88     		ldrh	r3, [r3]
 4398 0080 5B42     		neg	r3, r3
 4399 0082 9BB2     		uxth	r3, r3
 4400 0084 9AB2     		uxth	r2, r3
 4401 0086 3B68     		ldr	r3, [r7]
 4402 0088 1A80     		strh	r2, [r3]
 4403 008a 05E0     		b	.L211
 4404              	.L210:
1665:../Generated_Code/UTIL1.c ****   } else {
1666:../Generated_Code/UTIL1.c ****     *val = (int16_t)val16u;
 4405              		.loc 1 1666 0
 4406 008c 3B1C     		mov	r3, r7
 4407 008e 0E33     		add	r3, r3, #14
 4408 0090 1B88     		ldrh	r3, [r3]
 4409 0092 9AB2     		uxth	r2, r3
 4410 0094 3B68     		ldr	r3, [r7]
 4411 0096 1A80     		strh	r2, [r3]
 4412              	.L211:
1667:../Generated_Code/UTIL1.c ****   }
1668:../Generated_Code/UTIL1.c ****   *str = p;
 4413              		.loc 1 1668 0
 4414 0098 3A69     		ldr	r2, [r7, #16]
 4415 009a 7B68     		ldr	r3, [r7, #4]
 4416 009c 1A60     		str	r2, [r3]
1669:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4417              		.loc 1 1669 0
 4418 009e 0023     		mov	r3, #0
 4419              	.L212:
1670:../Generated_Code/UTIL1.c **** }
 4420              		.loc 1 1670 0
 4421 00a0 181C     		mov	r0, r3
 4422 00a2 BD46     		mov	sp, r7
 4423 00a4 07B0     		add	sp, sp, #28
 4424              		@ sp needed for prologue
 4425 00a6 90BD     		pop	{r4, r7, pc}
 4426              		.cfi_endproc
 4427              	.LFE37:
 4429              		.section	.text.UTIL1_ScanDecimal32uNumber,"ax",%progbits
 4430              		.align	2
 4431              		.global	UTIL1_ScanDecimal32uNumber
 4432              		.code	16
 4433              		.thumb_func
 4435              	UTIL1_ScanDecimal32uNumber:
 4436              	.LFB38:
1671:../Generated_Code/UTIL1.c **** 
1672:../Generated_Code/UTIL1.c **** /*
1673:../Generated_Code/UTIL1.c **** ** ===================================================================
1674:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal32uNumber (component Utility)
1675:../Generated_Code/UTIL1.c **** **     Description :
1676:../Generated_Code/UTIL1.c **** **         Scans a decimal 32bit unsigned number
1677:../Generated_Code/UTIL1.c **** **     Parameters  :
1678:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1679:../Generated_Code/UTIL1.c **** **         str             - string to scan. It returns as well until
1680:../Generated_Code/UTIL1.c **** **                           where it has scanned
1681:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1682:../Generated_Code/UTIL1.c **** **     Returns     :
1683:../Generated_Code/UTIL1.c **** **         ---             - Error code
1684:../Generated_Code/UTIL1.c **** ** ===================================================================
1685:../Generated_Code/UTIL1.c **** */
1686:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal32uNumber(const unsigned char **str, uint32_t *val)
1687:../Generated_Code/UTIL1.c **** {
 4437              		.loc 1 1687 0
 4438              		.cfi_startproc
 4439 0000 80B5     		push	{r7, lr}
 4440              	.LCFI114:
 4441              		.cfi_def_cfa_offset 8
 4442              		.cfi_offset 7, -8
 4443              		.cfi_offset 14, -4
 4444 0002 84B0     		sub	sp, sp, #16
 4445              	.LCFI115:
 4446              		.cfi_def_cfa_offset 24
 4447 0004 00AF     		add	r7, sp, #0
 4448              	.LCFI116:
 4449              		.cfi_def_cfa_register 7
 4450 0006 7860     		str	r0, [r7, #4]
 4451 0008 3960     		str	r1, [r7]
1688:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1689:../Generated_Code/UTIL1.c ****   #define _32_NOF_DIGITS  (10+1)
1690:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = _32_NOF_DIGITS; /* maximum number of digits to avoid overflow */
 4452              		.loc 1 1690 0
 4453 000a 3B1C     		mov	r3, r7
 4454 000c 0F33     		add	r3, r3, #15
 4455 000e 0B22     		mov	r2, #11
 4456 0010 1A70     		strb	r2, [r3]
1691:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4457              		.loc 1 1691 0
 4458 0012 7B68     		ldr	r3, [r7, #4]
 4459 0014 1B68     		ldr	r3, [r3]
 4460 0016 BB60     		str	r3, [r7, #8]
1692:../Generated_Code/UTIL1.c **** 
1693:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4461              		.loc 1 1693 0
 4462 0018 02E0     		b	.L214
 4463              	.L215:
1694:../Generated_Code/UTIL1.c ****     p++;
 4464              		.loc 1 1694 0
 4465 001a BB68     		ldr	r3, [r7, #8]
 4466 001c 0133     		add	r3, r3, #1
 4467 001e BB60     		str	r3, [r7, #8]
 4468              	.L214:
1693:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4469              		.loc 1 1693 0
 4470 0020 BB68     		ldr	r3, [r7, #8]
 4471 0022 1B78     		ldrb	r3, [r3]
 4472 0024 202B     		cmp	r3, #32
 4473 0026 F8D0     		beq	.L215
1695:../Generated_Code/UTIL1.c ****   }
1696:../Generated_Code/UTIL1.c ****   *val = 0;
 4474              		.loc 1 1696 0
 4475 0028 3B68     		ldr	r3, [r7]
 4476 002a 0022     		mov	r2, #0
 4477 002c 1A60     		str	r2, [r3]
1697:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4478              		.loc 1 1697 0
 4479 002e 17E0     		b	.L216
 4480              	.L218:
1698:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*10 + *p-'0');
 4481              		.loc 1 1698 0
 4482 0030 3B68     		ldr	r3, [r7]
 4483 0032 1A68     		ldr	r2, [r3]
 4484 0034 131C     		mov	r3, r2
 4485 0036 9B00     		lsl	r3, r3, #2
 4486 0038 9B18     		add	r3, r3, r2
 4487 003a 5B00     		lsl	r3, r3, #1
 4488 003c 1A1C     		mov	r2, r3
 4489 003e BB68     		ldr	r3, [r7, #8]
 4490 0040 1B78     		ldrb	r3, [r3]
 4491 0042 D318     		add	r3, r2, r3
 4492 0044 1A1C     		mov	r2, r3
 4493 0046 303A     		sub	r2, r2, #48
 4494 0048 3B68     		ldr	r3, [r7]
 4495 004a 1A60     		str	r2, [r3]
1699:../Generated_Code/UTIL1.c ****     nofDigits--;
 4496              		.loc 1 1699 0
 4497 004c 3B1C     		mov	r3, r7
 4498 004e 0F33     		add	r3, r3, #15
 4499 0050 3A1C     		mov	r2, r7
 4500 0052 0F32     		add	r2, r2, #15
 4501 0054 1278     		ldrb	r2, [r2]
 4502 0056 013A     		sub	r2, r2, #1
 4503 0058 1A70     		strb	r2, [r3]
1700:../Generated_Code/UTIL1.c ****     p++;
 4504              		.loc 1 1700 0
 4505 005a BB68     		ldr	r3, [r7, #8]
 4506 005c 0133     		add	r3, r3, #1
 4507 005e BB60     		str	r3, [r7, #8]
 4508              	.L216:
1697:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4509              		.loc 1 1697 0
 4510 0060 BB68     		ldr	r3, [r7, #8]
 4511 0062 1B78     		ldrb	r3, [r3]
 4512 0064 2F2B     		cmp	r3, #47
 4513 0066 08D9     		bls	.L217
1697:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4514              		.loc 1 1697 0 is_stmt 0
 4515 0068 BB68     		ldr	r3, [r7, #8]
 4516 006a 1B78     		ldrb	r3, [r3]
 4517 006c 392B     		cmp	r3, #57
 4518 006e 04D8     		bhi	.L217
1697:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 4519              		.loc 1 1697 0
 4520 0070 3B1C     		mov	r3, r7
 4521 0072 0F33     		add	r3, r3, #15
 4522 0074 1B78     		ldrb	r3, [r3]
 4523 0076 002B     		cmp	r3, #0
 4524 0078 DAD1     		bne	.L218
 4525              	.L217:
1701:../Generated_Code/UTIL1.c ****   } /* while */
1702:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 4526              		.loc 1 1702 0 is_stmt 1
 4527 007a 3B1C     		mov	r3, r7
 4528 007c 0F33     		add	r3, r3, #15
 4529 007e 1B78     		ldrb	r3, [r3]
 4530 0080 002B     		cmp	r3, #0
 4531 0082 01D1     		bne	.L219
1703:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 4532              		.loc 1 1703 0
 4533 0084 0423     		mov	r3, #4
 4534 0086 0AE0     		b	.L220
 4535              	.L219:
1704:../Generated_Code/UTIL1.c ****   }
1705:../Generated_Code/UTIL1.c ****   if (nofDigits==_32_NOF_DIGITS) { /* no digits at all? */
 4536              		.loc 1 1705 0
 4537 0088 3B1C     		mov	r3, r7
 4538 008a 0F33     		add	r3, r3, #15
 4539 008c 1B78     		ldrb	r3, [r3]
 4540 008e 0B2B     		cmp	r3, #11
 4541 0090 01D1     		bne	.L221
1706:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4542              		.loc 1 1706 0
 4543 0092 1B23     		mov	r3, #27
 4544 0094 03E0     		b	.L220
 4545              	.L221:
1707:../Generated_Code/UTIL1.c ****   }
1708:../Generated_Code/UTIL1.c ****   *str = p;
 4546              		.loc 1 1708 0
 4547 0096 7B68     		ldr	r3, [r7, #4]
 4548 0098 BA68     		ldr	r2, [r7, #8]
 4549 009a 1A60     		str	r2, [r3]
1709:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4550              		.loc 1 1709 0
 4551 009c 0023     		mov	r3, #0
 4552              	.L220:
1710:../Generated_Code/UTIL1.c **** }
 4553              		.loc 1 1710 0
 4554 009e 181C     		mov	r0, r3
 4555 00a0 BD46     		mov	sp, r7
 4556 00a2 04B0     		add	sp, sp, #16
 4557              		@ sp needed for prologue
 4558 00a4 80BD     		pop	{r7, pc}
 4559              		.cfi_endproc
 4560              	.LFE38:
 4562 00a6 C046     		.section	.text.UTIL1_ScanDecimal32sNumber,"ax",%progbits
 4563              		.align	2
 4564              		.global	UTIL1_ScanDecimal32sNumber
 4565              		.code	16
 4566              		.thumb_func
 4568              	UTIL1_ScanDecimal32sNumber:
 4569              	.LFB39:
1711:../Generated_Code/UTIL1.c **** 
1712:../Generated_Code/UTIL1.c **** /*
1713:../Generated_Code/UTIL1.c **** ** ===================================================================
1714:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal32sNumber (component Utility)
1715:../Generated_Code/UTIL1.c **** **     Description :
1716:../Generated_Code/UTIL1.c **** **         Scans a decimal 32bit signed number
1717:../Generated_Code/UTIL1.c **** **     Parameters  :
1718:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1719:../Generated_Code/UTIL1.c **** **         str             - string to scan. It returns as well until
1720:../Generated_Code/UTIL1.c **** **                           where it has scanned
1721:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1722:../Generated_Code/UTIL1.c **** **     Returns     :
1723:../Generated_Code/UTIL1.c **** **         ---             - Error code
1724:../Generated_Code/UTIL1.c **** ** ===================================================================
1725:../Generated_Code/UTIL1.c **** */
1726:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal32sNumber(const unsigned char **str, int32_t *val)
1727:../Generated_Code/UTIL1.c **** {
 4570              		.loc 1 1727 0
 4571              		.cfi_startproc
 4572 0000 90B5     		push	{r4, r7, lr}
 4573              	.LCFI117:
 4574              		.cfi_def_cfa_offset 12
 4575              		.cfi_offset 4, -12
 4576              		.cfi_offset 7, -8
 4577              		.cfi_offset 14, -4
 4578 0002 87B0     		sub	sp, sp, #28
 4579              	.LCFI118:
 4580              		.cfi_def_cfa_offset 40
 4581 0004 00AF     		add	r7, sp, #0
 4582              	.LCFI119:
 4583              		.cfi_def_cfa_register 7
 4584 0006 7860     		str	r0, [r7, #4]
 4585 0008 3960     		str	r1, [r7]
1728:../Generated_Code/UTIL1.c ****   /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
1729:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4586              		.loc 1 1729 0
 4587 000a 7B68     		ldr	r3, [r7, #4]
 4588 000c 1B68     		ldr	r3, [r3]
 4589 000e 3B61     		str	r3, [r7, #16]
1730:../Generated_Code/UTIL1.c ****   bool isNeg;
1731:../Generated_Code/UTIL1.c ****   uint32_t val32u;
1732:../Generated_Code/UTIL1.c ****   uint8_t res;
1733:../Generated_Code/UTIL1.c **** 
1734:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4590              		.loc 1 1734 0
 4591 0010 02E0     		b	.L223
 4592              	.L224:
1735:../Generated_Code/UTIL1.c ****     p++;
 4593              		.loc 1 1735 0
 4594 0012 3B69     		ldr	r3, [r7, #16]
 4595 0014 0133     		add	r3, r3, #1
 4596 0016 3B61     		str	r3, [r7, #16]
 4597              	.L223:
1734:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4598              		.loc 1 1734 0
 4599 0018 3B69     		ldr	r3, [r7, #16]
 4600 001a 1B78     		ldrb	r3, [r3]
 4601 001c 202B     		cmp	r3, #32
 4602 001e F8D0     		beq	.L224
1736:../Generated_Code/UTIL1.c ****   }
1737:../Generated_Code/UTIL1.c ****   *val = 0;
 4603              		.loc 1 1737 0
 4604 0020 3B68     		ldr	r3, [r7]
 4605 0022 0022     		mov	r2, #0
 4606 0024 1A60     		str	r2, [r3]
1738:../Generated_Code/UTIL1.c ****   if (*p=='-') {
 4607              		.loc 1 1738 0
 4608 0026 3B69     		ldr	r3, [r7, #16]
 4609 0028 1B78     		ldrb	r3, [r3]
 4610 002a 2D2B     		cmp	r3, #45
 4611 002c 07D1     		bne	.L225
1739:../Generated_Code/UTIL1.c ****     isNeg = TRUE;
 4612              		.loc 1 1739 0
 4613 002e 3B1C     		mov	r3, r7
 4614 0030 1733     		add	r3, r3, #23
 4615 0032 0122     		mov	r2, #1
 4616 0034 1A70     		strb	r2, [r3]
1740:../Generated_Code/UTIL1.c ****     p++; /* skip minus */
 4617              		.loc 1 1740 0
 4618 0036 3B69     		ldr	r3, [r7, #16]
 4619 0038 0133     		add	r3, r3, #1
 4620 003a 3B61     		str	r3, [r7, #16]
 4621 003c 03E0     		b	.L226
 4622              	.L225:
1741:../Generated_Code/UTIL1.c ****   } else {
1742:../Generated_Code/UTIL1.c ****     isNeg = FALSE;
 4623              		.loc 1 1742 0
 4624 003e 3B1C     		mov	r3, r7
 4625 0040 1733     		add	r3, r3, #23
 4626 0042 0022     		mov	r2, #0
 4627 0044 1A70     		strb	r2, [r3]
 4628              	.L226:
1743:../Generated_Code/UTIL1.c ****   }
1744:../Generated_Code/UTIL1.c ****   res = UTIL1_ScanDecimal32uNumber(&p, &val32u);
 4629              		.loc 1 1744 0
 4630 0046 3C1C     		mov	r4, r7
 4631 0048 1634     		add	r4, r4, #22
 4632 004a 3A1C     		mov	r2, r7
 4633 004c 1032     		add	r2, r2, #16
 4634 004e 3B1C     		mov	r3, r7
 4635 0050 0C33     		add	r3, r3, #12
 4636 0052 101C     		mov	r0, r2
 4637 0054 191C     		mov	r1, r3
 4638 0056 FFF7FEFF 		bl	UTIL1_ScanDecimal32uNumber
 4639 005a 031C     		mov	r3, r0
 4640 005c 2370     		strb	r3, [r4]
1745:../Generated_Code/UTIL1.c ****   if (res != ERR_OK) {
 4641              		.loc 1 1745 0
 4642 005e 3B1C     		mov	r3, r7
 4643 0060 1633     		add	r3, r3, #22
 4644 0062 1B78     		ldrb	r3, [r3]
 4645 0064 002B     		cmp	r3, #0
 4646 0066 03D0     		beq	.L227
1746:../Generated_Code/UTIL1.c ****     return res;
 4647              		.loc 1 1746 0
 4648 0068 3B1C     		mov	r3, r7
 4649 006a 1633     		add	r3, r3, #22
 4650 006c 1B78     		ldrb	r3, [r3]
 4651 006e 11E0     		b	.L231
 4652              	.L227:
1747:../Generated_Code/UTIL1.c ****   }
1748:../Generated_Code/UTIL1.c ****   if (isNeg) {
 4653              		.loc 1 1748 0
 4654 0070 3B1C     		mov	r3, r7
 4655 0072 1733     		add	r3, r3, #23
 4656 0074 1B78     		ldrb	r3, [r3]
 4657 0076 002B     		cmp	r3, #0
 4658 0078 04D0     		beq	.L229
1749:../Generated_Code/UTIL1.c ****     *val = (int32_t)(-(int32_t)val32u);
 4659              		.loc 1 1749 0
 4660 007a FB68     		ldr	r3, [r7, #12]
 4661 007c 5A42     		neg	r2, r3
 4662 007e 3B68     		ldr	r3, [r7]
 4663 0080 1A60     		str	r2, [r3]
 4664 0082 03E0     		b	.L230
 4665              	.L229:
1750:../Generated_Code/UTIL1.c ****   } else {
1751:../Generated_Code/UTIL1.c ****     *val = (int32_t)val32u;
 4666              		.loc 1 1751 0
 4667 0084 FB68     		ldr	r3, [r7, #12]
 4668 0086 1A1C     		mov	r2, r3
 4669 0088 3B68     		ldr	r3, [r7]
 4670 008a 1A60     		str	r2, [r3]
 4671              	.L230:
1752:../Generated_Code/UTIL1.c ****   }
1753:../Generated_Code/UTIL1.c ****   *str = p;
 4672              		.loc 1 1753 0
 4673 008c 3A69     		ldr	r2, [r7, #16]
 4674 008e 7B68     		ldr	r3, [r7, #4]
 4675 0090 1A60     		str	r2, [r3]
1754:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4676              		.loc 1 1754 0
 4677 0092 0023     		mov	r3, #0
 4678              	.L231:
1755:../Generated_Code/UTIL1.c **** }
 4679              		.loc 1 1755 0
 4680 0094 181C     		mov	r0, r3
 4681 0096 BD46     		mov	sp, r7
 4682 0098 07B0     		add	sp, sp, #28
 4683              		@ sp needed for prologue
 4684 009a 90BD     		pop	{r4, r7, pc}
 4685              		.cfi_endproc
 4686              	.LFE39:
 4688              		.section	.text.UTIL1_ScanDecimal32sDotNumber,"ax",%progbits
 4689              		.align	2
 4690              		.global	UTIL1_ScanDecimal32sDotNumber
 4691              		.code	16
 4692              		.thumb_func
 4694              	UTIL1_ScanDecimal32sDotNumber:
 4695              	.LFB40:
1756:../Generated_Code/UTIL1.c **** 
1757:../Generated_Code/UTIL1.c **** /*
1758:../Generated_Code/UTIL1.c **** ** ===================================================================
1759:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal32sDotNumber (component Utility)
1760:../Generated_Code/UTIL1.c **** **     Description :
1761:../Generated_Code/UTIL1.c **** **         Scans a decimal 32bit signed number with a following dot
1762:../Generated_Code/UTIL1.c **** **         (fractional part), e.g. "-34587.0248", it will return the
1763:../Generated_Code/UTIL1.c **** **         (signed) integral and fractional part with number of
1764:../Generated_Code/UTIL1.c **** **         fractional zeros. The function accepts as well numbers  like
1765:../Generated_Code/UTIL1.c **** **         "17" (no fractional part" or "17.0" 
1766:../Generated_Code/UTIL1.c **** **     Parameters  :
1767:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1768:../Generated_Code/UTIL1.c **** **         str             - string to scan. It returns as well until
1769:../Generated_Code/UTIL1.c **** **                           where it has scanned
1770:../Generated_Code/UTIL1.c **** **       * integral        - Pointer to value before the dot
1771:../Generated_Code/UTIL1.c **** **       * fractional      - Pointer to value after the
1772:../Generated_Code/UTIL1.c **** **                           dot, e.g. 32 for "-134.0032"
1773:../Generated_Code/UTIL1.c **** **         nofFractionalZeros - Number of
1774:../Generated_Code/UTIL1.c **** **                           fractional leading zeros, e.g. 2 for "-134.
1775:../Generated_Code/UTIL1.c **** **                           0032"
1776:../Generated_Code/UTIL1.c **** **     Returns     :
1777:../Generated_Code/UTIL1.c **** **         ---             - Error code
1778:../Generated_Code/UTIL1.c **** ** ===================================================================
1779:../Generated_Code/UTIL1.c **** */
1780:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDecimal32sDotNumber(const unsigned char **str, int32_t *integral, uint32_t *fract
1781:../Generated_Code/UTIL1.c **** {
 4696              		.loc 1 1781 0
 4697              		.cfi_startproc
 4698 0000 90B5     		push	{r4, r7, lr}
 4699              	.LCFI120:
 4700              		.cfi_def_cfa_offset 12
 4701              		.cfi_offset 4, -12
 4702              		.cfi_offset 7, -8
 4703              		.cfi_offset 14, -4
 4704 0002 87B0     		sub	sp, sp, #28
 4705              	.LCFI121:
 4706              		.cfi_def_cfa_offset 40
 4707 0004 00AF     		add	r7, sp, #0
 4708              	.LCFI122:
 4709              		.cfi_def_cfa_register 7
 4710 0006 F860     		str	r0, [r7, #12]
 4711 0008 B960     		str	r1, [r7, #8]
 4712 000a 7A60     		str	r2, [r7, #4]
 4713 000c 3B60     		str	r3, [r7]
1782:../Generated_Code/UTIL1.c ****   /* scans e.g. "-3445.071" and returns -3445 in integral part, and 71 in fractional part */
1783:../Generated_Code/UTIL1.c ****   uint8_t res;
1784:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4714              		.loc 1 1784 0
 4715 000e FB68     		ldr	r3, [r7, #12]
 4716 0010 1B68     		ldr	r3, [r3]
 4717 0012 3B61     		str	r3, [r7, #16]
1785:../Generated_Code/UTIL1.c **** 
1786:../Generated_Code/UTIL1.c ****   *integral = 0;
 4718              		.loc 1 1786 0
 4719 0014 BB68     		ldr	r3, [r7, #8]
 4720 0016 0022     		mov	r2, #0
 4721 0018 1A60     		str	r2, [r3]
1787:../Generated_Code/UTIL1.c ****   *fractional = 0;
 4722              		.loc 1 1787 0
 4723 001a 7B68     		ldr	r3, [r7, #4]
 4724 001c 0022     		mov	r2, #0
 4725 001e 1A60     		str	r2, [r3]
1788:../Generated_Code/UTIL1.c ****   *nofFractionalZeros = 0;
 4726              		.loc 1 1788 0
 4727 0020 3B68     		ldr	r3, [r7]
 4728 0022 0022     		mov	r2, #0
 4729 0024 1A70     		strb	r2, [r3]
1789:../Generated_Code/UTIL1.c ****   res = UTIL1_ScanDecimal32sNumber(&p, integral);
 4730              		.loc 1 1789 0
 4731 0026 3C1C     		mov	r4, r7
 4732 0028 1734     		add	r4, r4, #23
 4733 002a 3A1C     		mov	r2, r7
 4734 002c 1032     		add	r2, r2, #16
 4735 002e BB68     		ldr	r3, [r7, #8]
 4736 0030 101C     		mov	r0, r2
 4737 0032 191C     		mov	r1, r3
 4738 0034 FFF7FEFF 		bl	UTIL1_ScanDecimal32sNumber
 4739 0038 031C     		mov	r3, r0
 4740 003a 2370     		strb	r3, [r4]
1790:../Generated_Code/UTIL1.c ****   if (res != ERR_OK) {
 4741              		.loc 1 1790 0
 4742 003c 3B1C     		mov	r3, r7
 4743 003e 1733     		add	r3, r3, #23
 4744 0040 1B78     		ldrb	r3, [r3]
 4745 0042 002B     		cmp	r3, #0
 4746 0044 03D0     		beq	.L233
1791:../Generated_Code/UTIL1.c ****     return res;
 4747              		.loc 1 1791 0
 4748 0046 3B1C     		mov	r3, r7
 4749 0048 1733     		add	r3, r3, #23
 4750 004a 1B78     		ldrb	r3, [r3]
 4751 004c 34E0     		b	.L238
 4752              	.L233:
1792:../Generated_Code/UTIL1.c ****   }
1793:../Generated_Code/UTIL1.c ****   if (*p=='.') {
 4753              		.loc 1 1793 0
 4754 004e 3B69     		ldr	r3, [r7, #16]
 4755 0050 1B78     		ldrb	r3, [r3]
 4756 0052 2E2B     		cmp	r3, #46
 4757 0054 2CD1     		bne	.L235
1794:../Generated_Code/UTIL1.c ****     p++; /* skip '.' */
 4758              		.loc 1 1794 0
 4759 0056 3B69     		ldr	r3, [r7, #16]
 4760 0058 0133     		add	r3, r3, #1
 4761 005a 3B61     		str	r3, [r7, #16]
1795:../Generated_Code/UTIL1.c ****     while (*p=='0') { /* count leading zeros */
 4762              		.loc 1 1795 0
 4763 005c 08E0     		b	.L236
 4764              	.L237:
1796:../Generated_Code/UTIL1.c ****       (*nofFractionalZeros)++;
 4765              		.loc 1 1796 0
 4766 005e 3B68     		ldr	r3, [r7]
 4767 0060 1B78     		ldrb	r3, [r3]
 4768 0062 0133     		add	r3, r3, #1
 4769 0064 DAB2     		uxtb	r2, r3
 4770 0066 3B68     		ldr	r3, [r7]
 4771 0068 1A70     		strb	r2, [r3]
1797:../Generated_Code/UTIL1.c ****       p++; /* skip leading zero */
 4772              		.loc 1 1797 0
 4773 006a 3B69     		ldr	r3, [r7, #16]
 4774 006c 0133     		add	r3, r3, #1
 4775 006e 3B61     		str	r3, [r7, #16]
 4776              	.L236:
1795:../Generated_Code/UTIL1.c ****     while (*p=='0') { /* count leading zeros */
 4777              		.loc 1 1795 0
 4778 0070 3B69     		ldr	r3, [r7, #16]
 4779 0072 1B78     		ldrb	r3, [r3]
 4780 0074 302B     		cmp	r3, #48
 4781 0076 F2D0     		beq	.L237
1798:../Generated_Code/UTIL1.c ****     }
1799:../Generated_Code/UTIL1.c ****     if (*p>='0' && *p<='9') { /* number */
 4782              		.loc 1 1799 0
 4783 0078 3B69     		ldr	r3, [r7, #16]
 4784 007a 1B78     		ldrb	r3, [r3]
 4785 007c 2F2B     		cmp	r3, #47
 4786 007e 17D9     		bls	.L235
 4787              		.loc 1 1799 0 is_stmt 0
 4788 0080 3B69     		ldr	r3, [r7, #16]
 4789 0082 1B78     		ldrb	r3, [r3]
 4790 0084 392B     		cmp	r3, #57
 4791 0086 13D8     		bhi	.L235
1800:../Generated_Code/UTIL1.c ****       res = UTIL1_ScanDecimal32uNumber(&p, fractional);
 4792              		.loc 1 1800 0 is_stmt 1
 4793 0088 3C1C     		mov	r4, r7
 4794 008a 1734     		add	r4, r4, #23
 4795 008c 3A1C     		mov	r2, r7
 4796 008e 1032     		add	r2, r2, #16
 4797 0090 7B68     		ldr	r3, [r7, #4]
 4798 0092 101C     		mov	r0, r2
 4799 0094 191C     		mov	r1, r3
 4800 0096 FFF7FEFF 		bl	UTIL1_ScanDecimal32uNumber
 4801 009a 031C     		mov	r3, r0
 4802 009c 2370     		strb	r3, [r4]
1801:../Generated_Code/UTIL1.c ****       if (res != ERR_OK) {
 4803              		.loc 1 1801 0
 4804 009e 3B1C     		mov	r3, r7
 4805 00a0 1733     		add	r3, r3, #23
 4806 00a2 1B78     		ldrb	r3, [r3]
 4807 00a4 002B     		cmp	r3, #0
 4808 00a6 03D0     		beq	.L235
1802:../Generated_Code/UTIL1.c ****         return res;
 4809              		.loc 1 1802 0
 4810 00a8 3B1C     		mov	r3, r7
 4811 00aa 1733     		add	r3, r3, #23
 4812 00ac 1B78     		ldrb	r3, [r3]
 4813 00ae 03E0     		b	.L238
 4814              	.L235:
1803:../Generated_Code/UTIL1.c ****       }
1804:../Generated_Code/UTIL1.c ****     }
1805:../Generated_Code/UTIL1.c ****   }
1806:../Generated_Code/UTIL1.c ****   *str = p; /* store parsing pointer */
 4815              		.loc 1 1806 0
 4816 00b0 3A69     		ldr	r2, [r7, #16]
 4817 00b2 FB68     		ldr	r3, [r7, #12]
 4818 00b4 1A60     		str	r2, [r3]
1807:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4819              		.loc 1 1807 0
 4820 00b6 0023     		mov	r3, #0
 4821              	.L238:
1808:../Generated_Code/UTIL1.c **** }
 4822              		.loc 1 1808 0
 4823 00b8 181C     		mov	r0, r3
 4824 00ba BD46     		mov	sp, r7
 4825 00bc 07B0     		add	sp, sp, #28
 4826              		@ sp needed for prologue
 4827 00be 90BD     		pop	{r4, r7, pc}
 4828              		.cfi_endproc
 4829              	.LFE40:
 4831              		.section	.text.isHexCharacter,"ax",%progbits
 4832              		.align	2
 4833              		.code	16
 4834              		.thumb_func
 4836              	isHexCharacter:
 4837              	.LFB41:
1809:../Generated_Code/UTIL1.c **** 
1810:../Generated_Code/UTIL1.c **** /*
1811:../Generated_Code/UTIL1.c **** ** ===================================================================
1812:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcmp (component Utility)
1813:../Generated_Code/UTIL1.c **** **     Description :
1814:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strcmp() routine
1815:../Generated_Code/UTIL1.c **** **     Parameters  :
1816:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1817:../Generated_Code/UTIL1.c **** **       * str1            - Pointer to string
1818:../Generated_Code/UTIL1.c **** **       * str2            - Pointer to string
1819:../Generated_Code/UTIL1.c **** **     Returns     :
1820:../Generated_Code/UTIL1.c **** **         ---             - Returns zero if the two strings are the
1821:../Generated_Code/UTIL1.c **** **                           same
1822:../Generated_Code/UTIL1.c **** ** ===================================================================
1823:../Generated_Code/UTIL1.c **** */
1824:../Generated_Code/UTIL1.c **** /***
1825:../Generated_Code/UTIL1.c **** int16_t UTIL1_strcmp(const char *, const char *)
1826:../Generated_Code/UTIL1.c **** {
1827:../Generated_Code/UTIL1.c ****   Method is implemented as macro in the header file as wrapper to the standard strcmp() function
1828:../Generated_Code/UTIL1.c **** }
1829:../Generated_Code/UTIL1.c **** */
1830:../Generated_Code/UTIL1.c **** 
1831:../Generated_Code/UTIL1.c **** /*
1832:../Generated_Code/UTIL1.c **** ** ===================================================================
1833:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strncmp (component Utility)
1834:../Generated_Code/UTIL1.c **** **     Description :
1835:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strncmp() routine
1836:../Generated_Code/UTIL1.c **** **     Parameters  :
1837:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1838:../Generated_Code/UTIL1.c **** **       * str1            - Pointer to string
1839:../Generated_Code/UTIL1.c **** **       * str2            - Pointer to string
1840:../Generated_Code/UTIL1.c **** **         size            - 
1841:../Generated_Code/UTIL1.c **** **     Returns     :
1842:../Generated_Code/UTIL1.c **** **         ---             - Returns zero if the two strings are the
1843:../Generated_Code/UTIL1.c **** **                           same
1844:../Generated_Code/UTIL1.c **** ** ===================================================================
1845:../Generated_Code/UTIL1.c **** */
1846:../Generated_Code/UTIL1.c **** /***
1847:../Generated_Code/UTIL1.c **** int16_t UTIL1_strncmp(const char *, const char *, size_t size)
1848:../Generated_Code/UTIL1.c **** {
1849:../Generated_Code/UTIL1.c ****   /Method is implemented as macro in the header file as wrapper to the standard strncmp() function
1850:../Generated_Code/UTIL1.c **** }
1851:../Generated_Code/UTIL1.c **** */
1852:../Generated_Code/UTIL1.c **** 
1853:../Generated_Code/UTIL1.c **** /*
1854:../Generated_Code/UTIL1.c **** ** ===================================================================
1855:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strlen (component Utility)
1856:../Generated_Code/UTIL1.c **** **     Description :
1857:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strlen() function.
1858:../Generated_Code/UTIL1.c **** **     Parameters  :
1859:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1860:../Generated_Code/UTIL1.c **** **         str             - 
1861:../Generated_Code/UTIL1.c **** **     Returns     :
1862:../Generated_Code/UTIL1.c **** **         ---             - size of strinig
1863:../Generated_Code/UTIL1.c **** ** ===================================================================
1864:../Generated_Code/UTIL1.c **** */
1865:../Generated_Code/UTIL1.c **** /***
1866:../Generated_Code/UTIL1.c **** uint16_t UTIL1_strlen(const char *)
1867:../Generated_Code/UTIL1.c **** {
1868:../Generated_Code/UTIL1.c ****   Method is implemented as macro in the header file as wrapper to the standard strlen() function
1869:../Generated_Code/UTIL1.c **** }
1870:../Generated_Code/UTIL1.c **** */
1871:../Generated_Code/UTIL1.c **** 
1872:../Generated_Code/UTIL1.c **** static bool isHexCharacter(unsigned char ch) {
 4838              		.loc 1 1872 0
 4839              		.cfi_startproc
 4840 0000 80B5     		push	{r7, lr}
 4841              	.LCFI123:
 4842              		.cfi_def_cfa_offset 8
 4843              		.cfi_offset 7, -8
 4844              		.cfi_offset 14, -4
 4845 0002 82B0     		sub	sp, sp, #8
 4846              	.LCFI124:
 4847              		.cfi_def_cfa_offset 16
 4848 0004 00AF     		add	r7, sp, #0
 4849              	.LCFI125:
 4850              		.cfi_def_cfa_register 7
 4851 0006 021C     		mov	r2, r0
 4852 0008 FB1D     		add	r3, r7, #7
 4853 000a 1A70     		strb	r2, [r3]
1873:../Generated_Code/UTIL1.c ****   /* returns TRUE if character is a hexadecimal character */
1874:../Generated_Code/UTIL1.c ****   return (ch>='0' && ch<='9') || (ch>='a' && ch<='f') || (ch>='A' && ch<='F');
 4854              		.loc 1 1874 0
 4855 000c FB1D     		add	r3, r7, #7
 4856 000e 1B78     		ldrb	r3, [r3]
 4857 0010 2F2B     		cmp	r3, #47
 4858 0012 03D9     		bls	.L240
 4859              		.loc 1 1874 0 is_stmt 0
 4860 0014 FB1D     		add	r3, r7, #7
 4861 0016 1B78     		ldrb	r3, [r3]
 4862 0018 392B     		cmp	r3, #57
 4863 001a 0FD9     		bls	.L241
 4864              	.L240:
 4865              		.loc 1 1874 0
 4866 001c FB1D     		add	r3, r7, #7
 4867 001e 1B78     		ldrb	r3, [r3]
 4868 0020 602B     		cmp	r3, #96
 4869 0022 03D9     		bls	.L242
 4870              		.loc 1 1874 0
 4871 0024 FB1D     		add	r3, r7, #7
 4872 0026 1B78     		ldrb	r3, [r3]
 4873 0028 662B     		cmp	r3, #102
 4874 002a 07D9     		bls	.L241
 4875              	.L242:
 4876              		.loc 1 1874 0
 4877 002c FB1D     		add	r3, r7, #7
 4878 002e 1B78     		ldrb	r3, [r3]
 4879 0030 402B     		cmp	r3, #64
 4880 0032 05D9     		bls	.L243
 4881              		.loc 1 1874 0
 4882 0034 FB1D     		add	r3, r7, #7
 4883 0036 1B78     		ldrb	r3, [r3]
 4884 0038 462B     		cmp	r3, #70
 4885 003a 01D8     		bhi	.L243
 4886              	.L241:
 4887              		.loc 1 1874 0
 4888 003c 0123     		mov	r3, #1
 4889 003e 00E0     		b	.L244
 4890              	.L243:
 4891              		.loc 1 1874 0
 4892 0040 0023     		mov	r3, #0
 4893              	.L244:
 4894              		.loc 1 1874 0
 4895 0042 DBB2     		uxtb	r3, r3
1875:../Generated_Code/UTIL1.c **** }
 4896              		.loc 1 1875 0 is_stmt 1
 4897 0044 181C     		mov	r0, r3
 4898 0046 BD46     		mov	sp, r7
 4899 0048 02B0     		add	sp, sp, #8
 4900              		@ sp needed for prologue
 4901 004a 80BD     		pop	{r7, pc}
 4902              		.cfi_endproc
 4903              	.LFE41:
 4905              		.section	.text.PreScanHexNumber,"ax",%progbits
 4906              		.align	2
 4907              		.code	16
 4908              		.thumb_func
 4910              	PreScanHexNumber:
 4911              	.LFB42:
1876:../Generated_Code/UTIL1.c **** 
1877:../Generated_Code/UTIL1.c **** static uint8_t PreScanHexNumber(const unsigned char **str) {
 4912              		.loc 1 1877 0
 4913              		.cfi_startproc
 4914 0000 80B5     		push	{r7, lr}
 4915              	.LCFI126:
 4916              		.cfi_def_cfa_offset 8
 4917              		.cfi_offset 7, -8
 4918              		.cfi_offset 14, -4
 4919 0002 84B0     		sub	sp, sp, #16
 4920              	.LCFI127:
 4921              		.cfi_def_cfa_offset 24
 4922 0004 00AF     		add	r7, sp, #0
 4923              	.LCFI128:
 4924              		.cfi_def_cfa_register 7
 4925 0006 7860     		str	r0, [r7, #4]
1878:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 4926              		.loc 1 1878 0
 4927 0008 7B68     		ldr	r3, [r7, #4]
 4928 000a 1B68     		ldr	r3, [r3]
 4929 000c FB60     		str	r3, [r7, #12]
1879:../Generated_Code/UTIL1.c **** 
1880:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4930              		.loc 1 1880 0
 4931 000e 02E0     		b	.L247
 4932              	.L248:
1881:../Generated_Code/UTIL1.c ****     p++; /* skip space */
 4933              		.loc 1 1881 0
 4934 0010 FB68     		ldr	r3, [r7, #12]
 4935 0012 0133     		add	r3, r3, #1
 4936 0014 FB60     		str	r3, [r7, #12]
 4937              	.L247:
1880:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 4938              		.loc 1 1880 0
 4939 0016 FB68     		ldr	r3, [r7, #12]
 4940 0018 1B78     		ldrb	r3, [r3]
 4941 001a 202B     		cmp	r3, #32
 4942 001c F8D0     		beq	.L248
1882:../Generated_Code/UTIL1.c ****   }
1883:../Generated_Code/UTIL1.c ****   if (*p!='0') { /* must start with 0x */
 4943              		.loc 1 1883 0
 4944 001e FB68     		ldr	r3, [r7, #12]
 4945 0020 1B78     		ldrb	r3, [r3]
 4946 0022 302B     		cmp	r3, #48
 4947 0024 01D0     		beq	.L249
1884:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4948              		.loc 1 1884 0
 4949 0026 1B23     		mov	r3, #27
 4950 0028 0FE0     		b	.L250
 4951              	.L249:
1885:../Generated_Code/UTIL1.c ****   }
1886:../Generated_Code/UTIL1.c ****   p++; /* skip '0' */
 4952              		.loc 1 1886 0
 4953 002a FB68     		ldr	r3, [r7, #12]
 4954 002c 0133     		add	r3, r3, #1
 4955 002e FB60     		str	r3, [r7, #12]
1887:../Generated_Code/UTIL1.c ****   if (*p!='x') { /* must start with 0x */
 4956              		.loc 1 1887 0
 4957 0030 FB68     		ldr	r3, [r7, #12]
 4958 0032 1B78     		ldrb	r3, [r3]
 4959 0034 782B     		cmp	r3, #120
 4960 0036 01D0     		beq	.L251
1888:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 4961              		.loc 1 1888 0
 4962 0038 1B23     		mov	r3, #27
 4963 003a 06E0     		b	.L250
 4964              	.L251:
1889:../Generated_Code/UTIL1.c ****   }
1890:../Generated_Code/UTIL1.c ****   p++; /* skip 'x' */
 4965              		.loc 1 1890 0
 4966 003c FB68     		ldr	r3, [r7, #12]
 4967 003e 0133     		add	r3, r3, #1
 4968 0040 FB60     		str	r3, [r7, #12]
1891:../Generated_Code/UTIL1.c ****   *str = p;
 4969              		.loc 1 1891 0
 4970 0042 7B68     		ldr	r3, [r7, #4]
 4971 0044 FA68     		ldr	r2, [r7, #12]
 4972 0046 1A60     		str	r2, [r3]
1892:../Generated_Code/UTIL1.c ****   return ERR_OK;
 4973              		.loc 1 1892 0
 4974 0048 0023     		mov	r3, #0
 4975              	.L250:
1893:../Generated_Code/UTIL1.c **** }
 4976              		.loc 1 1893 0
 4977 004a 181C     		mov	r0, r3
 4978 004c BD46     		mov	sp, r7
 4979 004e 04B0     		add	sp, sp, #16
 4980              		@ sp needed for prologue
 4981 0050 80BD     		pop	{r7, pc}
 4982              		.cfi_endproc
 4983              	.LFE42:
 4985 0052 C046     		.section	.text.HexToDec,"ax",%progbits
 4986              		.align	2
 4987              		.code	16
 4988              		.thumb_func
 4990              	HexToDec:
 4991              	.LFB43:
1894:../Generated_Code/UTIL1.c **** 
1895:../Generated_Code/UTIL1.c **** static uint8_t HexToDec(const unsigned char **p, unsigned char *val) {
 4992              		.loc 1 1895 0
 4993              		.cfi_startproc
 4994 0000 80B5     		push	{r7, lr}
 4995              	.LCFI129:
 4996              		.cfi_def_cfa_offset 8
 4997              		.cfi_offset 7, -8
 4998              		.cfi_offset 14, -4
 4999 0002 84B0     		sub	sp, sp, #16
 5000              	.LCFI130:
 5001              		.cfi_def_cfa_offset 24
 5002 0004 00AF     		add	r7, sp, #0
 5003              	.LCFI131:
 5004              		.cfi_def_cfa_register 7
 5005 0006 7860     		str	r0, [r7, #4]
 5006 0008 3960     		str	r1, [r7]
1896:../Generated_Code/UTIL1.c ****   /* convert a hexadecimal character into a decimal value */
1897:../Generated_Code/UTIL1.c ****   unsigned char ch = **p;
 5007              		.loc 1 1897 0
 5008 000a 7B68     		ldr	r3, [r7, #4]
 5009 000c 1A68     		ldr	r2, [r3]
 5010 000e 3B1C     		mov	r3, r7
 5011 0010 0F33     		add	r3, r3, #15
 5012 0012 1278     		ldrb	r2, [r2]
 5013 0014 1A70     		strb	r2, [r3]
1898:../Generated_Code/UTIL1.c **** 
1899:../Generated_Code/UTIL1.c ****   if (ch>='0' && ch<='9') {
 5014              		.loc 1 1899 0
 5015 0016 3B1C     		mov	r3, r7
 5016 0018 0F33     		add	r3, r3, #15
 5017 001a 1B78     		ldrb	r3, [r3]
 5018 001c 2F2B     		cmp	r3, #47
 5019 001e 12D9     		bls	.L253
 5020              		.loc 1 1899 0 is_stmt 0
 5021 0020 3B1C     		mov	r3, r7
 5022 0022 0F33     		add	r3, r3, #15
 5023 0024 1B78     		ldrb	r3, [r3]
 5024 0026 392B     		cmp	r3, #57
 5025 0028 0DD8     		bhi	.L253
1900:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'0');
 5026              		.loc 1 1900 0 is_stmt 1
 5027 002a 3B1C     		mov	r3, r7
 5028 002c 0F33     		add	r3, r3, #15
 5029 002e 1B78     		ldrb	r3, [r3]
 5030 0030 303B     		sub	r3, r3, #48
 5031 0032 DAB2     		uxtb	r2, r3
 5032 0034 3B68     		ldr	r3, [r7]
 5033 0036 1A70     		strb	r2, [r3]
1901:../Generated_Code/UTIL1.c ****     (*p)++;
 5034              		.loc 1 1901 0
 5035 0038 7B68     		ldr	r3, [r7, #4]
 5036 003a 1B68     		ldr	r3, [r3]
 5037 003c 5A1C     		add	r2, r3, #1
 5038 003e 7B68     		ldr	r3, [r7, #4]
 5039 0040 1A60     		str	r2, [r3]
1902:../Generated_Code/UTIL1.c ****     return ERR_OK;
 5040              		.loc 1 1902 0
 5041 0042 0023     		mov	r3, #0
 5042 0044 30E0     		b	.L254
 5043              	.L253:
1903:../Generated_Code/UTIL1.c ****   } else if (ch>='a' && ch<='f') {
 5044              		.loc 1 1903 0
 5045 0046 3B1C     		mov	r3, r7
 5046 0048 0F33     		add	r3, r3, #15
 5047 004a 1B78     		ldrb	r3, [r3]
 5048 004c 602B     		cmp	r3, #96
 5049 004e 12D9     		bls	.L255
 5050              		.loc 1 1903 0 is_stmt 0
 5051 0050 3B1C     		mov	r3, r7
 5052 0052 0F33     		add	r3, r3, #15
 5053 0054 1B78     		ldrb	r3, [r3]
 5054 0056 662B     		cmp	r3, #102
 5055 0058 0DD8     		bhi	.L255
1904:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'a'+10);
 5056              		.loc 1 1904 0 is_stmt 1
 5057 005a 3B1C     		mov	r3, r7
 5058 005c 0F33     		add	r3, r3, #15
 5059 005e 1B78     		ldrb	r3, [r3]
 5060 0060 573B     		sub	r3, r3, #87
 5061 0062 DAB2     		uxtb	r2, r3
 5062 0064 3B68     		ldr	r3, [r7]
 5063 0066 1A70     		strb	r2, [r3]
1905:../Generated_Code/UTIL1.c ****     (*p)++;
 5064              		.loc 1 1905 0
 5065 0068 7B68     		ldr	r3, [r7, #4]
 5066 006a 1B68     		ldr	r3, [r3]
 5067 006c 5A1C     		add	r2, r3, #1
 5068 006e 7B68     		ldr	r3, [r7, #4]
 5069 0070 1A60     		str	r2, [r3]
1906:../Generated_Code/UTIL1.c ****     return ERR_OK;
 5070              		.loc 1 1906 0
 5071 0072 0023     		mov	r3, #0
 5072 0074 18E0     		b	.L254
 5073              	.L255:
1907:../Generated_Code/UTIL1.c ****   } else if (ch>='A' && ch<='F') {
 5074              		.loc 1 1907 0
 5075 0076 3B1C     		mov	r3, r7
 5076 0078 0F33     		add	r3, r3, #15
 5077 007a 1B78     		ldrb	r3, [r3]
 5078 007c 402B     		cmp	r3, #64
 5079 007e 12D9     		bls	.L256
 5080              		.loc 1 1907 0 is_stmt 0
 5081 0080 3B1C     		mov	r3, r7
 5082 0082 0F33     		add	r3, r3, #15
 5083 0084 1B78     		ldrb	r3, [r3]
 5084 0086 462B     		cmp	r3, #70
 5085 0088 0DD8     		bhi	.L256
1908:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'A'+10);
 5086              		.loc 1 1908 0 is_stmt 1
 5087 008a 3B1C     		mov	r3, r7
 5088 008c 0F33     		add	r3, r3, #15
 5089 008e 1B78     		ldrb	r3, [r3]
 5090 0090 373B     		sub	r3, r3, #55
 5091 0092 DAB2     		uxtb	r2, r3
 5092 0094 3B68     		ldr	r3, [r7]
 5093 0096 1A70     		strb	r2, [r3]
1909:../Generated_Code/UTIL1.c ****     (*p)++;
 5094              		.loc 1 1909 0
 5095 0098 7B68     		ldr	r3, [r7, #4]
 5096 009a 1B68     		ldr	r3, [r3]
 5097 009c 5A1C     		add	r2, r3, #1
 5098 009e 7B68     		ldr	r3, [r7, #4]
 5099 00a0 1A60     		str	r2, [r3]
1910:../Generated_Code/UTIL1.c ****     return ERR_OK;
 5100              		.loc 1 1910 0
 5101 00a2 0023     		mov	r3, #0
 5102 00a4 00E0     		b	.L254
 5103              	.L256:
1911:../Generated_Code/UTIL1.c ****   }
1912:../Generated_Code/UTIL1.c ****   return ERR_FAILED;
 5104              		.loc 1 1912 0
 5105 00a6 1B23     		mov	r3, #27
 5106              	.L254:
1913:../Generated_Code/UTIL1.c **** }
 5107              		.loc 1 1913 0
 5108 00a8 181C     		mov	r0, r3
 5109 00aa BD46     		mov	sp, r7
 5110 00ac 04B0     		add	sp, sp, #16
 5111              		@ sp needed for prologue
 5112 00ae 80BD     		pop	{r7, pc}
 5113              		.cfi_endproc
 5114              	.LFE43:
 5116              		.section	.text.UTIL1_ScanHex32uNumber,"ax",%progbits
 5117              		.align	2
 5118              		.global	UTIL1_ScanHex32uNumber
 5119              		.code	16
 5120              		.thumb_func
 5122              	UTIL1_ScanHex32uNumber:
 5123              	.LFB44:
1914:../Generated_Code/UTIL1.c **** 
1915:../Generated_Code/UTIL1.c **** /*
1916:../Generated_Code/UTIL1.c **** ** ===================================================================
1917:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex32uNumber (component Utility)
1918:../Generated_Code/UTIL1.c **** **     Description :
1919:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 32bit number, starting with 0x
1920:../Generated_Code/UTIL1.c **** **     Parameters  :
1921:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1922:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1923:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1924:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1925:../Generated_Code/UTIL1.c **** **     Returns     :
1926:../Generated_Code/UTIL1.c **** **         ---             - Error code
1927:../Generated_Code/UTIL1.c **** ** ===================================================================
1928:../Generated_Code/UTIL1.c **** */
1929:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanHex32uNumber(const unsigned char **str, uint32_t *val)
1930:../Generated_Code/UTIL1.c **** {
 5124              		.loc 1 1930 0
 5125              		.cfi_startproc
 5126 0000 80B5     		push	{r7, lr}
 5127              	.LCFI132:
 5128              		.cfi_def_cfa_offset 8
 5129              		.cfi_offset 7, -8
 5130              		.cfi_offset 14, -4
 5131 0002 86B0     		sub	sp, sp, #24
 5132              	.LCFI133:
 5133              		.cfi_def_cfa_offset 32
 5134 0004 00AF     		add	r7, sp, #0
 5135              	.LCFI134:
 5136              		.cfi_def_cfa_register 7
 5137 0006 7860     		str	r0, [r7, #4]
 5138 0008 3960     		str	r1, [r7]
1931:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1932:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 8; /* maximum number of digits to avoid overflow */
 5139              		.loc 1 1932 0
 5140 000a 3B1C     		mov	r3, r7
 5141 000c 1733     		add	r3, r3, #23
 5142 000e 0822     		mov	r2, #8
 5143 0010 1A70     		strb	r2, [r3]
1933:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 5144              		.loc 1 1933 0
 5145 0012 7B68     		ldr	r3, [r7, #4]
 5146 0014 1B68     		ldr	r3, [r3]
 5147 0016 3B61     		str	r3, [r7, #16]
1934:../Generated_Code/UTIL1.c ****   uint8_t v;
1935:../Generated_Code/UTIL1.c **** 
1936:../Generated_Code/UTIL1.c ****   *val = 0;
 5148              		.loc 1 1936 0
 5149 0018 3B68     		ldr	r3, [r7]
 5150 001a 0022     		mov	r2, #0
 5151 001c 1A60     		str	r2, [r3]
1937:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 5152              		.loc 1 1937 0
 5153 001e 3B1C     		mov	r3, r7
 5154 0020 1033     		add	r3, r3, #16
 5155 0022 181C     		mov	r0, r3
 5156 0024 FFF7FEFF 		bl	PreScanHexNumber
 5157 0028 031C     		mov	r3, r0
 5158 002a 002B     		cmp	r3, #0
 5159 002c 01D0     		beq	.L258
1938:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5160              		.loc 1 1938 0
 5161 002e 1B23     		mov	r3, #27
 5162 0030 2DE0     		b	.L264
 5163              	.L258:
1939:../Generated_Code/UTIL1.c ****   }
1940:../Generated_Code/UTIL1.c ****   if (!isHexCharacter(*p)) { /* not a valid hex number sequence */
 5164              		.loc 1 1940 0
 5165 0032 3B69     		ldr	r3, [r7, #16]
 5166 0034 1B78     		ldrb	r3, [r3]
 5167 0036 181C     		mov	r0, r3
 5168 0038 FFF7FEFF 		bl	isHexCharacter
 5169 003c 031C     		mov	r3, r0
 5170 003e 002B     		cmp	r3, #0
 5171 0040 11D1     		bne	.L261
1941:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5172              		.loc 1 1941 0
 5173 0042 1B23     		mov	r3, #27
 5174 0044 23E0     		b	.L264
 5175              	.L263:
1942:../Generated_Code/UTIL1.c ****   }
1943:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
1944:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*16 + v);
 5176              		.loc 1 1944 0
 5177 0046 3B68     		ldr	r3, [r7]
 5178 0048 1B68     		ldr	r3, [r3]
 5179 004a 1A01     		lsl	r2, r3, #4
 5180 004c 3B1C     		mov	r3, r7
 5181 004e 0F33     		add	r3, r3, #15
 5182 0050 1B78     		ldrb	r3, [r3]
 5183 0052 D218     		add	r2, r2, r3
 5184 0054 3B68     		ldr	r3, [r7]
 5185 0056 1A60     		str	r2, [r3]
1945:../Generated_Code/UTIL1.c ****     nofDigits--;
 5186              		.loc 1 1945 0
 5187 0058 3B1C     		mov	r3, r7
 5188 005a 1733     		add	r3, r3, #23
 5189 005c 3A1C     		mov	r2, r7
 5190 005e 1732     		add	r2, r2, #23
 5191 0060 1278     		ldrb	r2, [r2]
 5192 0062 013A     		sub	r2, r2, #1
 5193 0064 1A70     		strb	r2, [r3]
 5194              	.L261:
1943:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5195              		.loc 1 1943 0
 5196 0066 3B1C     		mov	r3, r7
 5197 0068 1733     		add	r3, r3, #23
 5198 006a 1B78     		ldrb	r3, [r3]
 5199 006c 002B     		cmp	r3, #0
 5200 006e 0AD0     		beq	.L262
1943:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5201              		.loc 1 1943 0 is_stmt 0
 5202 0070 3A1C     		mov	r2, r7
 5203 0072 1032     		add	r2, r2, #16
 5204 0074 3B1C     		mov	r3, r7
 5205 0076 0F33     		add	r3, r3, #15
 5206 0078 101C     		mov	r0, r2
 5207 007a 191C     		mov	r1, r3
 5208 007c FFF7FEFF 		bl	HexToDec
 5209 0080 031C     		mov	r3, r0
 5210 0082 002B     		cmp	r3, #0
 5211 0084 DFD0     		beq	.L263
 5212              	.L262:
1946:../Generated_Code/UTIL1.c ****   } /* while */
1947:../Generated_Code/UTIL1.c ****   *str = p;
 5213              		.loc 1 1947 0 is_stmt 1
 5214 0086 3A69     		ldr	r2, [r7, #16]
 5215 0088 7B68     		ldr	r3, [r7, #4]
 5216 008a 1A60     		str	r2, [r3]
1948:../Generated_Code/UTIL1.c ****   return ERR_OK;
 5217              		.loc 1 1948 0
 5218 008c 0023     		mov	r3, #0
 5219              	.L264:
1949:../Generated_Code/UTIL1.c **** }
 5220              		.loc 1 1949 0
 5221 008e 181C     		mov	r0, r3
 5222 0090 BD46     		mov	sp, r7
 5223 0092 06B0     		add	sp, sp, #24
 5224              		@ sp needed for prologue
 5225 0094 80BD     		pop	{r7, pc}
 5226              		.cfi_endproc
 5227              	.LFE44:
 5229 0096 C046     		.section	.text.UTIL1_ScanHex16uNumber,"ax",%progbits
 5230              		.align	2
 5231              		.global	UTIL1_ScanHex16uNumber
 5232              		.code	16
 5233              		.thumb_func
 5235              	UTIL1_ScanHex16uNumber:
 5236              	.LFB45:
1950:../Generated_Code/UTIL1.c **** 
1951:../Generated_Code/UTIL1.c **** /*
1952:../Generated_Code/UTIL1.c **** ** ===================================================================
1953:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex16uNumber (component Utility)
1954:../Generated_Code/UTIL1.c **** **     Description :
1955:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 16bit number, starting with 0x
1956:../Generated_Code/UTIL1.c **** **     Parameters  :
1957:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1958:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x.. It
1959:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1960:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1961:../Generated_Code/UTIL1.c **** **     Returns     :
1962:../Generated_Code/UTIL1.c **** **         ---             - Error code
1963:../Generated_Code/UTIL1.c **** ** ===================================================================
1964:../Generated_Code/UTIL1.c **** */
1965:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanHex16uNumber(const unsigned char **str, uint16_t *val)
1966:../Generated_Code/UTIL1.c **** {
 5237              		.loc 1 1966 0
 5238              		.cfi_startproc
 5239 0000 80B5     		push	{r7, lr}
 5240              	.LCFI135:
 5241              		.cfi_def_cfa_offset 8
 5242              		.cfi_offset 7, -8
 5243              		.cfi_offset 14, -4
 5244 0002 86B0     		sub	sp, sp, #24
 5245              	.LCFI136:
 5246              		.cfi_def_cfa_offset 32
 5247 0004 00AF     		add	r7, sp, #0
 5248              	.LCFI137:
 5249              		.cfi_def_cfa_register 7
 5250 0006 7860     		str	r0, [r7, #4]
 5251 0008 3960     		str	r1, [r7]
1967:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1968:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 4; /* maximum number of digits to read */
 5252              		.loc 1 1968 0
 5253 000a 3B1C     		mov	r3, r7
 5254 000c 1733     		add	r3, r3, #23
 5255 000e 0422     		mov	r2, #4
 5256 0010 1A70     		strb	r2, [r3]
1969:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 5257              		.loc 1 1969 0
 5258 0012 7B68     		ldr	r3, [r7, #4]
 5259 0014 1B68     		ldr	r3, [r3]
 5260 0016 3B61     		str	r3, [r7, #16]
1970:../Generated_Code/UTIL1.c ****   uint8_t v;
1971:../Generated_Code/UTIL1.c **** 
1972:../Generated_Code/UTIL1.c ****   *val = 0;
 5261              		.loc 1 1972 0
 5262 0018 3B68     		ldr	r3, [r7]
 5263 001a 0022     		mov	r2, #0
 5264 001c 1A80     		strh	r2, [r3]
1973:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 5265              		.loc 1 1973 0
 5266 001e 3B1C     		mov	r3, r7
 5267 0020 1033     		add	r3, r3, #16
 5268 0022 181C     		mov	r0, r3
 5269 0024 FFF7FEFF 		bl	PreScanHexNumber
 5270 0028 031C     		mov	r3, r0
 5271 002a 002B     		cmp	r3, #0
 5272 002c 01D0     		beq	.L266
1974:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5273              		.loc 1 1974 0
 5274 002e 1B23     		mov	r3, #27
 5275 0030 2FE0     		b	.L272
 5276              	.L266:
1975:../Generated_Code/UTIL1.c ****   }
1976:../Generated_Code/UTIL1.c ****   if (!isHexCharacter(*p)) { /* not a valid hex number sequence */
 5277              		.loc 1 1976 0
 5278 0032 3B69     		ldr	r3, [r7, #16]
 5279 0034 1B78     		ldrb	r3, [r3]
 5280 0036 181C     		mov	r0, r3
 5281 0038 FFF7FEFF 		bl	isHexCharacter
 5282 003c 031C     		mov	r3, r0
 5283 003e 002B     		cmp	r3, #0
 5284 0040 13D1     		bne	.L269
1977:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5285              		.loc 1 1977 0
 5286 0042 1B23     		mov	r3, #27
 5287 0044 25E0     		b	.L272
 5288              	.L271:
1978:../Generated_Code/UTIL1.c ****   }
1979:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
1980:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*16 + v);
 5289              		.loc 1 1980 0
 5290 0046 3B68     		ldr	r3, [r7]
 5291 0048 1B88     		ldrh	r3, [r3]
 5292 004a 1B01     		lsl	r3, r3, #4
 5293 004c 9AB2     		uxth	r2, r3
 5294 004e 3B1C     		mov	r3, r7
 5295 0050 0F33     		add	r3, r3, #15
 5296 0052 1B78     		ldrb	r3, [r3]
 5297 0054 D318     		add	r3, r2, r3
 5298 0056 9AB2     		uxth	r2, r3
 5299 0058 3B68     		ldr	r3, [r7]
 5300 005a 1A80     		strh	r2, [r3]
1981:../Generated_Code/UTIL1.c ****     nofDigits--;
 5301              		.loc 1 1981 0
 5302 005c 3B1C     		mov	r3, r7
 5303 005e 1733     		add	r3, r3, #23
 5304 0060 3A1C     		mov	r2, r7
 5305 0062 1732     		add	r2, r2, #23
 5306 0064 1278     		ldrb	r2, [r2]
 5307 0066 013A     		sub	r2, r2, #1
 5308 0068 1A70     		strb	r2, [r3]
 5309              	.L269:
1979:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5310              		.loc 1 1979 0
 5311 006a 3B1C     		mov	r3, r7
 5312 006c 1733     		add	r3, r3, #23
 5313 006e 1B78     		ldrb	r3, [r3]
 5314 0070 002B     		cmp	r3, #0
 5315 0072 0AD0     		beq	.L270
1979:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5316              		.loc 1 1979 0 is_stmt 0
 5317 0074 3A1C     		mov	r2, r7
 5318 0076 1032     		add	r2, r2, #16
 5319 0078 3B1C     		mov	r3, r7
 5320 007a 0F33     		add	r3, r3, #15
 5321 007c 101C     		mov	r0, r2
 5322 007e 191C     		mov	r1, r3
 5323 0080 FFF7FEFF 		bl	HexToDec
 5324 0084 031C     		mov	r3, r0
 5325 0086 002B     		cmp	r3, #0
 5326 0088 DDD0     		beq	.L271
 5327              	.L270:
1982:../Generated_Code/UTIL1.c ****   } /* while */
1983:../Generated_Code/UTIL1.c ****   *str = p;
 5328              		.loc 1 1983 0 is_stmt 1
 5329 008a 3A69     		ldr	r2, [r7, #16]
 5330 008c 7B68     		ldr	r3, [r7, #4]
 5331 008e 1A60     		str	r2, [r3]
1984:../Generated_Code/UTIL1.c ****   return ERR_OK;
 5332              		.loc 1 1984 0
 5333 0090 0023     		mov	r3, #0
 5334              	.L272:
1985:../Generated_Code/UTIL1.c **** }
 5335              		.loc 1 1985 0
 5336 0092 181C     		mov	r0, r3
 5337 0094 BD46     		mov	sp, r7
 5338 0096 06B0     		add	sp, sp, #24
 5339              		@ sp needed for prologue
 5340 0098 80BD     		pop	{r7, pc}
 5341              		.cfi_endproc
 5342              	.LFE45:
 5344 009a C046     		.section	.text.UTIL1_ScanHex8uNumber,"ax",%progbits
 5345              		.align	2
 5346              		.global	UTIL1_ScanHex8uNumber
 5347              		.code	16
 5348              		.thumb_func
 5350              	UTIL1_ScanHex8uNumber:
 5351              	.LFB46:
1986:../Generated_Code/UTIL1.c **** 
1987:../Generated_Code/UTIL1.c **** /*
1988:../Generated_Code/UTIL1.c **** ** ===================================================================
1989:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex8uNumber (component Utility)
1990:../Generated_Code/UTIL1.c **** **     Description :
1991:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 8bit number, starting with 0x
1992:../Generated_Code/UTIL1.c **** **     Parameters  :
1993:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1994:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1995:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1996:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1997:../Generated_Code/UTIL1.c **** **     Returns     :
1998:../Generated_Code/UTIL1.c **** **         ---             - Error code
1999:../Generated_Code/UTIL1.c **** ** ===================================================================
2000:../Generated_Code/UTIL1.c **** */
2001:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanHex8uNumber(const unsigned char **str, uint8_t *val)
2002:../Generated_Code/UTIL1.c **** {
 5352              		.loc 1 2002 0
 5353              		.cfi_startproc
 5354 0000 80B5     		push	{r7, lr}
 5355              	.LCFI138:
 5356              		.cfi_def_cfa_offset 8
 5357              		.cfi_offset 7, -8
 5358              		.cfi_offset 14, -4
 5359 0002 86B0     		sub	sp, sp, #24
 5360              	.LCFI139:
 5361              		.cfi_def_cfa_offset 32
 5362 0004 00AF     		add	r7, sp, #0
 5363              	.LCFI140:
 5364              		.cfi_def_cfa_register 7
 5365 0006 7860     		str	r0, [r7, #4]
 5366 0008 3960     		str	r1, [r7]
2003:../Generated_Code/UTIL1.c ****   /* scans a hex number with 0x, and stops at any non-number. Number can have any preceding zeros o
2004:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 2; /* maximum number of digits to read */
 5367              		.loc 1 2004 0
 5368 000a 3B1C     		mov	r3, r7
 5369 000c 1733     		add	r3, r3, #23
 5370 000e 0222     		mov	r2, #2
 5371 0010 1A70     		strb	r2, [r3]
2005:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 5372              		.loc 1 2005 0
 5373 0012 7B68     		ldr	r3, [r7, #4]
 5374 0014 1B68     		ldr	r3, [r3]
 5375 0016 3B61     		str	r3, [r7, #16]
2006:../Generated_Code/UTIL1.c ****   uint8_t v;
2007:../Generated_Code/UTIL1.c **** 
2008:../Generated_Code/UTIL1.c ****   *val = 0;
 5376              		.loc 1 2008 0
 5377 0018 3B68     		ldr	r3, [r7]
 5378 001a 0022     		mov	r2, #0
 5379 001c 1A70     		strb	r2, [r3]
2009:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 5380              		.loc 1 2009 0
 5381 001e 3B1C     		mov	r3, r7
 5382 0020 1033     		add	r3, r3, #16
 5383 0022 181C     		mov	r0, r3
 5384 0024 FFF7FEFF 		bl	PreScanHexNumber
 5385 0028 031C     		mov	r3, r0
 5386 002a 002B     		cmp	r3, #0
 5387 002c 01D0     		beq	.L274
2010:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5388              		.loc 1 2010 0
 5389 002e 1B23     		mov	r3, #27
 5390 0030 2FE0     		b	.L280
 5391              	.L274:
2011:../Generated_Code/UTIL1.c ****   }
2012:../Generated_Code/UTIL1.c ****   if (!isHexCharacter(*p)) { /* not a valid hex number sequence */
 5392              		.loc 1 2012 0
 5393 0032 3B69     		ldr	r3, [r7, #16]
 5394 0034 1B78     		ldrb	r3, [r3]
 5395 0036 181C     		mov	r0, r3
 5396 0038 FFF7FEFF 		bl	isHexCharacter
 5397 003c 031C     		mov	r3, r0
 5398 003e 002B     		cmp	r3, #0
 5399 0040 13D1     		bne	.L277
2013:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5400              		.loc 1 2013 0
 5401 0042 1B23     		mov	r3, #27
 5402 0044 25E0     		b	.L280
 5403              	.L279:
2014:../Generated_Code/UTIL1.c ****   }
2015:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
2016:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*16 + v);
 5404              		.loc 1 2016 0
 5405 0046 3B68     		ldr	r3, [r7]
 5406 0048 1B78     		ldrb	r3, [r3]
 5407 004a 1B01     		lsl	r3, r3, #4
 5408 004c DAB2     		uxtb	r2, r3
 5409 004e 3B1C     		mov	r3, r7
 5410 0050 0F33     		add	r3, r3, #15
 5411 0052 1B78     		ldrb	r3, [r3]
 5412 0054 D318     		add	r3, r2, r3
 5413 0056 DAB2     		uxtb	r2, r3
 5414 0058 3B68     		ldr	r3, [r7]
 5415 005a 1A70     		strb	r2, [r3]
2017:../Generated_Code/UTIL1.c ****     nofDigits--;
 5416              		.loc 1 2017 0
 5417 005c 3B1C     		mov	r3, r7
 5418 005e 1733     		add	r3, r3, #23
 5419 0060 3A1C     		mov	r2, r7
 5420 0062 1732     		add	r2, r2, #23
 5421 0064 1278     		ldrb	r2, [r2]
 5422 0066 013A     		sub	r2, r2, #1
 5423 0068 1A70     		strb	r2, [r3]
 5424              	.L277:
2015:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5425              		.loc 1 2015 0
 5426 006a 3B1C     		mov	r3, r7
 5427 006c 1733     		add	r3, r3, #23
 5428 006e 1B78     		ldrb	r3, [r3]
 5429 0070 002B     		cmp	r3, #0
 5430 0072 0AD0     		beq	.L278
2015:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5431              		.loc 1 2015 0 is_stmt 0
 5432 0074 3A1C     		mov	r2, r7
 5433 0076 1032     		add	r2, r2, #16
 5434 0078 3B1C     		mov	r3, r7
 5435 007a 0F33     		add	r3, r3, #15
 5436 007c 101C     		mov	r0, r2
 5437 007e 191C     		mov	r1, r3
 5438 0080 FFF7FEFF 		bl	HexToDec
 5439 0084 031C     		mov	r3, r0
 5440 0086 002B     		cmp	r3, #0
 5441 0088 DDD0     		beq	.L279
 5442              	.L278:
2018:../Generated_Code/UTIL1.c ****   } /* while */
2019:../Generated_Code/UTIL1.c ****   *str = p;
 5443              		.loc 1 2019 0 is_stmt 1
 5444 008a 3A69     		ldr	r2, [r7, #16]
 5445 008c 7B68     		ldr	r3, [r7, #4]
 5446 008e 1A60     		str	r2, [r3]
2020:../Generated_Code/UTIL1.c ****   return ERR_OK;
 5447              		.loc 1 2020 0
 5448 0090 0023     		mov	r3, #0
 5449              	.L280:
2021:../Generated_Code/UTIL1.c **** }
 5450              		.loc 1 2021 0
 5451 0092 181C     		mov	r0, r3
 5452 0094 BD46     		mov	sp, r7
 5453 0096 06B0     		add	sp, sp, #24
 5454              		@ sp needed for prologue
 5455 0098 80BD     		pop	{r7, pc}
 5456              		.cfi_endproc
 5457              	.LFE46:
 5459 009a C046     		.section	.text.UTIL1_ScanHex8uNumberNoPrefix,"ax",%progbits
 5460              		.align	2
 5461              		.global	UTIL1_ScanHex8uNumberNoPrefix
 5462              		.code	16
 5463              		.thumb_func
 5465              	UTIL1_ScanHex8uNumberNoPrefix:
 5466              	.LFB47:
2022:../Generated_Code/UTIL1.c **** 
2023:../Generated_Code/UTIL1.c **** /*
2024:../Generated_Code/UTIL1.c **** ** ===================================================================
2025:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex8uNumberNoPrefix (component Utility)
2026:../Generated_Code/UTIL1.c **** **     Description :
2027:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 8bit number, without 0x
2028:../Generated_Code/UTIL1.c **** **     Parameters  :
2029:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2030:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
2031:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
2032:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
2033:../Generated_Code/UTIL1.c **** **     Returns     :
2034:../Generated_Code/UTIL1.c **** **         ---             - Error code
2035:../Generated_Code/UTIL1.c **** ** ===================================================================
2036:../Generated_Code/UTIL1.c **** */
2037:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanHex8uNumberNoPrefix(const unsigned char **str, uint8_t *val)
2038:../Generated_Code/UTIL1.c **** {
 5467              		.loc 1 2038 0
 5468              		.cfi_startproc
 5469 0000 80B5     		push	{r7, lr}
 5470              	.LCFI141:
 5471              		.cfi_def_cfa_offset 8
 5472              		.cfi_offset 7, -8
 5473              		.cfi_offset 14, -4
 5474 0002 86B0     		sub	sp, sp, #24
 5475              	.LCFI142:
 5476              		.cfi_def_cfa_offset 32
 5477 0004 00AF     		add	r7, sp, #0
 5478              	.LCFI143:
 5479              		.cfi_def_cfa_register 7
 5480 0006 7860     		str	r0, [r7, #4]
 5481 0008 3960     		str	r1, [r7]
2039:../Generated_Code/UTIL1.c ****   /* scans a hex number without 0x, and stops at any non-number. Number can have any preceding zero
2040:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 2; /* maximum number of digits to read */
 5482              		.loc 1 2040 0
 5483 000a 3B1C     		mov	r3, r7
 5484 000c 1733     		add	r3, r3, #23
 5485 000e 0222     		mov	r2, #2
 5486 0010 1A70     		strb	r2, [r3]
2041:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 5487              		.loc 1 2041 0
 5488 0012 7B68     		ldr	r3, [r7, #4]
 5489 0014 1B68     		ldr	r3, [r3]
 5490 0016 3B61     		str	r3, [r7, #16]
2042:../Generated_Code/UTIL1.c ****   uint8_t v;
2043:../Generated_Code/UTIL1.c **** 
2044:../Generated_Code/UTIL1.c ****   *val = 0;
 5491              		.loc 1 2044 0
 5492 0018 3B68     		ldr	r3, [r7]
 5493 001a 0022     		mov	r2, #0
 5494 001c 1A70     		strb	r2, [r3]
2045:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 5495              		.loc 1 2045 0
 5496 001e 02E0     		b	.L282
 5497              	.L283:
2046:../Generated_Code/UTIL1.c ****     p++; /* skip space */
 5498              		.loc 1 2046 0
 5499 0020 3B69     		ldr	r3, [r7, #16]
 5500 0022 0133     		add	r3, r3, #1
 5501 0024 3B61     		str	r3, [r7, #16]
 5502              	.L282:
2045:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 5503              		.loc 1 2045 0
 5504 0026 3B69     		ldr	r3, [r7, #16]
 5505 0028 1B78     		ldrb	r3, [r3]
 5506 002a 202B     		cmp	r3, #32
 5507 002c F8D0     		beq	.L283
2047:../Generated_Code/UTIL1.c ****   }
2048:../Generated_Code/UTIL1.c ****   if (!isHexCharacter(*p)) { /* not a valid hex number sequence */
 5508              		.loc 1 2048 0
 5509 002e 3B69     		ldr	r3, [r7, #16]
 5510 0030 1B78     		ldrb	r3, [r3]
 5511 0032 181C     		mov	r0, r3
 5512 0034 FFF7FEFF 		bl	isHexCharacter
 5513 0038 031C     		mov	r3, r0
 5514 003a 002B     		cmp	r3, #0
 5515 003c 13D1     		bne	.L286
2049:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 5516              		.loc 1 2049 0
 5517 003e 1B23     		mov	r3, #27
 5518 0040 25E0     		b	.L289
 5519              	.L288:
2050:../Generated_Code/UTIL1.c ****   }
2051:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
2052:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*16 + v);
 5520              		.loc 1 2052 0
 5521 0042 3B68     		ldr	r3, [r7]
 5522 0044 1B78     		ldrb	r3, [r3]
 5523 0046 1B01     		lsl	r3, r3, #4
 5524 0048 DAB2     		uxtb	r2, r3
 5525 004a 3B1C     		mov	r3, r7
 5526 004c 0F33     		add	r3, r3, #15
 5527 004e 1B78     		ldrb	r3, [r3]
 5528 0050 D318     		add	r3, r2, r3
 5529 0052 DAB2     		uxtb	r2, r3
 5530 0054 3B68     		ldr	r3, [r7]
 5531 0056 1A70     		strb	r2, [r3]
2053:../Generated_Code/UTIL1.c ****     nofDigits--;
 5532              		.loc 1 2053 0
 5533 0058 3B1C     		mov	r3, r7
 5534 005a 1733     		add	r3, r3, #23
 5535 005c 3A1C     		mov	r2, r7
 5536 005e 1732     		add	r2, r2, #23
 5537 0060 1278     		ldrb	r2, [r2]
 5538 0062 013A     		sub	r2, r2, #1
 5539 0064 1A70     		strb	r2, [r3]
 5540              	.L286:
2051:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5541              		.loc 1 2051 0
 5542 0066 3B1C     		mov	r3, r7
 5543 0068 1733     		add	r3, r3, #23
 5544 006a 1B78     		ldrb	r3, [r3]
 5545 006c 002B     		cmp	r3, #0
 5546 006e 0AD0     		beq	.L287
2051:../Generated_Code/UTIL1.c ****   while (nofDigits>0 && HexToDec(&p, &v)==ERR_OK) {
 5547              		.loc 1 2051 0 is_stmt 0
 5548 0070 3A1C     		mov	r2, r7
 5549 0072 1032     		add	r2, r2, #16
 5550 0074 3B1C     		mov	r3, r7
 5551 0076 0F33     		add	r3, r3, #15
 5552 0078 101C     		mov	r0, r2
 5553 007a 191C     		mov	r1, r3
 5554 007c FFF7FEFF 		bl	HexToDec
 5555 0080 031C     		mov	r3, r0
 5556 0082 002B     		cmp	r3, #0
 5557 0084 DDD0     		beq	.L288
 5558              	.L287:
2054:../Generated_Code/UTIL1.c ****   } /* while */
2055:../Generated_Code/UTIL1.c ****   *str = p;
 5559              		.loc 1 2055 0 is_stmt 1
 5560 0086 3A69     		ldr	r2, [r7, #16]
 5561 0088 7B68     		ldr	r3, [r7, #4]
 5562 008a 1A60     		str	r2, [r3]
2056:../Generated_Code/UTIL1.c ****   return ERR_OK;
 5563              		.loc 1 2056 0
 5564 008c 0023     		mov	r3, #0
 5565              	.L289:
2057:../Generated_Code/UTIL1.c **** }
 5566              		.loc 1 2057 0
 5567 008e 181C     		mov	r0, r3
 5568 0090 BD46     		mov	sp, r7
 5569 0092 06B0     		add	sp, sp, #24
 5570              		@ sp needed for prologue
 5571 0094 80BD     		pop	{r7, pc}
 5572              		.cfi_endproc
 5573              	.LFE47:
 5575 0096 C046     		.section	.text.UTIL1_strtailcmp,"ax",%progbits
 5576              		.align	2
 5577              		.global	UTIL1_strtailcmp
 5578              		.code	16
 5579              		.thumb_func
 5581              	UTIL1_strtailcmp:
 5582              	.LFB48:
2058:../Generated_Code/UTIL1.c **** 
2059:../Generated_Code/UTIL1.c **** /*
2060:../Generated_Code/UTIL1.c **** ** ===================================================================
2061:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strtailcmp (component Utility)
2062:../Generated_Code/UTIL1.c **** **     Description :
2063:../Generated_Code/UTIL1.c **** **         Compares the tail of a string and returns 0 if it matches, 1
2064:../Generated_Code/UTIL1.c **** **         otherwise
2065:../Generated_Code/UTIL1.c **** **     Parameters  :
2066:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2067:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string. This string is compared
2068:../Generated_Code/UTIL1.c **** **                           if it contains the tail.
2069:../Generated_Code/UTIL1.c **** **       * tail            - Pointer to tail string.
2070:../Generated_Code/UTIL1.c **** **     Returns     :
2071:../Generated_Code/UTIL1.c **** **         ---             - returns 0 if tail matches, -1 otherwise
2072:../Generated_Code/UTIL1.c **** ** ===================================================================
2073:../Generated_Code/UTIL1.c **** */
2074:../Generated_Code/UTIL1.c **** uint8_t UTIL1_strtailcmp(const uint8_t *str, const uint8_t *tail)
2075:../Generated_Code/UTIL1.c **** {
 5583              		.loc 1 2075 0
 5584              		.cfi_startproc
 5585 0000 80B5     		push	{r7, lr}
 5586              	.LCFI144:
 5587              		.cfi_def_cfa_offset 8
 5588              		.cfi_offset 7, -8
 5589              		.cfi_offset 14, -4
 5590 0002 84B0     		sub	sp, sp, #16
 5591              	.LCFI145:
 5592              		.cfi_def_cfa_offset 24
 5593 0004 00AF     		add	r7, sp, #0
 5594              	.LCFI146:
 5595              		.cfi_def_cfa_register 7
 5596 0006 7860     		str	r0, [r7, #4]
 5597 0008 3960     		str	r1, [r7]
2076:../Generated_Code/UTIL1.c ****   int i, j;
2077:../Generated_Code/UTIL1.c **** 
2078:../Generated_Code/UTIL1.c ****   i = (int)UTIL1_strlen((char*)str);
 5598              		.loc 1 2078 0
 5599 000a 7B68     		ldr	r3, [r7, #4]
 5600 000c 181C     		mov	r0, r3
 5601 000e FFF7FEFF 		bl	strlen
 5602 0012 031C     		mov	r3, r0
 5603 0014 FB60     		str	r3, [r7, #12]
2079:../Generated_Code/UTIL1.c ****   j = (int)UTIL1_strlen((char*)tail);
 5604              		.loc 1 2079 0
 5605 0016 3B68     		ldr	r3, [r7]
 5606 0018 181C     		mov	r0, r3
 5607 001a FFF7FEFF 		bl	strlen
 5608 001e 031C     		mov	r3, r0
 5609 0020 BB60     		str	r3, [r7, #8]
2080:../Generated_Code/UTIL1.c ****   if (j>i) { /* str is smaller than tail */
 5610              		.loc 1 2080 0
 5611 0022 BA68     		ldr	r2, [r7, #8]
 5612 0024 FB68     		ldr	r3, [r7, #12]
 5613 0026 9A42     		cmp	r2, r3
 5614 0028 0CDD     		ble	.L295
2081:../Generated_Code/UTIL1.c ****     return 1; /* cannot match */
 5615              		.loc 1 2081 0
 5616 002a 0123     		mov	r3, #1
 5617 002c 16E0     		b	.L292
 5618              	.L294:
2082:../Generated_Code/UTIL1.c ****   }
2083:../Generated_Code/UTIL1.c ****   /* compare strings */
2084:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
2085:../Generated_Code/UTIL1.c ****     i--;
 5619              		.loc 1 2085 0
 5620 002e FB68     		ldr	r3, [r7, #12]
 5621 0030 013B     		sub	r3, r3, #1
 5622 0032 FB60     		str	r3, [r7, #12]
2086:../Generated_Code/UTIL1.c ****     j--;
 5623              		.loc 1 2086 0
 5624 0034 BB68     		ldr	r3, [r7, #8]
 5625 0036 013B     		sub	r3, r3, #1
 5626 0038 BB60     		str	r3, [r7, #8]
2087:../Generated_Code/UTIL1.c ****     if (j<0) {
 5627              		.loc 1 2087 0
 5628 003a BB68     		ldr	r3, [r7, #8]
 5629 003c 002B     		cmp	r3, #0
 5630 003e 02DA     		bge	.L293
2088:../Generated_Code/UTIL1.c ****       return 0; /* match */
 5631              		.loc 1 2088 0
 5632 0040 0023     		mov	r3, #0
 5633 0042 0BE0     		b	.L292
 5634              	.L295:
2084:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
 5635              		.loc 1 2084 0
 5636 0044 C046     		mov	r8, r8
 5637              	.L293:
2084:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
 5638              		.loc 1 2084 0 is_stmt 0
 5639 0046 FB68     		ldr	r3, [r7, #12]
 5640 0048 7A68     		ldr	r2, [r7, #4]
 5641 004a D318     		add	r3, r2, r3
 5642 004c 1A78     		ldrb	r2, [r3]
 5643 004e BB68     		ldr	r3, [r7, #8]
 5644 0050 3968     		ldr	r1, [r7]
 5645 0052 CB18     		add	r3, r1, r3
 5646 0054 1B78     		ldrb	r3, [r3]
 5647 0056 9A42     		cmp	r2, r3
 5648 0058 E9D0     		beq	.L294
2089:../Generated_Code/UTIL1.c ****     }
2090:../Generated_Code/UTIL1.c ****   }
2091:../Generated_Code/UTIL1.c ****   return 1; /* !=0 means no match */
 5649              		.loc 1 2091 0 is_stmt 1
 5650 005a 0123     		mov	r3, #1
 5651              	.L292:
2092:../Generated_Code/UTIL1.c **** }
 5652              		.loc 1 2092 0
 5653 005c 181C     		mov	r0, r3
 5654 005e BD46     		mov	sp, r7
 5655 0060 04B0     		add	sp, sp, #16
 5656              		@ sp needed for prologue
 5657 0062 80BD     		pop	{r7, pc}
 5658              		.cfi_endproc
 5659              	.LFE48:
 5661              		.section	.text.UTIL1_strCutTail,"ax",%progbits
 5662              		.align	2
 5663              		.global	UTIL1_strCutTail
 5664              		.code	16
 5665              		.thumb_func
 5667              	UTIL1_strCutTail:
 5668              	.LFB49:
2093:../Generated_Code/UTIL1.c **** 
2094:../Generated_Code/UTIL1.c **** /*
2095:../Generated_Code/UTIL1.c **** ** ===================================================================
2096:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strCutTail (component Utility)
2097:../Generated_Code/UTIL1.c **** **     Description :
2098:../Generated_Code/UTIL1.c **** **         Removes a tailing substring from a string. The string passed
2099:../Generated_Code/UTIL1.c **** **         will be modified (the tail is cut by writing a zero byte to
2100:../Generated_Code/UTIL1.c **** **         the string!)
2101:../Generated_Code/UTIL1.c **** **     Parameters  :
2102:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2103:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string where to remove the tail
2104:../Generated_Code/UTIL1.c **** **       * tail            - Pointer to substring to remove
2105:../Generated_Code/UTIL1.c **** **     Returns     :
2106:../Generated_Code/UTIL1.c **** **         ---             - Error code, ERR_OK if no error, otherwise
2107:../Generated_Code/UTIL1.c **** **                           ERR_FAIL if tail is not found
2108:../Generated_Code/UTIL1.c **** ** ===================================================================
2109:../Generated_Code/UTIL1.c **** */
2110:../Generated_Code/UTIL1.c **** uint8_t UTIL1_strCutTail(uint8_t *str, uint8_t *tail)
2111:../Generated_Code/UTIL1.c **** {
 5669              		.loc 1 2111 0
 5670              		.cfi_startproc
 5671 0000 80B5     		push	{r7, lr}
 5672              	.LCFI147:
 5673              		.cfi_def_cfa_offset 8
 5674              		.cfi_offset 7, -8
 5675              		.cfi_offset 14, -4
 5676 0002 84B0     		sub	sp, sp, #16
 5677              	.LCFI148:
 5678              		.cfi_def_cfa_offset 24
 5679 0004 00AF     		add	r7, sp, #0
 5680              	.LCFI149:
 5681              		.cfi_def_cfa_register 7
 5682 0006 7860     		str	r0, [r7, #4]
 5683 0008 3960     		str	r1, [r7]
2112:../Generated_Code/UTIL1.c ****   /* cut the tail from the string */
2113:../Generated_Code/UTIL1.c ****   size_t strLen, tailLen;
2114:../Generated_Code/UTIL1.c **** 
2115:../Generated_Code/UTIL1.c ****   if (UTIL1_strtailcmp(str, tail)!=0) { /* check if tail is present */
 5684              		.loc 1 2115 0
 5685 000a 7A68     		ldr	r2, [r7, #4]
 5686 000c 3B68     		ldr	r3, [r7]
 5687 000e 101C     		mov	r0, r2
 5688 0010 191C     		mov	r1, r3
 5689 0012 FFF7FEFF 		bl	UTIL1_strtailcmp
 5690 0016 031C     		mov	r3, r0
 5691 0018 002B     		cmp	r3, #0
 5692 001a 01D0     		beq	.L297
2116:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* tail not found */
 5693              		.loc 1 2116 0
 5694 001c 1B23     		mov	r3, #27
 5695 001e 13E0     		b	.L298
 5696              	.L297:
2117:../Generated_Code/UTIL1.c ****   }
2118:../Generated_Code/UTIL1.c ****   tailLen = UTIL1_strlen((char*)tail);
 5697              		.loc 1 2118 0
 5698 0020 3B68     		ldr	r3, [r7]
 5699 0022 181C     		mov	r0, r3
 5700 0024 FFF7FEFF 		bl	strlen
 5701 0028 031C     		mov	r3, r0
 5702 002a FB60     		str	r3, [r7, #12]
2119:../Generated_Code/UTIL1.c ****   strLen = UTIL1_strlen((char*)str);
 5703              		.loc 1 2119 0
 5704 002c 7B68     		ldr	r3, [r7, #4]
 5705 002e 181C     		mov	r0, r3
 5706 0030 FFF7FEFF 		bl	strlen
 5707 0034 031C     		mov	r3, r0
 5708 0036 BB60     		str	r3, [r7, #8]
2120:../Generated_Code/UTIL1.c ****   /* write \0 to cut the tail */
2121:../Generated_Code/UTIL1.c ****   str[strLen-tailLen] = '\0';
 5709              		.loc 1 2121 0
 5710 0038 BA68     		ldr	r2, [r7, #8]
 5711 003a FB68     		ldr	r3, [r7, #12]
 5712 003c D31A     		sub	r3, r2, r3
 5713 003e 7A68     		ldr	r2, [r7, #4]
 5714 0040 D318     		add	r3, r2, r3
 5715 0042 0022     		mov	r2, #0
 5716 0044 1A70     		strb	r2, [r3]
2122:../Generated_Code/UTIL1.c ****   return ERR_OK;
 5717              		.loc 1 2122 0
 5718 0046 0023     		mov	r3, #0
 5719              	.L298:
2123:../Generated_Code/UTIL1.c **** }
 5720              		.loc 1 2123 0
 5721 0048 181C     		mov	r0, r3
 5722 004a BD46     		mov	sp, r7
 5723 004c 04B0     		add	sp, sp, #16
 5724              		@ sp needed for prologue
 5725 004e 80BD     		pop	{r7, pc}
 5726              		.cfi_endproc
 5727              	.LFE49:
 5729              		.section	.text.UTIL1_strcatNum32sDotValue100,"ax",%progbits
 5730              		.align	2
 5731              		.global	UTIL1_strcatNum32sDotValue100
 5732              		.code	16
 5733              		.thumb_func
 5735              	UTIL1_strcatNum32sDotValue100:
 5736              	.LFB50:
2124:../Generated_Code/UTIL1.c **** 
2125:../Generated_Code/UTIL1.c **** /*
2126:../Generated_Code/UTIL1.c **** ** ===================================================================
2127:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32sDotValue100 (component Utility)
2128:../Generated_Code/UTIL1.c **** **     Description :
2129:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer. The value
2130:../Generated_Code/UTIL1.c **** **         is in 1/100 units.  For example for the value -13456 it will
2131:../Generated_Code/UTIL1.c **** **         append the string "-134.56"
2132:../Generated_Code/UTIL1.c **** **     Parameters  :
2133:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2134:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
2135:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
2136:../Generated_Code/UTIL1.c **** **                           bytes).
2137:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
2138:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2139:../Generated_Code/UTIL1.c **** ** ===================================================================
2140:../Generated_Code/UTIL1.c **** */
2141:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32sDotValue100(uint8_t *dst, size_t dstSize, int32_t num)
2142:../Generated_Code/UTIL1.c **** {
 5737              		.loc 1 2142 0
 5738              		.cfi_startproc
 5739 0000 80B5     		push	{r7, lr}
 5740              	.LCFI150:
 5741              		.cfi_def_cfa_offset 8
 5742              		.cfi_offset 7, -8
 5743              		.cfi_offset 14, -4
 5744 0002 86B0     		sub	sp, sp, #24
 5745              	.LCFI151:
 5746              		.cfi_def_cfa_offset 32
 5747 0004 02AF     		add	r7, sp, #8
 5748              	.LCFI152:
 5749              		.cfi_def_cfa 7, 24
 5750 0006 F860     		str	r0, [r7, #12]
 5751 0008 B960     		str	r1, [r7, #8]
 5752 000a 7A60     		str	r2, [r7, #4]
2143:../Generated_Code/UTIL1.c ****   if (num<0 && (num/100)==0) { /* e.g. -53 ==> write sign, as strcatNum32() below will not know tha
 5753              		.loc 1 2143 0
 5754 000c 7B68     		ldr	r3, [r7, #4]
 5755 000e 002B     		cmp	r3, #0
 5756 0010 0ADA     		bge	.L300
 5757              		.loc 1 2143 0 is_stmt 0
 5758 0012 7B68     		ldr	r3, [r7, #4]
 5759 0014 6333     		add	r3, r3, #99
 5760 0016 C62B     		cmp	r3, #198
 5761 0018 06D8     		bhi	.L300
2144:../Generated_Code/UTIL1.c ****     UTIL1_chcat(dst, dstSize, '-');
 5762              		.loc 1 2144 0 is_stmt 1
 5763 001a FA68     		ldr	r2, [r7, #12]
 5764 001c BB68     		ldr	r3, [r7, #8]
 5765 001e 101C     		mov	r0, r2
 5766 0020 191C     		mov	r1, r3
 5767 0022 2D22     		mov	r2, #45
 5768 0024 FFF7FEFF 		bl	UTIL1_chcat
 5769              	.L300:
2145:../Generated_Code/UTIL1.c ****   }
2146:../Generated_Code/UTIL1.c ****   UTIL1_strcatNum32s(dst, dstSize, num/100);
 5770              		.loc 1 2146 0
 5771 0028 7B68     		ldr	r3, [r7, #4]
 5772 002a 181C     		mov	r0, r3
 5773 002c 6421     		mov	r1, #100
 5774 002e FFF7FEFF 		bl	__aeabi_idiv
 5775 0032 031C     		mov	r3, r0
 5776 0034 F968     		ldr	r1, [r7, #12]
 5777 0036 BA68     		ldr	r2, [r7, #8]
 5778 0038 081C     		mov	r0, r1
 5779 003a 111C     		mov	r1, r2
 5780 003c 1A1C     		mov	r2, r3
 5781 003e FFF7FEFF 		bl	UTIL1_strcatNum32s
2147:../Generated_Code/UTIL1.c ****   UTIL1_chcat(dst, dstSize, '.');
 5782              		.loc 1 2147 0
 5783 0042 FA68     		ldr	r2, [r7, #12]
 5784 0044 BB68     		ldr	r3, [r7, #8]
 5785 0046 101C     		mov	r0, r2
 5786 0048 191C     		mov	r1, r3
 5787 004a 2E22     		mov	r2, #46
 5788 004c FFF7FEFF 		bl	UTIL1_chcat
2148:../Generated_Code/UTIL1.c ****   if (num<0) {
 5789              		.loc 1 2148 0
 5790 0050 7B68     		ldr	r3, [r7, #4]
 5791 0052 002B     		cmp	r3, #0
 5792 0054 02DA     		bge	.L301
2149:../Generated_Code/UTIL1.c ****     num = -num;
 5793              		.loc 1 2149 0
 5794 0056 7B68     		ldr	r3, [r7, #4]
 5795 0058 5B42     		neg	r3, r3
 5796 005a 7B60     		str	r3, [r7, #4]
 5797              	.L301:
2150:../Generated_Code/UTIL1.c ****   }
2151:../Generated_Code/UTIL1.c ****   UTIL1_strcatNum16uFormatted(dst, dstSize, (uint16_t)((unsigned)num%100U), '0', 2);
 5798              		.loc 1 2151 0
 5799 005c 7B68     		ldr	r3, [r7, #4]
 5800 005e 181C     		mov	r0, r3
 5801 0060 6421     		mov	r1, #100
 5802 0062 FFF7FEFF 		bl	__aeabi_uidivmod
 5803 0066 0B1C     		mov	r3, r1
 5804 0068 9BB2     		uxth	r3, r3
 5805 006a F968     		ldr	r1, [r7, #12]
 5806 006c BA68     		ldr	r2, [r7, #8]
 5807 006e 0220     		mov	r0, #2
 5808 0070 0090     		str	r0, [sp]
 5809 0072 081C     		mov	r0, r1
 5810 0074 111C     		mov	r1, r2
 5811 0076 1A1C     		mov	r2, r3
 5812 0078 3023     		mov	r3, #48
 5813 007a FFF7FEFF 		bl	UTIL1_strcatNum16uFormatted
2152:../Generated_Code/UTIL1.c **** }
 5814              		.loc 1 2152 0
 5815 007e BD46     		mov	sp, r7
 5816 0080 04B0     		add	sp, sp, #16
 5817              		@ sp needed for prologue
 5818 0082 80BD     		pop	{r7, pc}
 5819              		.cfi_endproc
 5820              	.LFE50:
 5822              		.section	.text.UTIL1_strFind,"ax",%progbits
 5823              		.align	2
 5824              		.global	UTIL1_strFind
 5825              		.code	16
 5826              		.thumb_func
 5828              	UTIL1_strFind:
 5829              	.LFB51:
2153:../Generated_Code/UTIL1.c **** 
2154:../Generated_Code/UTIL1.c **** /*
2155:../Generated_Code/UTIL1.c **** ** ===================================================================
2156:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strFind (component Utility)
2157:../Generated_Code/UTIL1.c **** **     Description :
2158:../Generated_Code/UTIL1.c **** **         Searches a substring inside a string and returns the
2159:../Generated_Code/UTIL1.c **** **         position.
2160:../Generated_Code/UTIL1.c **** **     Parameters  :
2161:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2162:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string which will be searched
2163:../Generated_Code/UTIL1.c **** **       * subStr          - Pointer to substring to search
2164:../Generated_Code/UTIL1.c **** **                           inside str
2165:../Generated_Code/UTIL1.c **** **     Returns     :
2166:../Generated_Code/UTIL1.c **** **         ---             - -1 if not found, otherwise the character
2167:../Generated_Code/UTIL1.c **** **                           index.
2168:../Generated_Code/UTIL1.c **** ** ===================================================================
2169:../Generated_Code/UTIL1.c **** */
2170:../Generated_Code/UTIL1.c **** int16_t UTIL1_strFind(uint8_t *str, uint8_t *subStr)
2171:../Generated_Code/UTIL1.c **** {
 5830              		.loc 1 2171 0
 5831              		.cfi_startproc
 5832 0000 80B5     		push	{r7, lr}
 5833              	.LCFI153:
 5834              		.cfi_def_cfa_offset 8
 5835              		.cfi_offset 7, -8
 5836              		.cfi_offset 14, -4
 5837 0002 84B0     		sub	sp, sp, #16
 5838              	.LCFI154:
 5839              		.cfi_def_cfa_offset 24
 5840 0004 00AF     		add	r7, sp, #0
 5841              	.LCFI155:
 5842              		.cfi_def_cfa_register 7
 5843 0006 7860     		str	r0, [r7, #4]
 5844 0008 3960     		str	r1, [r7]
2172:../Generated_Code/UTIL1.c ****   int16_t i, len;
2173:../Generated_Code/UTIL1.c **** 
2174:../Generated_Code/UTIL1.c ****   len = (int16_t)UTIL1_strlen((char*)subStr);
 5845              		.loc 1 2174 0
 5846 000a 3B68     		ldr	r3, [r7]
 5847 000c 181C     		mov	r0, r3
 5848 000e FFF7FEFF 		bl	strlen
 5849 0012 021C     		mov	r2, r0
 5850 0014 3B1C     		mov	r3, r7
 5851 0016 0C33     		add	r3, r3, #12
 5852 0018 1A80     		strh	r2, [r3]
2175:../Generated_Code/UTIL1.c ****   for (i=0; *str!='\0'; i++, str++) {
 5853              		.loc 1 2175 0
 5854 001a 3B1C     		mov	r3, r7
 5855 001c 0E33     		add	r3, r3, #14
 5856 001e 0022     		mov	r2, #0
 5857 0020 1A80     		strh	r2, [r3]
 5858 0022 1BE0     		b	.L303
 5859              	.L306:
2176:../Generated_Code/UTIL1.c ****     if (UTIL1_strncmp((char*)str, (char*)subStr, len)==0) {
 5860              		.loc 1 2176 0
 5861 0024 3B1C     		mov	r3, r7
 5862 0026 0C33     		add	r3, r3, #12
 5863 0028 0022     		mov	r2, #0
 5864 002a 9B5E     		ldrsh	r3, [r3, r2]
 5865 002c 7968     		ldr	r1, [r7, #4]
 5866 002e 3A68     		ldr	r2, [r7]
 5867 0030 081C     		mov	r0, r1
 5868 0032 111C     		mov	r1, r2
 5869 0034 1A1C     		mov	r2, r3
 5870 0036 FFF7FEFF 		bl	strncmp
 5871 003a 031C     		mov	r3, r0
 5872 003c 002B     		cmp	r3, #0
 5873 003e 03D1     		bne	.L304
2177:../Generated_Code/UTIL1.c ****       return i; /* found */
 5874              		.loc 1 2177 0
 5875 0040 3B1C     		mov	r3, r7
 5876 0042 0E33     		add	r3, r3, #14
 5877 0044 1B88     		ldrh	r3, [r3]
 5878 0046 0EE0     		b	.L305
 5879              	.L304:
2175:../Generated_Code/UTIL1.c ****   for (i=0; *str!='\0'; i++, str++) {
 5880              		.loc 1 2175 0
 5881 0048 3B1C     		mov	r3, r7
 5882 004a 0E33     		add	r3, r3, #14
 5883 004c 3A1C     		mov	r2, r7
 5884 004e 0E32     		add	r2, r2, #14
 5885 0050 1288     		ldrh	r2, [r2]
 5886 0052 0132     		add	r2, r2, #1
 5887 0054 1A80     		strh	r2, [r3]
 5888 0056 7B68     		ldr	r3, [r7, #4]
 5889 0058 0133     		add	r3, r3, #1
 5890 005a 7B60     		str	r3, [r7, #4]
 5891              	.L303:
2175:../Generated_Code/UTIL1.c ****   for (i=0; *str!='\0'; i++, str++) {
 5892              		.loc 1 2175 0 is_stmt 0
 5893 005c 7B68     		ldr	r3, [r7, #4]
 5894 005e 1B78     		ldrb	r3, [r3]
 5895 0060 002B     		cmp	r3, #0
 5896 0062 DFD1     		bne	.L306
2178:../Generated_Code/UTIL1.c ****     }
2179:../Generated_Code/UTIL1.c ****   }
2180:../Generated_Code/UTIL1.c ****   return -1; /* not found */
 5897              		.loc 1 2180 0 is_stmt 1
 5898 0064 024B     		ldr	r3, .L307
 5899              	.L305:
 5900 0066 1BB2     		sxth	r3, r3
2181:../Generated_Code/UTIL1.c **** }
 5901              		.loc 1 2181 0
 5902 0068 181C     		mov	r0, r3
 5903 006a BD46     		mov	sp, r7
 5904 006c 04B0     		add	sp, sp, #16
 5905              		@ sp needed for prologue
 5906 006e 80BD     		pop	{r7, pc}
 5907              	.L308:
 5908              		.align	2
 5909              	.L307:
 5910 0070 FFFF0000 		.word	65535
 5911              		.cfi_endproc
 5912              	.LFE51:
 5914              		.section	.text.UTIL1_ScanSeparatedNumbers,"ax",%progbits
 5915              		.align	2
 5916              		.global	UTIL1_ScanSeparatedNumbers
 5917              		.code	16
 5918              		.thumb_func
 5920              	UTIL1_ScanSeparatedNumbers:
 5921              	.LFB52:
2182:../Generated_Code/UTIL1.c **** 
2183:../Generated_Code/UTIL1.c **** /*
2184:../Generated_Code/UTIL1.c **** ** ===================================================================
2185:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanSeparatedNumbers (component Utility)
2186:../Generated_Code/UTIL1.c **** **     Description :
2187:../Generated_Code/UTIL1.c **** **         Scans multiple numbers separated by character, e.g. "123.68.
2188:../Generated_Code/UTIL1.c **** **         5.3"
2189:../Generated_Code/UTIL1.c **** **     Parameters  :
2190:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2191:../Generated_Code/UTIL1.c **** **         str             - String to scan. It returns as well until
2192:../Generated_Code/UTIL1.c **** **                           where it has scanned
2193:../Generated_Code/UTIL1.c **** **       * values          - Pointer to array where to store the
2194:../Generated_Code/UTIL1.c **** **                           values
2195:../Generated_Code/UTIL1.c **** **         nofValues       - Number of values in the array
2196:../Generated_Code/UTIL1.c **** **         separator       - Character separator, e.g. '.'
2197:../Generated_Code/UTIL1.c **** **         numberType      - type of number to scan
2198:../Generated_Code/UTIL1.c **** **     Returns     :
2199:../Generated_Code/UTIL1.c **** **         ---             - Error code
2200:../Generated_Code/UTIL1.c **** ** ===================================================================
2201:../Generated_Code/UTIL1.c **** */
2202:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanSeparatedNumbers(const unsigned char **str, uint8_t *values, uint8_t nofValues, c
2203:../Generated_Code/UTIL1.c **** {
 5922              		.loc 1 2203 0
 5923              		.cfi_startproc
 5924 0000 90B5     		push	{r4, r7, lr}
 5925              	.LCFI156:
 5926              		.cfi_def_cfa_offset 12
 5927              		.cfi_offset 4, -12
 5928              		.cfi_offset 7, -8
 5929              		.cfi_offset 14, -4
 5930 0002 89B0     		sub	sp, sp, #36
 5931              	.LCFI157:
 5932              		.cfi_def_cfa_offset 48
 5933 0004 00AF     		add	r7, sp, #0
 5934              	.LCFI158:
 5935              		.cfi_def_cfa_register 7
 5936 0006 F860     		str	r0, [r7, #12]
 5937 0008 B960     		str	r1, [r7, #8]
 5938 000a 111C     		mov	r1, r2
 5939 000c 1A1C     		mov	r2, r3
 5940 000e FB1D     		add	r3, r7, #7
 5941 0010 1970     		strb	r1, [r3]
 5942 0012 BB1D     		add	r3, r7, #6
 5943 0014 1A70     		strb	r2, [r3]
2204:../Generated_Code/UTIL1.c ****   int i;
2205:../Generated_Code/UTIL1.c ****   uint8_t res;
2206:../Generated_Code/UTIL1.c ****   const unsigned char *p;
2207:../Generated_Code/UTIL1.c **** 
2208:../Generated_Code/UTIL1.c ****   if (nofValues<=1) {
 5944              		.loc 1 2208 0
 5945 0016 FB1D     		add	r3, r7, #7
 5946 0018 1B78     		ldrb	r3, [r3]
 5947 001a 012B     		cmp	r3, #1
 5948 001c 01D8     		bhi	.L310
2209:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* need at least two values */
 5949              		.loc 1 2209 0
 5950 001e 1B23     		mov	r3, #27
 5951 0020 54E0     		b	.L320
 5952              	.L310:
2210:../Generated_Code/UTIL1.c ****   }
2211:../Generated_Code/UTIL1.c ****   p = *str;
 5953              		.loc 1 2211 0
 5954 0022 FB68     		ldr	r3, [r7, #12]
 5955 0024 1B68     		ldr	r3, [r3]
 5956 0026 7B61     		str	r3, [r7, #20]
2212:../Generated_Code/UTIL1.c ****   for(i=0;i<nofValues;i++) {
 5957              		.loc 1 2212 0
 5958 0028 0023     		mov	r3, #0
 5959 002a FB61     		str	r3, [r7, #28]
 5960 002c 45E0     		b	.L312
 5961              	.L319:
2213:../Generated_Code/UTIL1.c ****     if (numberType==UTIL1_SEP_NUM_TYPE_UINT8) {
 5962              		.loc 1 2213 0
 5963 002e 3B1C     		mov	r3, r7
 5964 0030 3033     		add	r3, r3, #48
 5965 0032 1B78     		ldrb	r3, [r3]
 5966 0034 002B     		cmp	r3, #0
 5967 0036 0DD1     		bne	.L313
2214:../Generated_Code/UTIL1.c ****       res = UTIL1_ScanDecimal8uNumber(&p, &values[i]);
 5968              		.loc 1 2214 0
 5969 0038 FB69     		ldr	r3, [r7, #28]
 5970 003a BA68     		ldr	r2, [r7, #8]
 5971 003c D318     		add	r3, r2, r3
 5972 003e 3C1C     		mov	r4, r7
 5973 0040 1B34     		add	r4, r4, #27
 5974 0042 3A1C     		mov	r2, r7
 5975 0044 1432     		add	r2, r2, #20
 5976 0046 101C     		mov	r0, r2
 5977 0048 191C     		mov	r1, r3
 5978 004a FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 5979 004e 031C     		mov	r3, r0
 5980 0050 2370     		strb	r3, [r4]
 5981 0052 16E0     		b	.L314
 5982              	.L313:
2215:../Generated_Code/UTIL1.c ****     } else if (numberType==UTIL1_SEP_NUM_TYPE_UINT8_HEX_NO_PREFIX) {
 5983              		.loc 1 2215 0
 5984 0054 3B1C     		mov	r3, r7
 5985 0056 3033     		add	r3, r3, #48
 5986 0058 1B78     		ldrb	r3, [r3]
 5987 005a 012B     		cmp	r3, #1
 5988 005c 0DD1     		bne	.L315
2216:../Generated_Code/UTIL1.c ****       res = UTIL1_ScanHex8uNumberNoPrefix(&p, &values[i]);
 5989              		.loc 1 2216 0
 5990 005e FB69     		ldr	r3, [r7, #28]
 5991 0060 BA68     		ldr	r2, [r7, #8]
 5992 0062 D318     		add	r3, r2, r3
 5993 0064 3C1C     		mov	r4, r7
 5994 0066 1B34     		add	r4, r4, #27
 5995 0068 3A1C     		mov	r2, r7
 5996 006a 1432     		add	r2, r2, #20
 5997 006c 101C     		mov	r0, r2
 5998 006e 191C     		mov	r1, r3
 5999 0070 FFF7FEFF 		bl	UTIL1_ScanHex8uNumberNoPrefix
 6000 0074 031C     		mov	r3, r0
 6001 0076 2370     		strb	r3, [r4]
 6002 0078 03E0     		b	.L314
 6003              	.L315:
2217:../Generated_Code/UTIL1.c ****     } else {
2218:../Generated_Code/UTIL1.c ****       res = ERR_FAILED;
 6004              		.loc 1 2218 0
 6005 007a 3B1C     		mov	r3, r7
 6006 007c 1B33     		add	r3, r3, #27
 6007 007e 1B22     		mov	r2, #27
 6008 0080 1A70     		strb	r2, [r3]
 6009              	.L314:
2219:../Generated_Code/UTIL1.c ****     }
2220:../Generated_Code/UTIL1.c ****     if (res==ERR_OK) { /* parsing ok */
 6010              		.loc 1 2220 0
 6011 0082 3B1C     		mov	r3, r7
 6012 0084 1B33     		add	r3, r3, #27
 6013 0086 1B78     		ldrb	r3, [r3]
 6014 0088 002B     		cmp	r3, #0
 6015 008a 11D1     		bne	.L316
2221:../Generated_Code/UTIL1.c ****       if (i!=nofValues-1) {
 6016              		.loc 1 2221 0
 6017 008c FB1D     		add	r3, r7, #7
 6018 008e 1B78     		ldrb	r3, [r3]
 6019 0090 5A1E     		sub	r2, r3, #1
 6020 0092 FB69     		ldr	r3, [r7, #28]
 6021 0094 9A42     		cmp	r2, r3
 6022 0096 0DD0     		beq	.L317
2222:../Generated_Code/UTIL1.c ****         if ((*p)!=separator) { /* not last one */
 6023              		.loc 1 2222 0
 6024 0098 7B69     		ldr	r3, [r7, #20]
 6025 009a 1B78     		ldrb	r3, [r3]
 6026 009c BA1D     		add	r2, r7, #6
 6027 009e 1278     		ldrb	r2, [r2]
 6028 00a0 9A42     		cmp	r2, r3
 6029 00a2 01D0     		beq	.L318
2223:../Generated_Code/UTIL1.c ****           return ERR_FAILED; /* wrong separator */
 6030              		.loc 1 2223 0
 6031 00a4 1B23     		mov	r3, #27
 6032 00a6 11E0     		b	.L320
 6033              	.L318:
2224:../Generated_Code/UTIL1.c ****         } /* if */
2225:../Generated_Code/UTIL1.c ****         p++; /* skip separator and continue scanning */
 6034              		.loc 1 2225 0
 6035 00a8 7B69     		ldr	r3, [r7, #20]
 6036 00aa 0133     		add	r3, r3, #1
 6037 00ac 7B61     		str	r3, [r7, #20]
 6038 00ae 01E0     		b	.L317
 6039              	.L316:
2226:../Generated_Code/UTIL1.c ****       } /* if */
2227:../Generated_Code/UTIL1.c ****     } else {
2228:../Generated_Code/UTIL1.c ****       return ERR_FAILED; /* failed parsing number */
 6040              		.loc 1 2228 0
 6041 00b0 1B23     		mov	r3, #27
 6042 00b2 0BE0     		b	.L320
 6043              	.L317:
2212:../Generated_Code/UTIL1.c ****   for(i=0;i<nofValues;i++) {
 6044              		.loc 1 2212 0
 6045 00b4 FB69     		ldr	r3, [r7, #28]
 6046 00b6 0133     		add	r3, r3, #1
 6047 00b8 FB61     		str	r3, [r7, #28]
 6048              	.L312:
2212:../Generated_Code/UTIL1.c ****   for(i=0;i<nofValues;i++) {
 6049              		.loc 1 2212 0 is_stmt 0
 6050 00ba FB1D     		add	r3, r7, #7
 6051 00bc 1A78     		ldrb	r2, [r3]
 6052 00be FB69     		ldr	r3, [r7, #28]
 6053 00c0 9A42     		cmp	r2, r3
 6054 00c2 B4DC     		bgt	.L319
2229:../Generated_Code/UTIL1.c ****     } /* if */
2230:../Generated_Code/UTIL1.c ****   } /* for */
2231:../Generated_Code/UTIL1.c ****   *str = p;
 6055              		.loc 1 2231 0 is_stmt 1
 6056 00c4 7A69     		ldr	r2, [r7, #20]
 6057 00c6 FB68     		ldr	r3, [r7, #12]
 6058 00c8 1A60     		str	r2, [r3]
2232:../Generated_Code/UTIL1.c ****   return ERR_OK;
 6059              		.loc 1 2232 0
 6060 00ca 0023     		mov	r3, #0
 6061              	.L320:
2233:../Generated_Code/UTIL1.c **** }
 6062              		.loc 1 2233 0
 6063 00cc 181C     		mov	r0, r3
 6064 00ce BD46     		mov	sp, r7
 6065 00d0 09B0     		add	sp, sp, #36
 6066              		@ sp needed for prologue
 6067 00d2 90BD     		pop	{r4, r7, pc}
 6068              		.cfi_endproc
 6069              	.LFE52:
 6071              		.section	.text.UTIL1_ScanDoubleQuotedString,"ax",%progbits
 6072              		.align	2
 6073              		.global	UTIL1_ScanDoubleQuotedString
 6074              		.code	16
 6075              		.thumb_func
 6077              	UTIL1_ScanDoubleQuotedString:
 6078              	.LFB53:
2234:../Generated_Code/UTIL1.c **** 
2235:../Generated_Code/UTIL1.c **** /*
2236:../Generated_Code/UTIL1.c **** ** ===================================================================
2237:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDoubleQuotedString (component Utility)
2238:../Generated_Code/UTIL1.c **** **     Description :
2239:../Generated_Code/UTIL1.c **** **         Scans a string inside double quotes and returns it without
2240:../Generated_Code/UTIL1.c **** **         the double quotes.
2241:../Generated_Code/UTIL1.c **** **     Parameters  :
2242:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2243:../Generated_Code/UTIL1.c **** **         cmd             - Pointer to pointer to string to parse.
2244:../Generated_Code/UTIL1.c **** **                           This pointer will be advanced as much as
2245:../Generated_Code/UTIL1.c **** **                           parsing is done.
2246:../Generated_Code/UTIL1.c **** **       * buf             - Pointer to buffer where to store the string
2247:../Generated_Code/UTIL1.c **** **         bufSize         - Size of buffer in bytes
2248:../Generated_Code/UTIL1.c **** **     Returns     :
2249:../Generated_Code/UTIL1.c **** **         ---             - Error code
2250:../Generated_Code/UTIL1.c **** ** ===================================================================
2251:../Generated_Code/UTIL1.c **** */
2252:../Generated_Code/UTIL1.c **** uint8_t UTIL1_ScanDoubleQuotedString(const uint8_t **cmd, uint8_t *buf, size_t bufSize)
2253:../Generated_Code/UTIL1.c **** {
 6079              		.loc 1 2253 0
 6080              		.cfi_startproc
 6081 0000 80B5     		push	{r7, lr}
 6082              	.LCFI159:
 6083              		.cfi_def_cfa_offset 8
 6084              		.cfi_offset 7, -8
 6085              		.cfi_offset 14, -4
 6086 0002 86B0     		sub	sp, sp, #24
 6087              	.LCFI160:
 6088              		.cfi_def_cfa_offset 32
 6089 0004 00AF     		add	r7, sp, #0
 6090              	.LCFI161:
 6091              		.cfi_def_cfa_register 7
 6092 0006 F860     		str	r0, [r7, #12]
 6093 0008 B960     		str	r1, [r7, #8]
 6094 000a 7A60     		str	r2, [r7, #4]
2254:../Generated_Code/UTIL1.c ****   const uint8_t *p = *cmd;
 6095              		.loc 1 2254 0
 6096 000c FB68     		ldr	r3, [r7, #12]
 6097 000e 1B68     		ldr	r3, [r3]
 6098 0010 7B61     		str	r3, [r7, #20]
2255:../Generated_Code/UTIL1.c **** 
2256:../Generated_Code/UTIL1.c ****   if (bufSize==1) {
 6099              		.loc 1 2256 0
 6100 0012 7B68     		ldr	r3, [r7, #4]
 6101 0014 012B     		cmp	r3, #1
 6102 0016 01D1     		bne	.L322
2257:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* buffer too small */
 6103              		.loc 1 2257 0
 6104 0018 1B23     		mov	r3, #27
 6105 001a 3AE0     		b	.L323
 6106              	.L322:
2258:../Generated_Code/UTIL1.c ****   }
2259:../Generated_Code/UTIL1.c ****   buf[bufSize-1] = '\0'; /* terminate buffer */
 6107              		.loc 1 2259 0
 6108 001c 7B68     		ldr	r3, [r7, #4]
 6109 001e 013B     		sub	r3, r3, #1
 6110 0020 BA68     		ldr	r2, [r7, #8]
 6111 0022 D318     		add	r3, r2, r3
 6112 0024 0022     		mov	r2, #0
 6113 0026 1A70     		strb	r2, [r3]
2260:../Generated_Code/UTIL1.c ****   bufSize--;
 6114              		.loc 1 2260 0
 6115 0028 7B68     		ldr	r3, [r7, #4]
 6116 002a 013B     		sub	r3, r3, #1
 6117 002c 7B60     		str	r3, [r7, #4]
2261:../Generated_Code/UTIL1.c ****   if (*p!='\"') {
 6118              		.loc 1 2261 0
 6119 002e 7B69     		ldr	r3, [r7, #20]
 6120 0030 1B78     		ldrb	r3, [r3]
 6121 0032 222B     		cmp	r3, #34
 6122 0034 01D0     		beq	.L324
2262:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* does not start with double quote */
 6123              		.loc 1 2262 0
 6124 0036 1B23     		mov	r3, #27
 6125 0038 2BE0     		b	.L323
 6126              	.L324:
2263:../Generated_Code/UTIL1.c ****   }
2264:../Generated_Code/UTIL1.c ****   p++; /* skip double quote */
 6127              		.loc 1 2264 0
 6128 003a 7B69     		ldr	r3, [r7, #20]
 6129 003c 0133     		add	r3, r3, #1
 6130 003e 7B61     		str	r3, [r7, #20]
2265:../Generated_Code/UTIL1.c ****   while(*p!='\"' && *p!='\0' && bufSize>0) {
 6131              		.loc 1 2265 0
 6132 0040 0CE0     		b	.L325
 6133              	.L327:
2266:../Generated_Code/UTIL1.c ****     *buf++ = *p++;
 6134              		.loc 1 2266 0
 6135 0042 7B69     		ldr	r3, [r7, #20]
 6136 0044 1A78     		ldrb	r2, [r3]
 6137 0046 BB68     		ldr	r3, [r7, #8]
 6138 0048 1A70     		strb	r2, [r3]
 6139 004a BB68     		ldr	r3, [r7, #8]
 6140 004c 0133     		add	r3, r3, #1
 6141 004e BB60     		str	r3, [r7, #8]
 6142 0050 7B69     		ldr	r3, [r7, #20]
 6143 0052 0133     		add	r3, r3, #1
 6144 0054 7B61     		str	r3, [r7, #20]
2267:../Generated_Code/UTIL1.c ****     bufSize--;
 6145              		.loc 1 2267 0
 6146 0056 7B68     		ldr	r3, [r7, #4]
 6147 0058 013B     		sub	r3, r3, #1
 6148 005a 7B60     		str	r3, [r7, #4]
 6149              	.L325:
2265:../Generated_Code/UTIL1.c ****   while(*p!='\"' && *p!='\0' && bufSize>0) {
 6150              		.loc 1 2265 0
 6151 005c 7B69     		ldr	r3, [r7, #20]
 6152 005e 1B78     		ldrb	r3, [r3]
 6153 0060 222B     		cmp	r3, #34
 6154 0062 06D0     		beq	.L326
2265:../Generated_Code/UTIL1.c ****   while(*p!='\"' && *p!='\0' && bufSize>0) {
 6155              		.loc 1 2265 0 is_stmt 0
 6156 0064 7B69     		ldr	r3, [r7, #20]
 6157 0066 1B78     		ldrb	r3, [r3]
 6158 0068 002B     		cmp	r3, #0
 6159 006a 02D0     		beq	.L326
2265:../Generated_Code/UTIL1.c ****   while(*p!='\"' && *p!='\0' && bufSize>0) {
 6160              		.loc 1 2265 0
 6161 006c 7B68     		ldr	r3, [r7, #4]
 6162 006e 002B     		cmp	r3, #0
 6163 0070 E7D1     		bne	.L327
 6164              	.L326:
2268:../Generated_Code/UTIL1.c ****   }
2269:../Generated_Code/UTIL1.c ****   if (*p!='\"') {
 6165              		.loc 1 2269 0 is_stmt 1
 6166 0072 7B69     		ldr	r3, [r7, #20]
 6167 0074 1B78     		ldrb	r3, [r3]
 6168 0076 222B     		cmp	r3, #34
 6169 0078 01D0     		beq	.L328
2270:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* no terminating double quote */
 6170              		.loc 1 2270 0
 6171 007a 1B23     		mov	r3, #27
 6172 007c 09E0     		b	.L323
 6173              	.L328:
2271:../Generated_Code/UTIL1.c ****   } else {
2272:../Generated_Code/UTIL1.c ****     p++; /* skip double quote */
 6174              		.loc 1 2272 0
 6175 007e 7B69     		ldr	r3, [r7, #20]
 6176 0080 0133     		add	r3, r3, #1
 6177 0082 7B61     		str	r3, [r7, #20]
2273:../Generated_Code/UTIL1.c ****     *buf = '\0'; /* terminate buffer */
 6178              		.loc 1 2273 0
 6179 0084 BB68     		ldr	r3, [r7, #8]
 6180 0086 0022     		mov	r2, #0
 6181 0088 1A70     		strb	r2, [r3]
2274:../Generated_Code/UTIL1.c ****   }
2275:../Generated_Code/UTIL1.c ****   *cmd = p; /* advance pointer */
 6182              		.loc 1 2275 0
 6183 008a FB68     		ldr	r3, [r7, #12]
 6184 008c 7A69     		ldr	r2, [r7, #20]
 6185 008e 1A60     		str	r2, [r3]
2276:../Generated_Code/UTIL1.c ****   return ERR_OK;
 6186              		.loc 1 2276 0
 6187 0090 0023     		mov	r3, #0
 6188              	.L323:
2277:../Generated_Code/UTIL1.c **** }
 6189              		.loc 1 2277 0
 6190 0092 181C     		mov	r0, r3
 6191 0094 BD46     		mov	sp, r7
 6192 0096 06B0     		add	sp, sp, #24
 6193              		@ sp needed for prologue
 6194 0098 80BD     		pop	{r7, pc}
 6195              		.cfi_endproc
 6196              	.LFE53:
 6198 009a C046     		.section	.text.UTIL1_strcatPad,"ax",%progbits
 6199              		.align	2
 6200              		.global	UTIL1_strcatPad
 6201              		.code	16
 6202              		.thumb_func
 6204              	UTIL1_strcatPad:
 6205              	.LFB54:
2278:../Generated_Code/UTIL1.c **** 
2279:../Generated_Code/UTIL1.c **** /*
2280:../Generated_Code/UTIL1.c **** ** ===================================================================
2281:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatPad (component Utility)
2282:../Generated_Code/UTIL1.c **** **     Description :
2283:../Generated_Code/UTIL1.c **** **         Same as normal strcat, but safe as it does not write beyond
2284:../Generated_Code/UTIL1.c **** **         the buffer. The buffer will be filled with a pad character
2285:../Generated_Code/UTIL1.c **** **         for a given length.
2286:../Generated_Code/UTIL1.c **** **     Parameters  :
2287:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2288:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
2289:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
2290:../Generated_Code/UTIL1.c **** **                           bytes).
2291:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
2292:../Generated_Code/UTIL1.c **** **         padChar         - Character to be used for padding
2293:../Generated_Code/UTIL1.c **** **         srcPadSize      - To which size the src string
2294:../Generated_Code/UTIL1.c **** **                           has to be padded.
2295:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2296:../Generated_Code/UTIL1.c **** ** ===================================================================
2297:../Generated_Code/UTIL1.c **** */
2298:../Generated_Code/UTIL1.c **** void UTIL1_strcatPad(uint8_t *dst, size_t dstSize, const unsigned char *src, char padChar, uint8_t 
2299:../Generated_Code/UTIL1.c **** {
 6206              		.loc 1 2299 0
 6207              		.cfi_startproc
 6208 0000 80B5     		push	{r7, lr}
 6209              	.LCFI162:
 6210              		.cfi_def_cfa_offset 8
 6211              		.cfi_offset 7, -8
 6212              		.cfi_offset 14, -4
 6213 0002 86B0     		sub	sp, sp, #24
 6214              	.LCFI163:
 6215              		.cfi_def_cfa_offset 32
 6216 0004 00AF     		add	r7, sp, #0
 6217              	.LCFI164:
 6218              		.cfi_def_cfa_register 7
 6219 0006 F860     		str	r0, [r7, #12]
 6220 0008 B960     		str	r1, [r7, #8]
 6221 000a 7A60     		str	r2, [r7, #4]
 6222 000c 1A1C     		mov	r2, r3
 6223 000e FB1C     		add	r3, r7, #3
 6224 0010 1A70     		strb	r2, [r3]
2300:../Generated_Code/UTIL1.c ****   uint8_t *p;
2301:../Generated_Code/UTIL1.c ****   size_t nof = 0;
 6225              		.loc 1 2301 0
 6226 0012 0023     		mov	r3, #0
 6227 0014 3B61     		str	r3, [r7, #16]
2302:../Generated_Code/UTIL1.c **** 
2303:../Generated_Code/UTIL1.c ****   if (dstSize<2) {
 6228              		.loc 1 2303 0
 6229 0016 BB68     		ldr	r3, [r7, #8]
 6230 0018 012B     		cmp	r3, #1
 6231 001a 54D9     		bls	.L340
 6232              	.L330:
2304:../Generated_Code/UTIL1.c ****     return; /* hmm, really to small for anything than the zero byte? */
2305:../Generated_Code/UTIL1.c ****   }
2306:../Generated_Code/UTIL1.c ****   p = dst;
 6233              		.loc 1 2306 0
 6234 001c FB68     		ldr	r3, [r7, #12]
 6235 001e 7B61     		str	r3, [r7, #20]
2307:../Generated_Code/UTIL1.c ****   while(*p != '\0') { /* find end of string */
 6236              		.loc 1 2307 0
 6237 0020 05E0     		b	.L332
 6238              	.L333:
2308:../Generated_Code/UTIL1.c ****     p++;
 6239              		.loc 1 2308 0
 6240 0022 7B69     		ldr	r3, [r7, #20]
 6241 0024 0133     		add	r3, r3, #1
 6242 0026 7B61     		str	r3, [r7, #20]
2309:../Generated_Code/UTIL1.c ****     nof++;
 6243              		.loc 1 2309 0
 6244 0028 3B69     		ldr	r3, [r7, #16]
 6245 002a 0133     		add	r3, r3, #1
 6246 002c 3B61     		str	r3, [r7, #16]
 6247              	.L332:
2307:../Generated_Code/UTIL1.c ****   while(*p != '\0') { /* find end of string */
 6248              		.loc 1 2307 0
 6249 002e 7B69     		ldr	r3, [r7, #20]
 6250 0030 1B78     		ldrb	r3, [r3]
 6251 0032 002B     		cmp	r3, #0
 6252 0034 F5D1     		bne	.L333
2310:../Generated_Code/UTIL1.c ****   }
2311:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst+nof, dstSize-nof, src); /* add string */
 6253              		.loc 1 2311 0
 6254 0036 FA68     		ldr	r2, [r7, #12]
 6255 0038 3B69     		ldr	r3, [r7, #16]
 6256 003a D118     		add	r1, r2, r3
 6257 003c BA68     		ldr	r2, [r7, #8]
 6258 003e 3B69     		ldr	r3, [r7, #16]
 6259 0040 D21A     		sub	r2, r2, r3
 6260 0042 7B68     		ldr	r3, [r7, #4]
 6261 0044 081C     		mov	r0, r1
 6262 0046 111C     		mov	r1, r2
 6263 0048 1A1C     		mov	r2, r3
 6264 004a FFF7FEFF 		bl	UTIL1_strcat
2312:../Generated_Code/UTIL1.c ****   dstSize -= nof;
 6265              		.loc 1 2312 0
 6266 004e BA68     		ldr	r2, [r7, #8]
 6267 0050 3B69     		ldr	r3, [r7, #16]
 6268 0052 D31A     		sub	r3, r2, r3
 6269 0054 BB60     		str	r3, [r7, #8]
2313:../Generated_Code/UTIL1.c ****   while(*p != '\0' && srcPadSize>0 && dstSize>1) {
 6270              		.loc 1 2313 0
 6271 0056 0CE0     		b	.L334
 6272              	.L336:
2314:../Generated_Code/UTIL1.c ****     p++;
 6273              		.loc 1 2314 0
 6274 0058 7B69     		ldr	r3, [r7, #20]
 6275 005a 0133     		add	r3, r3, #1
 6276 005c 7B61     		str	r3, [r7, #20]
2315:../Generated_Code/UTIL1.c ****     srcPadSize--;
 6277              		.loc 1 2315 0
 6278 005e 3B1C     		mov	r3, r7
 6279 0060 2033     		add	r3, r3, #32
 6280 0062 3A1C     		mov	r2, r7
 6281 0064 2032     		add	r2, r2, #32
 6282 0066 1278     		ldrb	r2, [r2]
 6283 0068 013A     		sub	r2, r2, #1
 6284 006a 1A70     		strb	r2, [r3]
2316:../Generated_Code/UTIL1.c ****     dstSize--;
 6285              		.loc 1 2316 0
 6286 006c BB68     		ldr	r3, [r7, #8]
 6287 006e 013B     		sub	r3, r3, #1
 6288 0070 BB60     		str	r3, [r7, #8]
 6289              	.L334:
2313:../Generated_Code/UTIL1.c ****   while(*p != '\0' && srcPadSize>0 && dstSize>1) {
 6290              		.loc 1 2313 0
 6291 0072 7B69     		ldr	r3, [r7, #20]
 6292 0074 1B78     		ldrb	r3, [r3]
 6293 0076 002B     		cmp	r3, #0
 6294 0078 19D0     		beq	.L337
2313:../Generated_Code/UTIL1.c ****   while(*p != '\0' && srcPadSize>0 && dstSize>1) {
 6295              		.loc 1 2313 0 is_stmt 0
 6296 007a 3B1C     		mov	r3, r7
 6297 007c 2033     		add	r3, r3, #32
 6298 007e 1B78     		ldrb	r3, [r3]
 6299 0080 002B     		cmp	r3, #0
 6300 0082 14D0     		beq	.L337
2313:../Generated_Code/UTIL1.c ****   while(*p != '\0' && srcPadSize>0 && dstSize>1) {
 6301              		.loc 1 2313 0
 6302 0084 BB68     		ldr	r3, [r7, #8]
 6303 0086 012B     		cmp	r3, #1
 6304 0088 E6D8     		bhi	.L336
2317:../Generated_Code/UTIL1.c ****   }
2318:../Generated_Code/UTIL1.c ****   while(srcPadSize>0 && dstSize>1) {
 6305              		.loc 1 2318 0 is_stmt 1
 6306 008a 10E0     		b	.L337
 6307              	.L339:
2319:../Generated_Code/UTIL1.c ****     *p++ = padChar; /* add padding char */
 6308              		.loc 1 2319 0
 6309 008c 7B69     		ldr	r3, [r7, #20]
 6310 008e FA1C     		add	r2, r7, #3
 6311 0090 1278     		ldrb	r2, [r2]
 6312 0092 1A70     		strb	r2, [r3]
 6313 0094 7B69     		ldr	r3, [r7, #20]
 6314 0096 0133     		add	r3, r3, #1
 6315 0098 7B61     		str	r3, [r7, #20]
2320:../Generated_Code/UTIL1.c ****     srcPadSize--;
 6316              		.loc 1 2320 0
 6317 009a 3B1C     		mov	r3, r7
 6318 009c 2033     		add	r3, r3, #32
 6319 009e 3A1C     		mov	r2, r7
 6320 00a0 2032     		add	r2, r2, #32
 6321 00a2 1278     		ldrb	r2, [r2]
 6322 00a4 013A     		sub	r2, r2, #1
 6323 00a6 1A70     		strb	r2, [r3]
2321:../Generated_Code/UTIL1.c ****     dstSize--;
 6324              		.loc 1 2321 0
 6325 00a8 BB68     		ldr	r3, [r7, #8]
 6326 00aa 013B     		sub	r3, r3, #1
 6327 00ac BB60     		str	r3, [r7, #8]
 6328              	.L337:
2318:../Generated_Code/UTIL1.c ****   while(srcPadSize>0 && dstSize>1) {
 6329              		.loc 1 2318 0
 6330 00ae 3B1C     		mov	r3, r7
 6331 00b0 2033     		add	r3, r3, #32
 6332 00b2 1B78     		ldrb	r3, [r3]
 6333 00b4 002B     		cmp	r3, #0
 6334 00b6 02D0     		beq	.L338
2318:../Generated_Code/UTIL1.c ****   while(srcPadSize>0 && dstSize>1) {
 6335              		.loc 1 2318 0 is_stmt 0
 6336 00b8 BB68     		ldr	r3, [r7, #8]
 6337 00ba 012B     		cmp	r3, #1
 6338 00bc E6D8     		bhi	.L339
 6339              	.L338:
2322:../Generated_Code/UTIL1.c ****   }
2323:../Generated_Code/UTIL1.c ****   *p = '\0'; /* terminate string */
 6340              		.loc 1 2323 0 is_stmt 1
 6341 00be 7B69     		ldr	r3, [r7, #20]
 6342 00c0 0022     		mov	r2, #0
 6343 00c2 1A70     		strb	r2, [r3]
 6344 00c4 00E0     		b	.L329
 6345              	.L340:
2304:../Generated_Code/UTIL1.c ****     return; /* hmm, really to small for anything than the zero byte? */
 6346              		.loc 1 2304 0
 6347 00c6 C046     		mov	r8, r8
 6348              	.L329:
2324:../Generated_Code/UTIL1.c **** }
 6349              		.loc 1 2324 0
 6350 00c8 BD46     		mov	sp, r7
 6351 00ca 06B0     		add	sp, sp, #24
 6352              		@ sp needed for prologue
 6353 00cc 80BD     		pop	{r7, pc}
 6354              		.cfi_endproc
 6355              	.LFE54:
 6357              		.global	__aeabi_fcmplt
 6358              		.global	__aeabi_f2iz
 6359              		.global	__aeabi_ui2f
 6360              		.global	__aeabi_fsub
 6361              		.global	__aeabi_fmul
 6362              		.global	__aeabi_f2uiz
 6363 00ce C046     		.section	.rodata
 6364 0015 000000   		.align	2
 6365              	.LC7:
 6366 0018 2D00     		.ascii	"-\000"
 6367 001a 0000     		.section	.text.UTIL1_NumFloatToStr,"ax",%progbits
 6368              		.align	2
 6369              		.global	UTIL1_NumFloatToStr
 6370              		.code	16
 6371              		.thumb_func
 6373              	UTIL1_NumFloatToStr:
 6374              	.LFB55:
2325:../Generated_Code/UTIL1.c **** 
2326:../Generated_Code/UTIL1.c **** /*
2327:../Generated_Code/UTIL1.c **** ** ===================================================================
2328:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_NumFloatToStr (component Utility)
2329:../Generated_Code/UTIL1.c **** **     Description :
2330:../Generated_Code/UTIL1.c **** **         Converts a float value into a string.
2331:../Generated_Code/UTIL1.c **** **     Parameters  :
2332:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2333:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
2334:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
2335:../Generated_Code/UTIL1.c **** **                           bytes).
2336:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
2337:../Generated_Code/UTIL1.c **** **         nofFracDigits   - Number of fractional
2338:../Generated_Code/UTIL1.c **** **                           digits to print
2339:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2340:../Generated_Code/UTIL1.c **** ** ===================================================================
2341:../Generated_Code/UTIL1.c **** */
2342:../Generated_Code/UTIL1.c **** void UTIL1_NumFloatToStr(uint8_t *dst, size_t dstSize, float val, uint8_t nofFracDigits)
2343:../Generated_Code/UTIL1.c **** {
 6375              		.loc 1 2343 0
 6376              		.cfi_startproc
 6377 0000 90B5     		push	{r4, r7, lr}
 6378              	.LCFI165:
 6379              		.cfi_def_cfa_offset 12
 6380              		.cfi_offset 4, -12
 6381              		.cfi_offset 7, -8
 6382              		.cfi_offset 14, -4
 6383 0002 8DB0     		sub	sp, sp, #52
 6384              	.LCFI166:
 6385              		.cfi_def_cfa_offset 64
 6386 0004 02AF     		add	r7, sp, #8
 6387              	.LCFI167:
 6388              		.cfi_def_cfa 7, 56
 6389 0006 F860     		str	r0, [r7, #12]
 6390 0008 B960     		str	r1, [r7, #8]
 6391 000a 7A60     		str	r2, [r7, #4]
 6392 000c 1A1C     		mov	r2, r3
 6393 000e FB1C     		add	r3, r7, #3
 6394 0010 1A70     		strb	r2, [r3]
2344:../Generated_Code/UTIL1.c ****   uint32_t integral;
2345:../Generated_Code/UTIL1.c ****   uint32_t fractional, shift;
2346:../Generated_Code/UTIL1.c ****   int i;
2347:../Generated_Code/UTIL1.c ****   bool isNeg;
2348:../Generated_Code/UTIL1.c **** 
2349:../Generated_Code/UTIL1.c ****   isNeg = (bool)(val<0);
 6395              		.loc 1 2349 0
 6396 0012 0123     		mov	r3, #1
 6397 0014 1C1C     		add	r4, r3, #0
 6398 0016 7868     		ldr	r0, [r7, #4]
 6399 0018 0021     		mov	r1, #0
 6400 001a FFF7FEFF 		bl	__aeabi_fcmplt
 6401 001e 031C     		mov	r3, r0
 6402 0020 002B     		cmp	r3, #0
 6403 0022 01D1     		bne	.L342
 6404 0024 0023     		mov	r3, #0
 6405 0026 1C1C     		add	r4, r3, #0
 6406              	.L342:
 6407 0028 E2B2     		uxtb	r2, r4
 6408 002a 3B1C     		mov	r3, r7
 6409 002c 1F33     		add	r3, r3, #31
 6410 002e 1A70     		strb	r2, [r3]
2350:../Generated_Code/UTIL1.c ****   if (isNeg) {
 6411              		.loc 1 2350 0
 6412 0030 3B1C     		mov	r3, r7
 6413 0032 1F33     		add	r3, r3, #31
 6414 0034 1B78     		ldrb	r3, [r3]
 6415 0036 002B     		cmp	r3, #0
 6416 0038 04D0     		beq	.L343
2351:../Generated_Code/UTIL1.c ****     val = -val; /* make it positive */
 6417              		.loc 1 2351 0
 6418 003a 7B68     		ldr	r3, [r7, #4]
 6419 003c 8022     		mov	r2, #128
 6420 003e 1206     		lsl	r2, r2, #24
 6421 0040 5340     		eor	r3, r2
 6422 0042 7B60     		str	r3, [r7, #4]
 6423              	.L343:
2352:../Generated_Code/UTIL1.c ****   }
2353:../Generated_Code/UTIL1.c ****   integral = (uint32_t)(int32_t)val;
 6424              		.loc 1 2353 0
 6425 0044 7868     		ldr	r0, [r7, #4]
 6426 0046 FFF7FEFF 		bl	__aeabi_f2iz
 6427 004a 031C     		mov	r3, r0
 6428 004c BB61     		str	r3, [r7, #24]
2354:../Generated_Code/UTIL1.c ****   val = val-(float)integral; /* get rid of integral part */
 6429              		.loc 1 2354 0
 6430 004e B869     		ldr	r0, [r7, #24]
 6431 0050 FFF7FEFF 		bl	__aeabi_ui2f
 6432 0054 031C     		add	r3, r0, #0
 6433 0056 7868     		ldr	r0, [r7, #4]
 6434 0058 191C     		add	r1, r3, #0
 6435 005a FFF7FEFF 		bl	__aeabi_fsub
 6436 005e 031C     		add	r3, r0, #0
 6437 0060 7B60     		str	r3, [r7, #4]
2355:../Generated_Code/UTIL1.c ****   shift = 1;
 6438              		.loc 1 2355 0
 6439 0062 0123     		mov	r3, #1
 6440 0064 7B62     		str	r3, [r7, #36]
2356:../Generated_Code/UTIL1.c ****   for(i=0;i<nofFracDigits;i++) {
 6441              		.loc 1 2356 0
 6442 0066 0023     		mov	r3, #0
 6443 0068 3B62     		str	r3, [r7, #32]
 6444 006a 08E0     		b	.L344
 6445              	.L345:
2357:../Generated_Code/UTIL1.c ****     shift *= 10;
 6446              		.loc 1 2357 0
 6447 006c 7A6A     		ldr	r2, [r7, #36]
 6448 006e 131C     		mov	r3, r2
 6449 0070 9B00     		lsl	r3, r3, #2
 6450 0072 9B18     		add	r3, r3, r2
 6451 0074 5B00     		lsl	r3, r3, #1
 6452 0076 7B62     		str	r3, [r7, #36]
2356:../Generated_Code/UTIL1.c ****   for(i=0;i<nofFracDigits;i++) {
 6453              		.loc 1 2356 0
 6454 0078 3B6A     		ldr	r3, [r7, #32]
 6455 007a 0133     		add	r3, r3, #1
 6456 007c 3B62     		str	r3, [r7, #32]
 6457              	.L344:
2356:../Generated_Code/UTIL1.c ****   for(i=0;i<nofFracDigits;i++) {
 6458              		.loc 1 2356 0 is_stmt 0
 6459 007e FB1C     		add	r3, r7, #3
 6460 0080 1A78     		ldrb	r2, [r3]
 6461 0082 3B6A     		ldr	r3, [r7, #32]
 6462 0084 9A42     		cmp	r2, r3
 6463 0086 F1DC     		bgt	.L345
2358:../Generated_Code/UTIL1.c ****   }
2359:../Generated_Code/UTIL1.c ****   /* get fractional part */
2360:../Generated_Code/UTIL1.c ****   fractional = (uint32_t)(val*shift);
 6464              		.loc 1 2360 0 is_stmt 1
 6465 0088 786A     		ldr	r0, [r7, #36]
 6466 008a FFF7FEFF 		bl	__aeabi_ui2f
 6467 008e 031C     		add	r3, r0, #0
 6468 0090 181C     		add	r0, r3, #0
 6469 0092 7968     		ldr	r1, [r7, #4]
 6470 0094 FFF7FEFF 		bl	__aeabi_fmul
 6471 0098 031C     		add	r3, r0, #0
 6472 009a 181C     		add	r0, r3, #0
 6473 009c FFF7FEFF 		bl	__aeabi_f2uiz
 6474 00a0 031C     		mov	r3, r0
 6475 00a2 7B61     		str	r3, [r7, #20]
2361:../Generated_Code/UTIL1.c ****   /* write integral part */
2362:../Generated_Code/UTIL1.c ****   if (integral==0 && fractional==0) { /* special check to avoid writing -0 or -0.000 */
 6476              		.loc 1 2362 0
 6477 00a4 BB69     		ldr	r3, [r7, #24]
 6478 00a6 002B     		cmp	r3, #0
 6479 00a8 0AD1     		bne	.L346
 6480              		.loc 1 2362 0 is_stmt 0
 6481 00aa 7B69     		ldr	r3, [r7, #20]
 6482 00ac 002B     		cmp	r3, #0
 6483 00ae 07D1     		bne	.L346
2363:../Generated_Code/UTIL1.c ****     UTIL1_Num32sToStr(dst, dstSize, 0); /* just write the zero */
 6484              		.loc 1 2363 0 is_stmt 1
 6485 00b0 FA68     		ldr	r2, [r7, #12]
 6486 00b2 BB68     		ldr	r3, [r7, #8]
 6487 00b4 101C     		mov	r0, r2
 6488 00b6 191C     		mov	r1, r3
 6489 00b8 0022     		mov	r2, #0
 6490 00ba FFF7FEFF 		bl	UTIL1_Num32sToStr
 6491 00be 1DE0     		b	.L347
 6492              	.L346:
2364:../Generated_Code/UTIL1.c ****   } else if (isNeg) { /* for negative numbers, write it with sign */
 6493              		.loc 1 2364 0
 6494 00c0 3B1C     		mov	r3, r7
 6495 00c2 1F33     		add	r3, r3, #31
 6496 00c4 1B78     		ldrb	r3, [r3]
 6497 00c6 002B     		cmp	r3, #0
 6498 00c8 10D0     		beq	.L348
2365:../Generated_Code/UTIL1.c ****     UTIL1_strcpy(dst, dstSize, (unsigned char*)"-");
 6499              		.loc 1 2365 0
 6500 00ca F968     		ldr	r1, [r7, #12]
 6501 00cc BA68     		ldr	r2, [r7, #8]
 6502 00ce 184B     		ldr	r3, .L350
 6503 00d0 081C     		mov	r0, r1
 6504 00d2 111C     		mov	r1, r2
 6505 00d4 1A1C     		mov	r2, r3
 6506 00d6 FFF7FEFF 		bl	UTIL1_strcpy
2366:../Generated_Code/UTIL1.c ****     UTIL1_strcatNum32s(dst, dstSize, (int32_t)integral);
 6507              		.loc 1 2366 0
 6508 00da BB69     		ldr	r3, [r7, #24]
 6509 00dc F968     		ldr	r1, [r7, #12]
 6510 00de BA68     		ldr	r2, [r7, #8]
 6511 00e0 081C     		mov	r0, r1
 6512 00e2 111C     		mov	r1, r2
 6513 00e4 1A1C     		mov	r2, r3
 6514 00e6 FFF7FEFF 		bl	UTIL1_strcatNum32s
 6515 00ea 07E0     		b	.L347
 6516              	.L348:
2367:../Generated_Code/UTIL1.c ****   } else {
2368:../Generated_Code/UTIL1.c ****     UTIL1_Num32sToStr(dst, dstSize, (int32_t)integral);
 6517              		.loc 1 2368 0
 6518 00ec BB69     		ldr	r3, [r7, #24]
 6519 00ee F968     		ldr	r1, [r7, #12]
 6520 00f0 BA68     		ldr	r2, [r7, #8]
 6521 00f2 081C     		mov	r0, r1
 6522 00f4 111C     		mov	r1, r2
 6523 00f6 1A1C     		mov	r2, r3
 6524 00f8 FFF7FEFF 		bl	UTIL1_Num32sToStr
 6525              	.L347:
2369:../Generated_Code/UTIL1.c ****   }
2370:../Generated_Code/UTIL1.c ****   /* write fractional part */
2371:../Generated_Code/UTIL1.c ****   if (nofFracDigits>0) {
 6526              		.loc 1 2371 0
 6527 00fc FB1C     		add	r3, r7, #3
 6528 00fe 1B78     		ldrb	r3, [r3]
 6529 0100 002B     		cmp	r3, #0
 6530 0102 12D0     		beq	.L341
2372:../Generated_Code/UTIL1.c ****     UTIL1_chcat(dst, dstSize, '.');
 6531              		.loc 1 2372 0
 6532 0104 FA68     		ldr	r2, [r7, #12]
 6533 0106 BB68     		ldr	r3, [r7, #8]
 6534 0108 101C     		mov	r0, r2
 6535 010a 191C     		mov	r1, r3
 6536 010c 2E22     		mov	r2, #46
 6537 010e FFF7FEFF 		bl	UTIL1_chcat
2373:../Generated_Code/UTIL1.c ****     UTIL1_strcatNum32uFormatted(dst, dstSize, fractional, '0', nofFracDigits);
 6538              		.loc 1 2373 0
 6539 0112 F968     		ldr	r1, [r7, #12]
 6540 0114 BA68     		ldr	r2, [r7, #8]
 6541 0116 7B69     		ldr	r3, [r7, #20]
 6542 0118 F81C     		add	r0, r7, #3
 6543 011a 0078     		ldrb	r0, [r0]
 6544 011c 0090     		str	r0, [sp]
 6545 011e 081C     		mov	r0, r1
 6546 0120 111C     		mov	r1, r2
 6547 0122 1A1C     		mov	r2, r3
 6548 0124 3023     		mov	r3, #48
 6549 0126 FFF7FEFF 		bl	UTIL1_strcatNum32uFormatted
 6550              	.L341:
2374:../Generated_Code/UTIL1.c ****   }
2375:../Generated_Code/UTIL1.c **** }
 6551              		.loc 1 2375 0
 6552 012a BD46     		mov	sp, r7
 6553 012c 0BB0     		add	sp, sp, #44
 6554              		@ sp needed for prologue
 6555 012e 90BD     		pop	{r4, r7, pc}
 6556              	.L351:
 6557              		.align	2
 6558              	.L350:
 6559 0130 18000000 		.word	.LC7
 6560              		.cfi_endproc
 6561              	.LFE55:
 6563              		.section	.text.UTIL1_strcatNumFloat,"ax",%progbits
 6564              		.align	2
 6565              		.global	UTIL1_strcatNumFloat
 6566              		.code	16
 6567              		.thumb_func
 6569              	UTIL1_strcatNumFloat:
 6570              	.LFB56:
2376:../Generated_Code/UTIL1.c **** 
2377:../Generated_Code/UTIL1.c **** /*
2378:../Generated_Code/UTIL1.c **** ** ===================================================================
2379:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNumFloat (component Utility)
2380:../Generated_Code/UTIL1.c **** **     Description :
2381:../Generated_Code/UTIL1.c **** **         Converts a float value into a string.
2382:../Generated_Code/UTIL1.c **** **     Parameters  :
2383:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2384:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
2385:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
2386:../Generated_Code/UTIL1.c **** **                           bytes).
2387:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
2388:../Generated_Code/UTIL1.c **** **         nofFracDigits   - Number of factional
2389:../Generated_Code/UTIL1.c **** **                           digits to print
2390:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2391:../Generated_Code/UTIL1.c **** ** ===================================================================
2392:../Generated_Code/UTIL1.c **** */
2393:../Generated_Code/UTIL1.c **** void UTIL1_strcatNumFloat(uint8_t *dst, size_t dstSize, float val, uint8_t nofFracDigits)
2394:../Generated_Code/UTIL1.c **** {
 6571              		.loc 1 2394 0
 6572              		.cfi_startproc
 6573 0000 80B5     		push	{r7, lr}
 6574              	.LCFI168:
 6575              		.cfi_def_cfa_offset 8
 6576              		.cfi_offset 7, -8
 6577              		.cfi_offset 14, -4
 6578 0002 8CB0     		sub	sp, sp, #48
 6579              	.LCFI169:
 6580              		.cfi_def_cfa_offset 56
 6581 0004 00AF     		add	r7, sp, #0
 6582              	.LCFI170:
 6583              		.cfi_def_cfa_register 7
 6584 0006 F860     		str	r0, [r7, #12]
 6585 0008 B960     		str	r1, [r7, #8]
 6586 000a 7A60     		str	r2, [r7, #4]
 6587 000c 1A1C     		mov	r2, r3
 6588 000e FB1C     		add	r3, r7, #3
 6589 0010 1A70     		strb	r2, [r3]
2395:../Generated_Code/UTIL1.c ****   uint8_t buf[32];
2396:../Generated_Code/UTIL1.c **** 
2397:../Generated_Code/UTIL1.c ****   UTIL1_NumFloatToStr(buf, sizeof(buf), val, nofFracDigits);
 6590              		.loc 1 2397 0
 6591 0012 391C     		mov	r1, r7
 6592 0014 1031     		add	r1, r1, #16
 6593 0016 7A68     		ldr	r2, [r7, #4]
 6594 0018 FB1C     		add	r3, r7, #3
 6595 001a 1B78     		ldrb	r3, [r3]
 6596 001c 081C     		mov	r0, r1
 6597 001e 2021     		mov	r1, #32
 6598 0020 FFF7FEFF 		bl	UTIL1_NumFloatToStr
2398:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 6599              		.loc 1 2398 0
 6600 0024 F968     		ldr	r1, [r7, #12]
 6601 0026 BA68     		ldr	r2, [r7, #8]
 6602 0028 3B1C     		mov	r3, r7
 6603 002a 1033     		add	r3, r3, #16
 6604 002c 081C     		mov	r0, r1
 6605 002e 111C     		mov	r1, r2
 6606 0030 1A1C     		mov	r2, r3
 6607 0032 FFF7FEFF 		bl	UTIL1_strcat
2399:../Generated_Code/UTIL1.c **** }
 6608              		.loc 1 2399 0
 6609 0036 BD46     		mov	sp, r7
 6610 0038 0CB0     		add	sp, sp, #48
 6611              		@ sp needed for prologue
 6612 003a 80BD     		pop	{r7, pc}
 6613              		.cfi_endproc
 6614              	.LFE56:
 6616              		.section	.text.UTIL1_GetValue16LE,"ax",%progbits
 6617              		.align	2
 6618              		.global	UTIL1_GetValue16LE
 6619              		.code	16
 6620              		.thumb_func
 6622              	UTIL1_GetValue16LE:
 6623              	.LFB57:
2400:../Generated_Code/UTIL1.c **** 
2401:../Generated_Code/UTIL1.c **** /*
2402:../Generated_Code/UTIL1.c **** ** ===================================================================
2403:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_GetValue16LE (component Utility)
2404:../Generated_Code/UTIL1.c **** **     Description :
2405:../Generated_Code/UTIL1.c **** **         Returns a 16bit Little Endian value from memory
2406:../Generated_Code/UTIL1.c **** **     Parameters  :
2407:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2408:../Generated_Code/UTIL1.c **** **       * dataP           - Pointer to memory
2409:../Generated_Code/UTIL1.c **** **     Returns     :
2410:../Generated_Code/UTIL1.c **** **         ---             - Error code
2411:../Generated_Code/UTIL1.c **** ** ===================================================================
2412:../Generated_Code/UTIL1.c **** */
2413:../Generated_Code/UTIL1.c **** uint16_t UTIL1_GetValue16LE(uint8_t *dataP)
2414:../Generated_Code/UTIL1.c **** {
 6624              		.loc 1 2414 0
 6625              		.cfi_startproc
 6626 0000 80B5     		push	{r7, lr}
 6627              	.LCFI171:
 6628              		.cfi_def_cfa_offset 8
 6629              		.cfi_offset 7, -8
 6630              		.cfi_offset 14, -4
 6631 0002 82B0     		sub	sp, sp, #8
 6632              	.LCFI172:
 6633              		.cfi_def_cfa_offset 16
 6634 0004 00AF     		add	r7, sp, #0
 6635              	.LCFI173:
 6636              		.cfi_def_cfa_register 7
 6637 0006 7860     		str	r0, [r7, #4]
2415:../Generated_Code/UTIL1.c ****   return (uint16_t)((dataP[1]<<8)+(dataP[0]));
 6638              		.loc 1 2415 0
 6639 0008 7B68     		ldr	r3, [r7, #4]
 6640 000a 0133     		add	r3, r3, #1
 6641 000c 1B78     		ldrb	r3, [r3]
 6642 000e 1B02     		lsl	r3, r3, #8
 6643 0010 9AB2     		uxth	r2, r3
 6644 0012 7B68     		ldr	r3, [r7, #4]
 6645 0014 1B78     		ldrb	r3, [r3]
 6646 0016 D318     		add	r3, r2, r3
 6647 0018 9BB2     		uxth	r3, r3
2416:../Generated_Code/UTIL1.c **** }
 6648              		.loc 1 2416 0
 6649 001a 181C     		mov	r0, r3
 6650 001c BD46     		mov	sp, r7
 6651 001e 02B0     		add	sp, sp, #8
 6652              		@ sp needed for prologue
 6653 0020 80BD     		pop	{r7, pc}
 6654              		.cfi_endproc
 6655              	.LFE57:
 6657 0022 C046     		.section	.text.UTIL1_GetValue24LE,"ax",%progbits
 6658              		.align	2
 6659              		.global	UTIL1_GetValue24LE
 6660              		.code	16
 6661              		.thumb_func
 6663              	UTIL1_GetValue24LE:
 6664              	.LFB58:
2417:../Generated_Code/UTIL1.c **** 
2418:../Generated_Code/UTIL1.c **** /*
2419:../Generated_Code/UTIL1.c **** ** ===================================================================
2420:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_GetValue24LE (component Utility)
2421:../Generated_Code/UTIL1.c **** **     Description :
2422:../Generated_Code/UTIL1.c **** **         Returns a 24bit Little Endian value from memory
2423:../Generated_Code/UTIL1.c **** **     Parameters  :
2424:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2425:../Generated_Code/UTIL1.c **** **       * dataP           - Pointer to memory
2426:../Generated_Code/UTIL1.c **** **     Returns     :
2427:../Generated_Code/UTIL1.c **** **         ---             - Error code
2428:../Generated_Code/UTIL1.c **** ** ===================================================================
2429:../Generated_Code/UTIL1.c **** */
2430:../Generated_Code/UTIL1.c **** uint32_t UTIL1_GetValue24LE(uint8_t *dataP)
2431:../Generated_Code/UTIL1.c **** {
 6665              		.loc 1 2431 0
 6666              		.cfi_startproc
 6667 0000 80B5     		push	{r7, lr}
 6668              	.LCFI174:
 6669              		.cfi_def_cfa_offset 8
 6670              		.cfi_offset 7, -8
 6671              		.cfi_offset 14, -4
 6672 0002 82B0     		sub	sp, sp, #8
 6673              	.LCFI175:
 6674              		.cfi_def_cfa_offset 16
 6675 0004 00AF     		add	r7, sp, #0
 6676              	.LCFI176:
 6677              		.cfi_def_cfa_register 7
 6678 0006 7860     		str	r0, [r7, #4]
2432:../Generated_Code/UTIL1.c ****   return (uint32_t)(((uint32_t)dataP[2])<<16)+(dataP[1]<<8)+(dataP[0]);
 6679              		.loc 1 2432 0
 6680 0008 7B68     		ldr	r3, [r7, #4]
 6681 000a 0233     		add	r3, r3, #2
 6682 000c 1B78     		ldrb	r3, [r3]
 6683 000e 1A04     		lsl	r2, r3, #16
 6684 0010 7B68     		ldr	r3, [r7, #4]
 6685 0012 0133     		add	r3, r3, #1
 6686 0014 1B78     		ldrb	r3, [r3]
 6687 0016 1B02     		lsl	r3, r3, #8
 6688 0018 D218     		add	r2, r2, r3
 6689 001a 7B68     		ldr	r3, [r7, #4]
 6690 001c 1B78     		ldrb	r3, [r3]
 6691 001e D318     		add	r3, r2, r3
2433:../Generated_Code/UTIL1.c **** }
 6692              		.loc 1 2433 0
 6693 0020 181C     		mov	r0, r3
 6694 0022 BD46     		mov	sp, r7
 6695 0024 02B0     		add	sp, sp, #8
 6696              		@ sp needed for prologue
 6697 0026 80BD     		pop	{r7, pc}
 6698              		.cfi_endproc
 6699              	.LFE58:
 6701              		.section	.text.UTIL1_GetValue32LE,"ax",%progbits
 6702              		.align	2
 6703              		.global	UTIL1_GetValue32LE
 6704              		.code	16
 6705              		.thumb_func
 6707              	UTIL1_GetValue32LE:
 6708              	.LFB59:
2434:../Generated_Code/UTIL1.c **** 
2435:../Generated_Code/UTIL1.c **** /*
2436:../Generated_Code/UTIL1.c **** ** ===================================================================
2437:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_GetValue32LE (component Utility)
2438:../Generated_Code/UTIL1.c **** **     Description :
2439:../Generated_Code/UTIL1.c **** **         Returns a 32bit Little Endian value from memory
2440:../Generated_Code/UTIL1.c **** **     Parameters  :
2441:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2442:../Generated_Code/UTIL1.c **** **       * dataP           - Pointer to memory
2443:../Generated_Code/UTIL1.c **** **     Returns     :
2444:../Generated_Code/UTIL1.c **** **         ---             - Error code
2445:../Generated_Code/UTIL1.c **** ** ===================================================================
2446:../Generated_Code/UTIL1.c **** */
2447:../Generated_Code/UTIL1.c **** uint32_t UTIL1_GetValue32LE(uint8_t *dataP)
2448:../Generated_Code/UTIL1.c **** {
 6709              		.loc 1 2448 0
 6710              		.cfi_startproc
 6711 0000 80B5     		push	{r7, lr}
 6712              	.LCFI177:
 6713              		.cfi_def_cfa_offset 8
 6714              		.cfi_offset 7, -8
 6715              		.cfi_offset 14, -4
 6716 0002 82B0     		sub	sp, sp, #8
 6717              	.LCFI178:
 6718              		.cfi_def_cfa_offset 16
 6719 0004 00AF     		add	r7, sp, #0
 6720              	.LCFI179:
 6721              		.cfi_def_cfa_register 7
 6722 0006 7860     		str	r0, [r7, #4]
2449:../Generated_Code/UTIL1.c ****   return (uint32_t)(((uint32_t)dataP[3])<<24)+(((uint32_t)dataP[2])<<16)+(dataP[1]<<8)+(dataP[0]);
 6723              		.loc 1 2449 0
 6724 0008 7B68     		ldr	r3, [r7, #4]
 6725 000a 0333     		add	r3, r3, #3
 6726 000c 1B78     		ldrb	r3, [r3]
 6727 000e 1A06     		lsl	r2, r3, #24
 6728 0010 7B68     		ldr	r3, [r7, #4]
 6729 0012 0233     		add	r3, r3, #2
 6730 0014 1B78     		ldrb	r3, [r3]
 6731 0016 1B04     		lsl	r3, r3, #16
 6732 0018 D218     		add	r2, r2, r3
 6733 001a 7B68     		ldr	r3, [r7, #4]
 6734 001c 0133     		add	r3, r3, #1
 6735 001e 1B78     		ldrb	r3, [r3]
 6736 0020 1B02     		lsl	r3, r3, #8
 6737 0022 D218     		add	r2, r2, r3
 6738 0024 7B68     		ldr	r3, [r7, #4]
 6739 0026 1B78     		ldrb	r3, [r3]
 6740 0028 D318     		add	r3, r2, r3
2450:../Generated_Code/UTIL1.c **** }
 6741              		.loc 1 2450 0
 6742 002a 181C     		mov	r0, r3
 6743 002c BD46     		mov	sp, r7
 6744 002e 02B0     		add	sp, sp, #8
 6745              		@ sp needed for prologue
 6746 0030 80BD     		pop	{r7, pc}
 6747              		.cfi_endproc
 6748              	.LFE59:
 6750 0032 C046     		.section	.text.UTIL1_SetValue16LE,"ax",%progbits
 6751              		.align	2
 6752              		.global	UTIL1_SetValue16LE
 6753              		.code	16
 6754              		.thumb_func
 6756              	UTIL1_SetValue16LE:
 6757              	.LFB60:
2451:../Generated_Code/UTIL1.c **** 
2452:../Generated_Code/UTIL1.c **** /*
2453:../Generated_Code/UTIL1.c **** ** ===================================================================
2454:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_SetValue16LE (component Utility)
2455:../Generated_Code/UTIL1.c **** **     Description :
2456:../Generated_Code/UTIL1.c **** **         Stores a 16bit value in memory as Little Endian
2457:../Generated_Code/UTIL1.c **** **     Parameters  :
2458:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2459:../Generated_Code/UTIL1.c **** **         data            - Value to store
2460:../Generated_Code/UTIL1.c **** **       * dataP           - Pointer to memory
2461:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2462:../Generated_Code/UTIL1.c **** ** ===================================================================
2463:../Generated_Code/UTIL1.c **** */
2464:../Generated_Code/UTIL1.c **** void UTIL1_SetValue16LE(uint16_t data, uint8_t *dataP)
2465:../Generated_Code/UTIL1.c **** {
 6758              		.loc 1 2465 0
 6759              		.cfi_startproc
 6760 0000 80B5     		push	{r7, lr}
 6761              	.LCFI180:
 6762              		.cfi_def_cfa_offset 8
 6763              		.cfi_offset 7, -8
 6764              		.cfi_offset 14, -4
 6765 0002 82B0     		sub	sp, sp, #8
 6766              	.LCFI181:
 6767              		.cfi_def_cfa_offset 16
 6768 0004 00AF     		add	r7, sp, #0
 6769              	.LCFI182:
 6770              		.cfi_def_cfa_register 7
 6771 0006 021C     		mov	r2, r0
 6772 0008 3960     		str	r1, [r7]
 6773 000a BB1D     		add	r3, r7, #6
 6774 000c 1A80     		strh	r2, [r3]
2466:../Generated_Code/UTIL1.c ****   dataP[0] = (uint8_t)(data&0xff); /* LSB */
 6775              		.loc 1 2466 0
 6776 000e BB1D     		add	r3, r7, #6
 6777 0010 1B88     		ldrh	r3, [r3]
 6778 0012 DAB2     		uxtb	r2, r3
 6779 0014 3B68     		ldr	r3, [r7]
 6780 0016 1A70     		strb	r2, [r3]
2467:../Generated_Code/UTIL1.c ****   dataP[1] = (uint8_t)((data>>8)&0xff); /* MSB */
 6781              		.loc 1 2467 0
 6782 0018 3B68     		ldr	r3, [r7]
 6783 001a 0133     		add	r3, r3, #1
 6784 001c BA1D     		add	r2, r7, #6
 6785 001e 1288     		ldrh	r2, [r2]
 6786 0020 120A     		lsr	r2, r2, #8
 6787 0022 92B2     		uxth	r2, r2
 6788 0024 D2B2     		uxtb	r2, r2
 6789 0026 1A70     		strb	r2, [r3]
2468:../Generated_Code/UTIL1.c **** }
 6790              		.loc 1 2468 0
 6791 0028 BD46     		mov	sp, r7
 6792 002a 02B0     		add	sp, sp, #8
 6793              		@ sp needed for prologue
 6794 002c 80BD     		pop	{r7, pc}
 6795              		.cfi_endproc
 6796              	.LFE60:
 6798 002e C046     		.section	.text.UTIL1_SetValue24LE,"ax",%progbits
 6799              		.align	2
 6800              		.global	UTIL1_SetValue24LE
 6801              		.code	16
 6802              		.thumb_func
 6804              	UTIL1_SetValue24LE:
 6805              	.LFB61:
2469:../Generated_Code/UTIL1.c **** 
2470:../Generated_Code/UTIL1.c **** /*
2471:../Generated_Code/UTIL1.c **** ** ===================================================================
2472:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_SetValue24LE (component Utility)
2473:../Generated_Code/UTIL1.c **** **     Description :
2474:../Generated_Code/UTIL1.c **** **         Stores a 24bit value in memory as Little Endian
2475:../Generated_Code/UTIL1.c **** **     Parameters  :
2476:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2477:../Generated_Code/UTIL1.c **** **         data            - Value to store
2478:../Generated_Code/UTIL1.c **** **       * dataP           - Pointer to memory
2479:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2480:../Generated_Code/UTIL1.c **** ** ===================================================================
2481:../Generated_Code/UTIL1.c **** */
2482:../Generated_Code/UTIL1.c **** void UTIL1_SetValue24LE(uint32_t data, uint8_t *dataP)
2483:../Generated_Code/UTIL1.c **** {
 6806              		.loc 1 2483 0
 6807              		.cfi_startproc
 6808 0000 80B5     		push	{r7, lr}
 6809              	.LCFI183:
 6810              		.cfi_def_cfa_offset 8
 6811              		.cfi_offset 7, -8
 6812              		.cfi_offset 14, -4
 6813 0002 82B0     		sub	sp, sp, #8
 6814              	.LCFI184:
 6815              		.cfi_def_cfa_offset 16
 6816 0004 00AF     		add	r7, sp, #0
 6817              	.LCFI185:
 6818              		.cfi_def_cfa_register 7
 6819 0006 7860     		str	r0, [r7, #4]
 6820 0008 3960     		str	r1, [r7]
2484:../Generated_Code/UTIL1.c ****   dataP[0] = (uint8_t)(data&0xff); /* LSB */
 6821              		.loc 1 2484 0
 6822 000a 7B68     		ldr	r3, [r7, #4]
 6823 000c DAB2     		uxtb	r2, r3
 6824 000e 3B68     		ldr	r3, [r7]
 6825 0010 1A70     		strb	r2, [r3]
2485:../Generated_Code/UTIL1.c ****   dataP[1] = (uint8_t)((data>>8)&0xff);
 6826              		.loc 1 2485 0
 6827 0012 3B68     		ldr	r3, [r7]
 6828 0014 0133     		add	r3, r3, #1
 6829 0016 7A68     		ldr	r2, [r7, #4]
 6830 0018 120A     		lsr	r2, r2, #8
 6831 001a D2B2     		uxtb	r2, r2
 6832 001c 1A70     		strb	r2, [r3]
2486:../Generated_Code/UTIL1.c ****   dataP[2] = (uint8_t)((data>>16)&0xff);
 6833              		.loc 1 2486 0
 6834 001e 3B68     		ldr	r3, [r7]
 6835 0020 0233     		add	r3, r3, #2
 6836 0022 7A68     		ldr	r2, [r7, #4]
 6837 0024 120C     		lsr	r2, r2, #16
 6838 0026 D2B2     		uxtb	r2, r2
 6839 0028 1A70     		strb	r2, [r3]
2487:../Generated_Code/UTIL1.c **** }
 6840              		.loc 1 2487 0
 6841 002a BD46     		mov	sp, r7
 6842 002c 02B0     		add	sp, sp, #8
 6843              		@ sp needed for prologue
 6844 002e 80BD     		pop	{r7, pc}
 6845              		.cfi_endproc
 6846              	.LFE61:
 6848              		.section	.text.UTIL1_SetValue32LE,"ax",%progbits
 6849              		.align	2
 6850              		.global	UTIL1_SetValue32LE
 6851              		.code	16
 6852              		.thumb_func
 6854              	UTIL1_SetValue32LE:
 6855              	.LFB62:
2488:../Generated_Code/UTIL1.c **** 
2489:../Generated_Code/UTIL1.c **** /*
2490:../Generated_Code/UTIL1.c **** ** ===================================================================
2491:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_SetValue32LE (component Utility)
2492:../Generated_Code/UTIL1.c **** **     Description :
2493:../Generated_Code/UTIL1.c **** **         Stores a 32bit value in memory as Little Endian
2494:../Generated_Code/UTIL1.c **** **     Parameters  :
2495:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2496:../Generated_Code/UTIL1.c **** **         data            - Value to store
2497:../Generated_Code/UTIL1.c **** **       * dataP           - Pointer to memory
2498:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2499:../Generated_Code/UTIL1.c **** ** ===================================================================
2500:../Generated_Code/UTIL1.c **** */
2501:../Generated_Code/UTIL1.c **** void UTIL1_SetValue32LE(uint32_t data, uint8_t *dataP)
2502:../Generated_Code/UTIL1.c **** {
 6856              		.loc 1 2502 0
 6857              		.cfi_startproc
 6858 0000 80B5     		push	{r7, lr}
 6859              	.LCFI186:
 6860              		.cfi_def_cfa_offset 8
 6861              		.cfi_offset 7, -8
 6862              		.cfi_offset 14, -4
 6863 0002 82B0     		sub	sp, sp, #8
 6864              	.LCFI187:
 6865              		.cfi_def_cfa_offset 16
 6866 0004 00AF     		add	r7, sp, #0
 6867              	.LCFI188:
 6868              		.cfi_def_cfa_register 7
 6869 0006 7860     		str	r0, [r7, #4]
 6870 0008 3960     		str	r1, [r7]
2503:../Generated_Code/UTIL1.c ****   dataP[0] = (uint8_t)(data&0xff); /* LSB */
 6871              		.loc 1 2503 0
 6872 000a 7B68     		ldr	r3, [r7, #4]
 6873 000c DAB2     		uxtb	r2, r3
 6874 000e 3B68     		ldr	r3, [r7]
 6875 0010 1A70     		strb	r2, [r3]
2504:../Generated_Code/UTIL1.c ****   dataP[1] = (uint8_t)((data>>8)&0xff);
 6876              		.loc 1 2504 0
 6877 0012 3B68     		ldr	r3, [r7]
 6878 0014 0133     		add	r3, r3, #1
 6879 0016 7A68     		ldr	r2, [r7, #4]
 6880 0018 120A     		lsr	r2, r2, #8
 6881 001a D2B2     		uxtb	r2, r2
 6882 001c 1A70     		strb	r2, [r3]
2505:../Generated_Code/UTIL1.c ****   dataP[2] = (uint8_t)((data>>16)&0xff);
 6883              		.loc 1 2505 0
 6884 001e 3B68     		ldr	r3, [r7]
 6885 0020 0233     		add	r3, r3, #2
 6886 0022 7A68     		ldr	r2, [r7, #4]
 6887 0024 120C     		lsr	r2, r2, #16
 6888 0026 D2B2     		uxtb	r2, r2
 6889 0028 1A70     		strb	r2, [r3]
2506:../Generated_Code/UTIL1.c ****   dataP[3] = (uint8_t)((data>>24)&0xff);
 6890              		.loc 1 2506 0
 6891 002a 3B68     		ldr	r3, [r7]
 6892 002c 0333     		add	r3, r3, #3
 6893 002e 7A68     		ldr	r2, [r7, #4]
 6894 0030 120E     		lsr	r2, r2, #24
 6895 0032 D2B2     		uxtb	r2, r2
 6896 0034 1A70     		strb	r2, [r3]
2507:../Generated_Code/UTIL1.c **** }
 6897              		.loc 1 2507 0
 6898 0036 BD46     		mov	sp, r7
 6899 0038 02B0     		add	sp, sp, #8
 6900              		@ sp needed for prologue
 6901 003a 80BD     		pop	{r7, pc}
 6902              		.cfi_endproc
 6903              	.LFE62:
 6905              		.section	.text.UTIL1_Deinit,"ax",%progbits
 6906              		.align	2
 6907              		.global	UTIL1_Deinit
 6908              		.code	16
 6909              		.thumb_func
 6911              	UTIL1_Deinit:
 6912              	.LFB63:
2508:../Generated_Code/UTIL1.c **** 
2509:../Generated_Code/UTIL1.c **** /*
2510:../Generated_Code/UTIL1.c **** ** ===================================================================
2511:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Deinit (component Utility)
2512:../Generated_Code/UTIL1.c **** **     Description :
2513:../Generated_Code/UTIL1.c **** **         Driver De-Initialization
2514:../Generated_Code/UTIL1.c **** **     Parameters  : None
2515:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2516:../Generated_Code/UTIL1.c **** ** ===================================================================
2517:../Generated_Code/UTIL1.c **** */
2518:../Generated_Code/UTIL1.c **** void UTIL1_Deinit(void)
2519:../Generated_Code/UTIL1.c **** {
 6913              		.loc 1 2519 0
 6914              		.cfi_startproc
 6915 0000 80B5     		push	{r7, lr}
 6916              	.LCFI189:
 6917              		.cfi_def_cfa_offset 8
 6918              		.cfi_offset 7, -8
 6919              		.cfi_offset 14, -4
 6920 0002 00AF     		add	r7, sp, #0
 6921              	.LCFI190:
 6922              		.cfi_def_cfa_register 7
2520:../Generated_Code/UTIL1.c ****   /* nothing needed */
2521:../Generated_Code/UTIL1.c **** }
 6923              		.loc 1 2521 0
 6924 0004 BD46     		mov	sp, r7
 6925              		@ sp needed for prologue
 6926 0006 80BD     		pop	{r7, pc}
 6927              		.cfi_endproc
 6928              	.LFE63:
 6930              		.section	.text.UTIL1_Init,"ax",%progbits
 6931              		.align	2
 6932              		.global	UTIL1_Init
 6933              		.code	16
 6934              		.thumb_func
 6936              	UTIL1_Init:
 6937              	.LFB64:
2522:../Generated_Code/UTIL1.c **** 
2523:../Generated_Code/UTIL1.c **** /*
2524:../Generated_Code/UTIL1.c **** ** ===================================================================
2525:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Init (component Utility)
2526:../Generated_Code/UTIL1.c **** **     Description :
2527:../Generated_Code/UTIL1.c **** **         Driver Initialization
2528:../Generated_Code/UTIL1.c **** **     Parameters  : None
2529:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2530:../Generated_Code/UTIL1.c **** ** ===================================================================
2531:../Generated_Code/UTIL1.c **** */
2532:../Generated_Code/UTIL1.c **** void UTIL1_Init(void)
2533:../Generated_Code/UTIL1.c **** {
 6938              		.loc 1 2533 0
 6939              		.cfi_startproc
 6940 0000 80B5     		push	{r7, lr}
 6941              	.LCFI191:
 6942              		.cfi_def_cfa_offset 8
 6943              		.cfi_offset 7, -8
 6944              		.cfi_offset 14, -4
 6945 0002 00AF     		add	r7, sp, #0
 6946              	.LCFI192:
 6947              		.cfi_def_cfa_register 7
2534:../Generated_Code/UTIL1.c ****   /* nothing needed */
2535:../Generated_Code/UTIL1.c **** }
 6948              		.loc 1 2535 0
 6949 0004 BD46     		mov	sp, r7
 6950              		@ sp needed for prologue
 6951 0006 80BD     		pop	{r7, pc}
 6952              		.cfi_endproc
 6953              	.LFE64:
 6955              		.section	.text.UTIL1_map,"ax",%progbits
 6956              		.align	2
 6957              		.global	UTIL1_map
 6958              		.code	16
 6959              		.thumb_func
 6961              	UTIL1_map:
 6962              	.LFB65:
2536:../Generated_Code/UTIL1.c **** 
2537:../Generated_Code/UTIL1.c **** /*
2538:../Generated_Code/UTIL1.c **** ** ===================================================================
2539:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_map (component Utility)
2540:../Generated_Code/UTIL1.c **** **     Description :
2541:../Generated_Code/UTIL1.c **** **         Maps a value from one range to another
2542:../Generated_Code/UTIL1.c **** **     Parameters  :
2543:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2544:../Generated_Code/UTIL1.c **** **         x               - value to be mapped
2545:../Generated_Code/UTIL1.c **** **         in_min          - input range minimum value
2546:../Generated_Code/UTIL1.c **** **         in_max          - input range maximum value
2547:../Generated_Code/UTIL1.c **** **         out_min         - output range maximum value
2548:../Generated_Code/UTIL1.c **** **         out_max         - 
2549:../Generated_Code/UTIL1.c **** **     Returns     :
2550:../Generated_Code/UTIL1.c **** **         ---             - remapped value
2551:../Generated_Code/UTIL1.c **** ** ===================================================================
2552:../Generated_Code/UTIL1.c **** */
2553:../Generated_Code/UTIL1.c **** int32_t UTIL1_map(int32_t x, int32_t in_min, int32_t in_max, int32_t out_min, int32_t out_max)
2554:../Generated_Code/UTIL1.c **** {
 6963              		.loc 1 2554 0
 6964              		.cfi_startproc
 6965 0000 80B5     		push	{r7, lr}
 6966              	.LCFI193:
 6967              		.cfi_def_cfa_offset 8
 6968              		.cfi_offset 7, -8
 6969              		.cfi_offset 14, -4
 6970 0002 84B0     		sub	sp, sp, #16
 6971              	.LCFI194:
 6972              		.cfi_def_cfa_offset 24
 6973 0004 00AF     		add	r7, sp, #0
 6974              	.LCFI195:
 6975              		.cfi_def_cfa_register 7
 6976 0006 F860     		str	r0, [r7, #12]
 6977 0008 B960     		str	r1, [r7, #8]
 6978 000a 7A60     		str	r2, [r7, #4]
 6979 000c 3B60     		str	r3, [r7]
2555:../Generated_Code/UTIL1.c **** #if 0 /* original Arduino implementation */
2556:../Generated_Code/UTIL1.c ****   return (x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min;
2557:../Generated_Code/UTIL1.c **** #else /* improved version, see https://github.com/arduino/Arduino/issues/2466 */
2558:../Generated_Code/UTIL1.c ****   if ((in_max - in_min) > (out_max - out_min)) {
 6980              		.loc 1 2558 0
 6981 000e 7A68     		ldr	r2, [r7, #4]
 6982 0010 BB68     		ldr	r3, [r7, #8]
 6983 0012 D21A     		sub	r2, r2, r3
 6984 0014 B969     		ldr	r1, [r7, #24]
 6985 0016 3B68     		ldr	r3, [r7]
 6986 0018 CB1A     		sub	r3, r1, r3
 6987 001a 9A42     		cmp	r2, r3
 6988 001c 14DD     		ble	.L365
2559:../Generated_Code/UTIL1.c ****     return (x - in_min) * (out_max - out_min+1) / (in_max - in_min+1) + out_min;
 6989              		.loc 1 2559 0
 6990 001e FA68     		ldr	r2, [r7, #12]
 6991 0020 BB68     		ldr	r3, [r7, #8]
 6992 0022 D31A     		sub	r3, r2, r3
 6993 0024 B969     		ldr	r1, [r7, #24]
 6994 0026 3A68     		ldr	r2, [r7]
 6995 0028 8A1A     		sub	r2, r1, r2
 6996 002a 0132     		add	r2, r2, #1
 6997 002c 5A43     		mul	r2, r3
 6998 002e 7968     		ldr	r1, [r7, #4]
 6999 0030 BB68     		ldr	r3, [r7, #8]
 7000 0032 CB1A     		sub	r3, r1, r3
 7001 0034 0133     		add	r3, r3, #1
 7002 0036 101C     		mov	r0, r2
 7003 0038 191C     		mov	r1, r3
 7004 003a FFF7FEFF 		bl	__aeabi_idiv
 7005 003e 031C     		mov	r3, r0
 7006 0040 1A1C     		mov	r2, r3
 7007 0042 3B68     		ldr	r3, [r7]
 7008 0044 D318     		add	r3, r2, r3
 7009 0046 11E0     		b	.L366
 7010              	.L365:
2560:../Generated_Code/UTIL1.c ****   } else {
2561:../Generated_Code/UTIL1.c ****     return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 7011              		.loc 1 2561 0
 7012 0048 FA68     		ldr	r2, [r7, #12]
 7013 004a BB68     		ldr	r3, [r7, #8]
 7014 004c D31A     		sub	r3, r2, r3
 7015 004e B969     		ldr	r1, [r7, #24]
 7016 0050 3A68     		ldr	r2, [r7]
 7017 0052 8A1A     		sub	r2, r1, r2
 7018 0054 5A43     		mul	r2, r3
 7019 0056 7968     		ldr	r1, [r7, #4]
 7020 0058 BB68     		ldr	r3, [r7, #8]
 7021 005a CB1A     		sub	r3, r1, r3
 7022 005c 101C     		mov	r0, r2
 7023 005e 191C     		mov	r1, r3
 7024 0060 FFF7FEFF 		bl	__aeabi_idiv
 7025 0064 031C     		mov	r3, r0
 7026 0066 1A1C     		mov	r2, r3
 7027 0068 3B68     		ldr	r3, [r7]
 7028 006a D318     		add	r3, r2, r3
 7029              	.L366:
2562:../Generated_Code/UTIL1.c ****   }
2563:../Generated_Code/UTIL1.c **** #endif
2564:../Generated_Code/UTIL1.c **** }
 7030              		.loc 1 2564 0
 7031 006c 181C     		mov	r0, r3
 7032 006e BD46     		mov	sp, r7
 7033 0070 04B0     		add	sp, sp, #16
 7034              		@ sp needed for prologue
 7035 0072 80BD     		pop	{r7, pc}
 7036              		.cfi_endproc
 7037              	.LFE65:
 7039              		.section	.text.UTIL1_constrain,"ax",%progbits
 7040              		.align	2
 7041              		.global	UTIL1_constrain
 7042              		.code	16
 7043              		.thumb_func
 7045              	UTIL1_constrain:
 7046              	.LFB66:
2565:../Generated_Code/UTIL1.c **** 
2566:../Generated_Code/UTIL1.c **** /*
2567:../Generated_Code/UTIL1.c **** ** ===================================================================
2568:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_constrain (component Utility)
2569:../Generated_Code/UTIL1.c **** **     Description :
2570:../Generated_Code/UTIL1.c **** **         Makes sure that a given input value is inside a given range.
2571:../Generated_Code/UTIL1.c **** **     Parameters  :
2572:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2573:../Generated_Code/UTIL1.c **** **         val             - input value
2574:../Generated_Code/UTIL1.c **** **         min             - range minimum value
2575:../Generated_Code/UTIL1.c **** **         max             - range maximum value
2576:../Generated_Code/UTIL1.c **** **     Returns     :
2577:../Generated_Code/UTIL1.c **** **         ---             - the constrained value
2578:../Generated_Code/UTIL1.c **** ** ===================================================================
2579:../Generated_Code/UTIL1.c **** */
2580:../Generated_Code/UTIL1.c **** int32_t UTIL1_constrain(int32_t val, int32_t min, int32_t max)
2581:../Generated_Code/UTIL1.c **** {
 7047              		.loc 1 2581 0
 7048              		.cfi_startproc
 7049 0000 80B5     		push	{r7, lr}
 7050              	.LCFI196:
 7051              		.cfi_def_cfa_offset 8
 7052              		.cfi_offset 7, -8
 7053              		.cfi_offset 14, -4
 7054 0002 84B0     		sub	sp, sp, #16
 7055              	.LCFI197:
 7056              		.cfi_def_cfa_offset 24
 7057 0004 00AF     		add	r7, sp, #0
 7058              	.LCFI198:
 7059              		.cfi_def_cfa_register 7
 7060 0006 F860     		str	r0, [r7, #12]
 7061 0008 B960     		str	r1, [r7, #8]
 7062 000a 7A60     		str	r2, [r7, #4]
2582:../Generated_Code/UTIL1.c ****   if (val<min) {
 7063              		.loc 1 2582 0
 7064 000c FA68     		ldr	r2, [r7, #12]
 7065 000e BB68     		ldr	r3, [r7, #8]
 7066 0010 9A42     		cmp	r2, r3
 7067 0012 01DA     		bge	.L368
2583:../Generated_Code/UTIL1.c ****     return min;
 7068              		.loc 1 2583 0
 7069 0014 BB68     		ldr	r3, [r7, #8]
 7070 0016 06E0     		b	.L369
 7071              	.L368:
2584:../Generated_Code/UTIL1.c ****   } else if (val>max) {
 7072              		.loc 1 2584 0
 7073 0018 FA68     		ldr	r2, [r7, #12]
 7074 001a 7B68     		ldr	r3, [r7, #4]
 7075 001c 9A42     		cmp	r2, r3
 7076 001e 01DD     		ble	.L370
2585:../Generated_Code/UTIL1.c ****     return max;
 7077              		.loc 1 2585 0
 7078 0020 7B68     		ldr	r3, [r7, #4]
 7079 0022 00E0     		b	.L369
 7080              	.L370:
2586:../Generated_Code/UTIL1.c ****   }
2587:../Generated_Code/UTIL1.c ****   return val;
 7081              		.loc 1 2587 0
 7082 0024 FB68     		ldr	r3, [r7, #12]
 7083              	.L369:
2588:../Generated_Code/UTIL1.c **** }
 7084              		.loc 1 2588 0
 7085 0026 181C     		mov	r0, r3
 7086 0028 BD46     		mov	sp, r7
 7087 002a 04B0     		add	sp, sp, #16
 7088              		@ sp needed for prologue
 7089 002c 80BD     		pop	{r7, pc}
 7090              		.cfi_endproc
 7091              	.LFE66:
 7093 002e C046     		.section	.text.UTIL1_random,"ax",%progbits
 7094              		.align	2
 7095              		.global	UTIL1_random
 7096              		.code	16
 7097              		.thumb_func
 7099              	UTIL1_random:
 7100              	.LFB67:
2589:../Generated_Code/UTIL1.c **** 
2590:../Generated_Code/UTIL1.c **** /*
2591:../Generated_Code/UTIL1.c **** ** ===================================================================
2592:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_random (component Utility)
2593:../Generated_Code/UTIL1.c **** **     Description :
2594:../Generated_Code/UTIL1.c **** **         Provides a random value. You have to call intialize the
2595:../Generated_Code/UTIL1.c **** **         random number generator with randomSetSeed() first!
2596:../Generated_Code/UTIL1.c **** **     Parameters  :
2597:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2598:../Generated_Code/UTIL1.c **** **         min             - range minimum value
2599:../Generated_Code/UTIL1.c **** **         max             - range maximum value
2600:../Generated_Code/UTIL1.c **** **     Returns     :
2601:../Generated_Code/UTIL1.c **** **         ---             - random value between min and max
2602:../Generated_Code/UTIL1.c **** ** ===================================================================
2603:../Generated_Code/UTIL1.c **** */
2604:../Generated_Code/UTIL1.c **** int32_t UTIL1_random(int32_t min, int32_t max)
2605:../Generated_Code/UTIL1.c **** {
 7101              		.loc 1 2605 0
 7102              		.cfi_startproc
 7103 0000 80B5     		push	{r7, lr}
 7104              	.LCFI199:
 7105              		.cfi_def_cfa_offset 8
 7106              		.cfi_offset 7, -8
 7107              		.cfi_offset 14, -4
 7108 0002 84B0     		sub	sp, sp, #16
 7109              	.LCFI200:
 7110              		.cfi_def_cfa_offset 24
 7111 0004 00AF     		add	r7, sp, #0
 7112              	.LCFI201:
 7113              		.cfi_def_cfa_register 7
 7114 0006 7860     		str	r0, [r7, #4]
 7115 0008 3960     		str	r1, [r7]
2606:../Generated_Code/UTIL1.c ****   int32_t val;
2607:../Generated_Code/UTIL1.c **** 
2608:../Generated_Code/UTIL1.c ****   val = rand()%(max-min+1)+min;
 7116              		.loc 1 2608 0
 7117 000a FFF7FEFF 		bl	rand
 7118 000e 021C     		mov	r2, r0
 7119 0010 3968     		ldr	r1, [r7]
 7120 0012 7B68     		ldr	r3, [r7, #4]
 7121 0014 CB1A     		sub	r3, r1, r3
 7122 0016 0133     		add	r3, r3, #1
 7123 0018 101C     		mov	r0, r2
 7124 001a 191C     		mov	r1, r3
 7125 001c FFF7FEFF 		bl	__aeabi_idivmod
 7126 0020 0B1C     		mov	r3, r1
 7127 0022 1A1C     		mov	r2, r3
 7128 0024 7B68     		ldr	r3, [r7, #4]
 7129 0026 D318     		add	r3, r2, r3
 7130 0028 FB60     		str	r3, [r7, #12]
2609:../Generated_Code/UTIL1.c ****   return UTIL1_constrain(val, min, max);
 7131              		.loc 1 2609 0
 7132 002a F968     		ldr	r1, [r7, #12]
 7133 002c 7A68     		ldr	r2, [r7, #4]
 7134 002e 3B68     		ldr	r3, [r7]
 7135 0030 081C     		mov	r0, r1
 7136 0032 111C     		mov	r1, r2
 7137 0034 1A1C     		mov	r2, r3
 7138 0036 FFF7FEFF 		bl	UTIL1_constrain
 7139 003a 031C     		mov	r3, r0
2610:../Generated_Code/UTIL1.c **** }
 7140              		.loc 1 2610 0
 7141 003c 181C     		mov	r0, r3
 7142 003e BD46     		mov	sp, r7
 7143 0040 04B0     		add	sp, sp, #16
 7144              		@ sp needed for prologue
 7145 0042 80BD     		pop	{r7, pc}
 7146              		.cfi_endproc
 7147              	.LFE67:
 7149              		.section	.text.UTIL1_randomSetSeed,"ax",%progbits
 7150              		.align	2
 7151              		.global	UTIL1_randomSetSeed
 7152              		.code	16
 7153              		.thumb_func
 7155              	UTIL1_randomSetSeed:
 7156              	.LFB68:
2611:../Generated_Code/UTIL1.c **** 
2612:../Generated_Code/UTIL1.c **** /*
2613:../Generated_Code/UTIL1.c **** ** ===================================================================
2614:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_randomSetSeed (component Utility)
2615:../Generated_Code/UTIL1.c **** **     Description :
2616:../Generated_Code/UTIL1.c **** **         Sets a seed for the random number generator
2617:../Generated_Code/UTIL1.c **** **     Parameters  :
2618:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2619:../Generated_Code/UTIL1.c **** **         seed            - seed to be used for random number
2620:../Generated_Code/UTIL1.c **** **                           generator
2621:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
2622:../Generated_Code/UTIL1.c **** ** ===================================================================
2623:../Generated_Code/UTIL1.c **** */
2624:../Generated_Code/UTIL1.c **** void UTIL1_randomSetSeed(unsigned int seed)
2625:../Generated_Code/UTIL1.c **** {
 7157              		.loc 1 2625 0
 7158              		.cfi_startproc
 7159 0000 80B5     		push	{r7, lr}
 7160              	.LCFI202:
 7161              		.cfi_def_cfa_offset 8
 7162              		.cfi_offset 7, -8
 7163              		.cfi_offset 14, -4
 7164 0002 82B0     		sub	sp, sp, #8
 7165              	.LCFI203:
 7166              		.cfi_def_cfa_offset 16
 7167 0004 00AF     		add	r7, sp, #0
 7168              	.LCFI204:
 7169              		.cfi_def_cfa_register 7
 7170 0006 7860     		str	r0, [r7, #4]
2626:../Generated_Code/UTIL1.c ****   srand(seed); /* set random number generator seed */
 7171              		.loc 1 2626 0
 7172 0008 7B68     		ldr	r3, [r7, #4]
 7173 000a 181C     		mov	r0, r3
 7174 000c FFF7FEFF 		bl	srand
2627:../Generated_Code/UTIL1.c **** }
 7175              		.loc 1 2627 0
 7176 0010 BD46     		mov	sp, r7
 7177 0012 02B0     		add	sp, sp, #8
 7178              		@ sp needed for prologue
 7179 0014 80BD     		pop	{r7, pc}
 7180              		.cfi_endproc
 7181              	.LFE68:
 7183              		.global	__aeabi_lmul
 7184              		.global	__aeabi_ldivmod
 7185 0016 C046     		.section	.text.UTIL1_map64,"ax",%progbits
 7186              		.align	2
 7187              		.global	UTIL1_map64
 7188              		.code	16
 7189              		.thumb_func
 7191              	UTIL1_map64:
 7192              	.LFB69:
2628:../Generated_Code/UTIL1.c **** 
2629:../Generated_Code/UTIL1.c **** /*
2630:../Generated_Code/UTIL1.c **** ** ===================================================================
2631:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_map64 (component Utility)
2632:../Generated_Code/UTIL1.c **** **     Description :
2633:../Generated_Code/UTIL1.c **** **         Maps a value from one range to another, using 64bit math
2634:../Generated_Code/UTIL1.c **** **     Parameters  :
2635:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
2636:../Generated_Code/UTIL1.c **** **         x               - value to be mapped
2637:../Generated_Code/UTIL1.c **** **         in_min          - input range minimum value
2638:../Generated_Code/UTIL1.c **** **         in_max          - input range maximum value
2639:../Generated_Code/UTIL1.c **** **         out_min         - output range maximum value
2640:../Generated_Code/UTIL1.c **** **         out_max         - 
2641:../Generated_Code/UTIL1.c **** **     Returns     :
2642:../Generated_Code/UTIL1.c **** **         ---             - remapped value
2643:../Generated_Code/UTIL1.c **** ** ===================================================================
2644:../Generated_Code/UTIL1.c **** */
2645:../Generated_Code/UTIL1.c **** #ifdef __GNUC__ /* HIWARE compiler does not support 64bit data types */
2646:../Generated_Code/UTIL1.c **** int64_t UTIL1_map64(int64_t x, int64_t in_min, int64_t in_max, int64_t out_min, int64_t out_max)
2647:../Generated_Code/UTIL1.c **** {
 7193              		.loc 1 2647 0
 7194              		.cfi_startproc
 7195 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 7196              	.LCFI205:
 7197              		.cfi_def_cfa_offset 20
 7198              		.cfi_offset 4, -20
 7199              		.cfi_offset 5, -16
 7200              		.cfi_offset 6, -12
 7201              		.cfi_offset 7, -8
 7202              		.cfi_offset 14, -4
 7203 0002 87B0     		sub	sp, sp, #28
 7204              	.LCFI206:
 7205              		.cfi_def_cfa_offset 48
 7206 0004 00AF     		add	r7, sp, #0
 7207              	.LCFI207:
 7208              		.cfi_def_cfa_register 7
 7209 0006 3861     		str	r0, [r7, #16]
 7210 0008 7961     		str	r1, [r7, #20]
 7211 000a BA60     		str	r2, [r7, #8]
 7212 000c FB60     		str	r3, [r7, #12]
2648:../Generated_Code/UTIL1.c ****   if ((in_max - in_min) > (out_max - out_min)) {
 7213              		.loc 1 2648 0
 7214 000e 396B     		ldr	r1, [r7, #48]
 7215 0010 7A6B     		ldr	r2, [r7, #52]
 7216 0012 BB68     		ldr	r3, [r7, #8]
 7217 0014 FC68     		ldr	r4, [r7, #12]
 7218 0016 C91A     		sub	r1, r1, r3
 7219 0018 A241     		sbc	r2, r2, r4
 7220 001a 3B6C     		ldr	r3, [r7, #64]
 7221 001c 7C6C     		ldr	r4, [r7, #68]
 7222 001e 3B60     		str	r3, [r7]
 7223 0020 7C60     		str	r4, [r7, #4]
 7224 0022 BB6B     		ldr	r3, [r7, #56]
 7225 0024 FC6B     		ldr	r4, [r7, #60]
 7226 0026 3D68     		ldr	r5, [r7]
 7227 0028 7E68     		ldr	r6, [r7, #4]
 7228 002a ED1A     		sub	r5, r5, r3
 7229 002c A641     		sbc	r6, r6, r4
 7230 002e 2B1C     		mov	r3, r5
 7231 0030 341C     		mov	r4, r6
 7232 0032 A242     		cmp	r2, r4
 7233 0034 02DC     		bgt	.L378
 7234 0036 34D1     		bne	.L375
 7235 0038 9942     		cmp	r1, r3
 7236 003a 32D9     		bls	.L375
 7237              	.L378:
2649:../Generated_Code/UTIL1.c ****     return (x - in_min) * (out_max - out_min+1) / (in_max - in_min+1) + out_min;
 7238              		.loc 1 2649 0
 7239 003c 3969     		ldr	r1, [r7, #16]
 7240 003e 7A69     		ldr	r2, [r7, #20]
 7241 0040 BB68     		ldr	r3, [r7, #8]
 7242 0042 FC68     		ldr	r4, [r7, #12]
 7243 0044 C91A     		sub	r1, r1, r3
 7244 0046 A241     		sbc	r2, r2, r4
 7245 0048 3D6C     		ldr	r5, [r7, #64]
 7246 004a 7E6C     		ldr	r6, [r7, #68]
 7247 004c BB6B     		ldr	r3, [r7, #56]
 7248 004e FC6B     		ldr	r4, [r7, #60]
 7249 0050 ED1A     		sub	r5, r5, r3
 7250 0052 A641     		sbc	r6, r6, r4
 7251 0054 0123     		mov	r3, #1
 7252 0056 0024     		mov	r4, #0
 7253 0058 5B19     		add	r3, r3, r5
 7254 005a 7441     		adc	r4, r4, r6
 7255 005c 081C     		mov	r0, r1
 7256 005e 111C     		mov	r1, r2
 7257 0060 1A1C     		mov	r2, r3
 7258 0062 231C     		mov	r3, r4
 7259 0064 FFF7FEFF 		bl	__aeabi_lmul
 7260 0068 031C     		mov	r3, r0
 7261 006a 0C1C     		mov	r4, r1
 7262 006c 191C     		mov	r1, r3
 7263 006e 221C     		mov	r2, r4
 7264 0070 3D6B     		ldr	r5, [r7, #48]
 7265 0072 7E6B     		ldr	r6, [r7, #52]
 7266 0074 BB68     		ldr	r3, [r7, #8]
 7267 0076 FC68     		ldr	r4, [r7, #12]
 7268 0078 ED1A     		sub	r5, r5, r3
 7269 007a A641     		sbc	r6, r6, r4
 7270 007c 0123     		mov	r3, #1
 7271 007e 0024     		mov	r4, #0
 7272 0080 5B19     		add	r3, r3, r5
 7273 0082 7441     		adc	r4, r4, r6
 7274 0084 081C     		mov	r0, r1
 7275 0086 111C     		mov	r1, r2
 7276 0088 1A1C     		mov	r2, r3
 7277 008a 231C     		mov	r3, r4
 7278 008c FFF7FEFF 		bl	__aeabi_ldivmod
 7279 0090 031C     		mov	r3, r0
 7280 0092 0C1C     		mov	r4, r1
 7281 0094 191C     		mov	r1, r3
 7282 0096 221C     		mov	r2, r4
 7283 0098 BB6B     		ldr	r3, [r7, #56]
 7284 009a FC6B     		ldr	r4, [r7, #60]
 7285 009c 5B18     		add	r3, r3, r1
 7286 009e 5441     		adc	r4, r4, r2
 7287 00a0 35E0     		b	.L377
 7288              	.L375:
2650:../Generated_Code/UTIL1.c ****   } else {
2651:../Generated_Code/UTIL1.c ****     return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 7289              		.loc 1 2651 0
 7290 00a2 3969     		ldr	r1, [r7, #16]
 7291 00a4 7A69     		ldr	r2, [r7, #20]
 7292 00a6 BB68     		ldr	r3, [r7, #8]
 7293 00a8 FC68     		ldr	r4, [r7, #12]
 7294 00aa C91A     		sub	r1, r1, r3
 7295 00ac A241     		sbc	r2, r2, r4
 7296 00ae 3B6C     		ldr	r3, [r7, #64]
 7297 00b0 7C6C     		ldr	r4, [r7, #68]
 7298 00b2 3B60     		str	r3, [r7]
 7299 00b4 7C60     		str	r4, [r7, #4]
 7300 00b6 BB6B     		ldr	r3, [r7, #56]
 7301 00b8 FC6B     		ldr	r4, [r7, #60]
 7302 00ba 3D68     		ldr	r5, [r7]
 7303 00bc 7E68     		ldr	r6, [r7, #4]
 7304 00be ED1A     		sub	r5, r5, r3
 7305 00c0 A641     		sbc	r6, r6, r4
 7306 00c2 2B1C     		mov	r3, r5
 7307 00c4 341C     		mov	r4, r6
 7308 00c6 081C     		mov	r0, r1
 7309 00c8 111C     		mov	r1, r2
 7310 00ca 1A1C     		mov	r2, r3
 7311 00cc 231C     		mov	r3, r4
 7312 00ce FFF7FEFF 		bl	__aeabi_lmul
 7313 00d2 031C     		mov	r3, r0
 7314 00d4 0C1C     		mov	r4, r1
 7315 00d6 191C     		mov	r1, r3
 7316 00d8 221C     		mov	r2, r4
 7317 00da 3B6B     		ldr	r3, [r7, #48]
 7318 00dc 7C6B     		ldr	r4, [r7, #52]
 7319 00de 3B60     		str	r3, [r7]
 7320 00e0 7C60     		str	r4, [r7, #4]
 7321 00e2 BB68     		ldr	r3, [r7, #8]
 7322 00e4 FC68     		ldr	r4, [r7, #12]
 7323 00e6 3D68     		ldr	r5, [r7]
 7324 00e8 7E68     		ldr	r6, [r7, #4]
 7325 00ea ED1A     		sub	r5, r5, r3
 7326 00ec A641     		sbc	r6, r6, r4
 7327 00ee 2B1C     		mov	r3, r5
 7328 00f0 341C     		mov	r4, r6
 7329 00f2 081C     		mov	r0, r1
 7330 00f4 111C     		mov	r1, r2
 7331 00f6 1A1C     		mov	r2, r3
 7332 00f8 231C     		mov	r3, r4
 7333 00fa FFF7FEFF 		bl	__aeabi_ldivmod
 7334 00fe 031C     		mov	r3, r0
 7335 0100 0C1C     		mov	r4, r1
 7336 0102 191C     		mov	r1, r3
 7337 0104 221C     		mov	r2, r4
 7338 0106 BB6B     		ldr	r3, [r7, #56]
 7339 0108 FC6B     		ldr	r4, [r7, #60]
 7340 010a 5B18     		add	r3, r3, r1
 7341 010c 5441     		adc	r4, r4, r2
 7342              	.L377:
2652:../Generated_Code/UTIL1.c ****   }
2653:../Generated_Code/UTIL1.c **** }
 7343              		.loc 1 2653 0
 7344 010e 181C     		mov	r0, r3
 7345 0110 211C     		mov	r1, r4
 7346 0112 BD46     		mov	sp, r7
 7347 0114 07B0     		add	sp, sp, #28
 7348              		@ sp needed for prologue
 7349 0116 F0BD     		pop	{r4, r5, r6, r7, pc}
 7350              		.cfi_endproc
 7351              	.LFE69:
 7353              		.section	.rodata.skew.6402,"a",%progbits
 7354              		.align	2
 7357              	skew.6402:
 7358 0000 00       		.byte	0
 7359 0001 03       		.byte	3
 7360 0002 03       		.byte	3
 7361 0003 06       		.byte	6
 7362 0004 01       		.byte	1
 7363 0005 04       		.byte	4
 7364 0006 06       		.byte	6
 7365 0007 02       		.byte	2
 7366 0008 05       		.byte	5
 7367 0009 00       		.byte	0
 7368 000a 03       		.byte	3
 7369 000b 05       		.byte	5
 7370              		.text
 7371              	.Letext0:
 7372              		.file 2 "D:/Freescale/CodeWarrior11/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 7373              		.file 3 "../Generated_Code/PE_Types.h"
 7374              		.file 4 "D:/Freescale/CodeWarrior11/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
 7375              		.file 5 "../Generated_Code/UTIL1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 UTIL1.c
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:18     .text.UTIL1_strcpy:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:23     .text.UTIL1_strcpy:00000000 UTIL1_strcpy
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:88     .text.UTIL1_strcat:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:93     .text.UTIL1_strcat:00000000 UTIL1_strcat
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:178    .text.UTIL1_chcat:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:183    .text.UTIL1_chcat:00000000 UTIL1_chcat
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:254    .text.UTIL1_Num8uToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:259    .text.UTIL1_Num8uToStr:00000000 UTIL1_Num8uToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:349    .text.UTIL1_Num16uToStr:00000000 UTIL1_Num16uToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:297    .text.UTIL1_Num8sToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:302    .text.UTIL1_Num8sToStr:00000000 UTIL1_Num8sToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:558    .text.UTIL1_Num16sToStr:00000000 UTIL1_Num16sToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:344    .text.UTIL1_Num16uToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:547    .rodata:00000000 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:553    .text.UTIL1_Num16sToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:826    .text.UTIL1_Num16sToStr:000001b0 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:832    .text.ShiftRightAndFill:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:836    .text.ShiftRightAndFill:00000000 ShiftRightAndFill
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:989    .text.UTIL1_Num16sToStrFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:994    .text.UTIL1_Num16sToStrFormatted:00000000 UTIL1_Num16sToStrFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1047   .text.UTIL1_Num16uToStrFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1052   .text.UTIL1_Num16uToStrFormatted:00000000 UTIL1_Num16uToStrFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1104   .text.UTIL1_Num32uToStrFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1109   .text.UTIL1_Num32uToStrFormatted:00000000 UTIL1_Num32uToStrFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2444   .text.UTIL1_Num32uToStr:00000000 UTIL1_Num32uToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1158   .text.UTIL1_Num32sToStrFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1163   .text.UTIL1_Num32sToStrFormatted:00000000 UTIL1_Num32sToStrFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2182   .text.UTIL1_Num32sToStr:00000000 UTIL1_Num32sToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1212   .text.UTIL1_strcatNum8u:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1217   .text.UTIL1_strcatNum8u:00000000 UTIL1_strcatNum8u
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1263   .text.UTIL1_strcatNum8s:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1268   .text.UTIL1_strcatNum8s:00000000 UTIL1_strcatNum8s
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1315   .text.UTIL1_strcatNum16u:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1320   .text.UTIL1_strcatNum16u:00000000 UTIL1_strcatNum16u
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1366   .text.UTIL1_strcatNum16s:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1371   .text.UTIL1_strcatNum16s:00000000 UTIL1_strcatNum16s
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1418   .text.UTIL1_strcatNum16uFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1423   .text.UTIL1_strcatNum16uFormatted:00000000 UTIL1_strcatNum16uFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1478   .text.UTIL1_strcatNum16sFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1483   .text.UTIL1_strcatNum16sFormatted:00000000 UTIL1_strcatNum16sFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1539   .text.UTIL1_strcatNum32uFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1544   .text.UTIL1_strcatNum32uFormatted:00000000 UTIL1_strcatNum32uFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1596   .text.UTIL1_strcatNum32sFormatted:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1601   .text.UTIL1_strcatNum32sFormatted:00000000 UTIL1_strcatNum32sFormatted
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1653   .text.UTIL1_strcatNum8Hex:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1658   .text.UTIL1_strcatNum8Hex:00000000 UTIL1_strcatNum8Hex
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1759   .text.UTIL1_strcatNum16Hex:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1764   .text.UTIL1_strcatNum16Hex:00000000 UTIL1_strcatNum16Hex
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1867   .text.UTIL1_strcatNum24Hex:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1872   .text.UTIL1_strcatNum24Hex:00000000 UTIL1_strcatNum24Hex
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1971   .text.UTIL1_strcatNum32Hex:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:1976   .text.UTIL1_strcatNum32Hex:00000000 UTIL1_strcatNum32Hex
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2075   .text.UTIL1_strcatNum32s:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2080   .text.UTIL1_strcatNum32s:00000000 UTIL1_strcatNum32s
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2124   .text.UTIL1_strcatNum32u:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2129   .text.UTIL1_strcatNum32u:00000000 UTIL1_strcatNum32u
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2177   .text.UTIL1_Num32sToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2434   .text.UTIL1_Num32sToStr:00000190 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2439   .text.UTIL1_Num32uToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2635   .text.UTIL1_IsLeapYear:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2640   .text.UTIL1_IsLeapYear:00000000 UTIL1_IsLeapYear
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2708   .text.UTIL1_WeekDay:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2713   .text.UTIL1_WeekDay:00000000 UTIL1_WeekDay
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2855   .text.UTIL1_WeekDay:000000e8 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7357   .rodata.skew.6402:00000000 skew.6402
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2865   .text.UTIL1_ReadEscapedName:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:2870   .text.UTIL1_ReadEscapedName:00000000 UTIL1_ReadEscapedName
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3117   .text.UTIL1_ReadEscapedName:00000158 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3122   .text.UTIL1_xatoi:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3127   .text.UTIL1_xatoi:00000000 UTIL1_xatoi
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3462   .text.UTIL1_ScanDate:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3467   .text.UTIL1_ScanDate:00000000 UTIL1_ScanDate
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3903   .text.UTIL1_ScanDecimal8uNumber:00000000 UTIL1_ScanDecimal8uNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4169   .text.UTIL1_ScanDecimal16uNumber:00000000 UTIL1_ScanDecimal16uNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3641   .text.UTIL1_ScanDate:000000fc $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3646   .text.UTIL1_ScanTime:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3651   .text.UTIL1_ScanTime:00000000 UTIL1_ScanTime
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:3898   .text.UTIL1_ScanDecimal8uNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4032   .text.UTIL1_ScanDecimal8sNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4037   .text.UTIL1_ScanDecimal8sNumber:00000000 UTIL1_ScanDecimal8sNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4164   .text.UTIL1_ScanDecimal16uNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4298   .text.UTIL1_ScanDecimal16sNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4303   .text.UTIL1_ScanDecimal16sNumber:00000000 UTIL1_ScanDecimal16sNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4430   .text.UTIL1_ScanDecimal32uNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4435   .text.UTIL1_ScanDecimal32uNumber:00000000 UTIL1_ScanDecimal32uNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4563   .text.UTIL1_ScanDecimal32sNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4568   .text.UTIL1_ScanDecimal32sNumber:00000000 UTIL1_ScanDecimal32sNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4689   .text.UTIL1_ScanDecimal32sDotNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4694   .text.UTIL1_ScanDecimal32sDotNumber:00000000 UTIL1_ScanDecimal32sDotNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4832   .text.isHexCharacter:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4836   .text.isHexCharacter:00000000 isHexCharacter
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4906   .text.PreScanHexNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4910   .text.PreScanHexNumber:00000000 PreScanHexNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4986   .text.HexToDec:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:4990   .text.HexToDec:00000000 HexToDec
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5117   .text.UTIL1_ScanHex32uNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5122   .text.UTIL1_ScanHex32uNumber:00000000 UTIL1_ScanHex32uNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5230   .text.UTIL1_ScanHex16uNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5235   .text.UTIL1_ScanHex16uNumber:00000000 UTIL1_ScanHex16uNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5345   .text.UTIL1_ScanHex8uNumber:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5350   .text.UTIL1_ScanHex8uNumber:00000000 UTIL1_ScanHex8uNumber
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5460   .text.UTIL1_ScanHex8uNumberNoPrefix:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5465   .text.UTIL1_ScanHex8uNumberNoPrefix:00000000 UTIL1_ScanHex8uNumberNoPrefix
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5576   .text.UTIL1_strtailcmp:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5581   .text.UTIL1_strtailcmp:00000000 UTIL1_strtailcmp
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5662   .text.UTIL1_strCutTail:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5667   .text.UTIL1_strCutTail:00000000 UTIL1_strCutTail
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5730   .text.UTIL1_strcatNum32sDotValue100:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5735   .text.UTIL1_strcatNum32sDotValue100:00000000 UTIL1_strcatNum32sDotValue100
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5823   .text.UTIL1_strFind:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5828   .text.UTIL1_strFind:00000000 UTIL1_strFind
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5910   .text.UTIL1_strFind:00000070 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5915   .text.UTIL1_ScanSeparatedNumbers:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:5920   .text.UTIL1_ScanSeparatedNumbers:00000000 UTIL1_ScanSeparatedNumbers
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6072   .text.UTIL1_ScanDoubleQuotedString:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6077   .text.UTIL1_ScanDoubleQuotedString:00000000 UTIL1_ScanDoubleQuotedString
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6199   .text.UTIL1_strcatPad:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6204   .text.UTIL1_strcatPad:00000000 UTIL1_strcatPad
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6368   .text.UTIL1_NumFloatToStr:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6373   .text.UTIL1_NumFloatToStr:00000000 UTIL1_NumFloatToStr
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6559   .text.UTIL1_NumFloatToStr:00000130 $d
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6564   .text.UTIL1_strcatNumFloat:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6569   .text.UTIL1_strcatNumFloat:00000000 UTIL1_strcatNumFloat
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6617   .text.UTIL1_GetValue16LE:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6622   .text.UTIL1_GetValue16LE:00000000 UTIL1_GetValue16LE
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6658   .text.UTIL1_GetValue24LE:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6663   .text.UTIL1_GetValue24LE:00000000 UTIL1_GetValue24LE
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6702   .text.UTIL1_GetValue32LE:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6707   .text.UTIL1_GetValue32LE:00000000 UTIL1_GetValue32LE
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6751   .text.UTIL1_SetValue16LE:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6756   .text.UTIL1_SetValue16LE:00000000 UTIL1_SetValue16LE
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6799   .text.UTIL1_SetValue24LE:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6804   .text.UTIL1_SetValue24LE:00000000 UTIL1_SetValue24LE
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6849   .text.UTIL1_SetValue32LE:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6854   .text.UTIL1_SetValue32LE:00000000 UTIL1_SetValue32LE
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6906   .text.UTIL1_Deinit:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6911   .text.UTIL1_Deinit:00000000 UTIL1_Deinit
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6931   .text.UTIL1_Init:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6936   .text.UTIL1_Init:00000000 UTIL1_Init
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6956   .text.UTIL1_map:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:6961   .text.UTIL1_map:00000000 UTIL1_map
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7040   .text.UTIL1_constrain:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7045   .text.UTIL1_constrain:00000000 UTIL1_constrain
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7094   .text.UTIL1_random:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7099   .text.UTIL1_random:00000000 UTIL1_random
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7150   .text.UTIL1_randomSetSeed:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7155   .text.UTIL1_randomSetSeed:00000000 UTIL1_randomSetSeed
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7186   .text.UTIL1_map64:00000000 $t
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7191   .text.UTIL1_map64:00000000 UTIL1_map64
C:\Users\David\AppData\Local\Temp\cc9KdjJT.s:7354   .rodata.skew.6402:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
__aeabi_uidiv
__aeabi_idivmod
__aeabi_idiv
strchr
strlen
strncmp
__aeabi_fcmplt
__aeabi_f2iz
__aeabi_ui2f
__aeabi_fsub
__aeabi_fmul
__aeabi_f2uiz
rand
srand
__aeabi_lmul
__aeabi_ldivmod
